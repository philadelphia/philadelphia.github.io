<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Retrofit 源码分析 | philadelphia</title>
<meta name="description" content="德不孤，必有邻">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://philadelphia.github.io/favicon.ico?v=1607249706546">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://philadelphia.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://philadelphia.github.io">
        <img src="https://philadelphia.github.io/images/avatar.png?v=1607249706546" class="site-logo">
        <h1 class="site-title">philadelphia</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            基础知识
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      德不孤，必有邻
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://philadelphia.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Retrofit 源码分析</h2>
            <div class="post-date">2019-08-16</div>
            
            <div class="post-content">
              <h1 id="简介">简介</h1>
<p>retrofit是square出品的一个优秀的网络框架，注意，不是一个网络引擎。它的定位和Volley是一样的。</p>
<p>它完成了封装请求，线程切换，数据装换等一系列工作，如果自己有能力也可以封装一个这种框架，本质上是没有区别的。</p>
<p>retrofit使用的网络引擎是OkHttp.</p>
<p>而OKHttp和HTTPClient，HttpUrlConnection是一个级别的。</p>
<p>#使用</p>
<pre><code class="language-java">//1 创建网络请求接口类
public interface GitHubService {
  @GET(&quot;users/{user}/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}

//2 创建Retrofit实例对象
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
     .addConverterFactory(GsonConverterFactory.create())
     .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
    .build();

//3 通过动态代理创建网络接口代理对象
GitHubService service = retrofit.create(GitHubService.class);

//4 获取Call对象
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);

//5	执行同步请求或异步请求
repos.execute();
repos.enqueue(callback)
</code></pre>
<h1 id="retrofit">Retrofit</h1>
<p>Retrofit也是使用Build模式创建的。</p>
<p>![屏幕快照 2019-01-11 下午3.12.35](/Users/meiliwu/Desktop/屏幕快照 2019-01-11 下午3.12.35.png)</p>
<p>builder类有这些方法。从图表可以看出，我们可以调用client方法传入一个我们自定义的OkhttpClient,</p>
<p>调用baseUrl方法传入Host,最后调动build方法生成一个Retrofit 对象</p>
<pre><code class="language-java">public Retrofit build() {
    //baseUrl是必须的
  if (baseUrl == null) {
    throw new IllegalStateException(&quot;Base URL required.&quot;);
  }

   //如果没有设置callFactory对象，系统自动生成一个OkhttpClient对象.因为OKHttpclient实现了			Call.Factory接口
   // public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory
  okhttp3.Call.Factory callFactory = this.callFactory;
  if (callFactory == null) {
    callFactory = new OkHttpClient();
  }

  //如果没有设置callbackExecutor，系统自动生成一个，platform.defaultCallbackExecutor，这个platform是无参构造方法里调用Platform.get()方法得到的。
    /** 
    public Builder() {
      this(Platform.get());
    }**/
    
  Executor callbackExecutor = this.callbackExecutor;
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  // Make a defensive copy of the adapters and add the default Call adapter.
  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

  // Make a defensive copy of the converters.
  List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

  return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
      callbackExecutor, validateEagerly);
}
</code></pre>
<h1 id="platform">Platform</h1>
<pre><code class="language-java">class Platform {
  private static final Platform PLATFORM = findPlatform();

  static Platform get() {
    return PLATFORM;
  }

  private static Platform findPlatform() {
    try {
      Class.forName(&quot;android.os.Build&quot;);
      if (Build.VERSION.SDK_INT != 0) {
        return new Android();
      }
    } catch (ClassNotFoundException ignored) {
    }
    try {
      Class.forName(&quot;java.util.Optional&quot;);
      return new Java8();
    } catch (ClassNotFoundException ignored) {
    }
    try {
        //怎么还有IOS代码呢？
      Class.forName(&quot;org.robovm.apple.foundation.NSObject&quot;);
      return new IOS();
    } catch (ClassNotFoundException ignored) {
    }
    return new Platform();
  }

  Executor defaultCallbackExecutor() {
    return null;
  }

  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
    if (callbackExecutor != null) {
      return new ExecutorCallAdapterFactory(callbackExecutor);
    }
    return DefaultCallAdapterFactory.INSTANCE;
  }

  boolean isDefaultMethod(Method method) {
    return false;
  }

  Object invokeDefaultMethod(Method method, Class&lt;?&gt; declaringClass, Object object, Object... args)
      throws Throwable {
    throw new UnsupportedOperationException();
  }

  static class Android extends Platform {
    @Override public Executor defaultCallbackExecutor() {
      return new MainThreadExecutor();
    }

    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
      return new ExecutorCallAdapterFactory(callbackExecutor);
    }

    static class MainThreadExecutor implements Executor {
      private final Handler handler = new Handler(Looper.getMainLooper());

      @Override public void execute(Runnable r) {
        handler.post(r);
      }
    }
  }
}
</code></pre>
<p>Retrofit 要求必须将请求API写到一个interface接口文件里，这是动态代理特性要求的。</p>
<p>从接口文件里我们可以看到，我们将每个请求用这种形式表达</p>
<pre><code class="language-Java">public interface GitHubService {
	@GET(&quot;users/{user}/repos&quot;)
	Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}		

</code></pre>
<p>从接口文件我们可以看出，一个请求接口被各种注解所表示。</p>
<p>我们知道一个方法有一下关键字段组成</p>
<p>首先一个方法必须有描述符，返回值，方法名，参数类型，参数构成。</p>
<p>那我们用一个方法表示一个http请求需要哪些东西呢？</p>
<p>Http请求，首先我们得知道是GET请求还是POST请求，</p>
<p>然后就是请求头信息，请求路径，查询参数等等。</p>
<p>POST请求还需要Body。</p>
<p>Retrofit 已经提供了足够的注解来表示一个方法。</p>
<p>Retrofit的核心思想AOP，面向切面变成，通过动态代理的反射，将接口文件里的每个方法记性处理，也就是分析该方法的注解生成一个ServiceMethod类。</p>
<p>Retrofit 里有个关键的类，ServiceMethod</p>
<pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety.
public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service);
  if (validateEagerly) {
    eagerlyValidateMethods(service);
  }
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
        private final Platform platform = Platform.get();

        @Override public Object invoke(Object proxy, Method method, Object... args)
            throws Throwable {
          // If the method is a method from Object then defer to normal invocation.
          if (method.getDeclaringClass() == Object.class) {
            return method.invoke(this, args);
          }
          if (platform.isDefaultMethod(method)) {
            return platform.invokeDefaultMethod(method, service, proxy, args);
          }
            //创建ServiceMethod对象
          ServiceMethod serviceMethod = loadServiceMethod(method);
          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
          return serviceMethod.callAdapter.adapt(okHttpCall);
        }
      });
}
</code></pre>
<p>从第3步我们可以看出create方法的实现就是使用了动态代理，在运行时生成了GitHubService对象。</p>
<p>//创建ServiceMethod对象<br>
ServiceMethod serviceMethod = loadServiceMethod(method);</p>
<pre><code class="language-java">ServiceMethod loadServiceMethod(Method method) {
  ServiceMethod result;
  synchronized (serviceMethodCache) {
  //先从换从中取改方法对应的ServiceMethod对象，如果为null就构建一个ServiceMethod对象并存入到map中，如果不为null直接返回
    result = serviceMethodCache.get(method);
    if (result == null) {
      result = new ServiceMethod.Builder(this, method).build();
      serviceMethodCache.put(method, result);
    }
  }
  return result;
}
</code></pre>
<p>我们可以看到loadServiceMethod(Method method)方法返回了一个ServiceMethod对象<br>
这个serviceMethodCache对象是Retrofit的一个字段，是一个Map集合。</p>
<p><code>private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</code></p>
<p>将接口文件里每个方法转换为一个ServiceMethod对象后放入改map中作为缓存，下次调用该方法后就不用再次解析改方法对象了，直接从改map里去以方法为key去取对应的ServiceMethod就行了。666</p>
<p>接下来看一下ServiceMethod对象的构造</p>
<h1 id="servicemethod">ServiceMethod</h1>
<pre><code class="language-java">final class ServiceMethod&lt;T&gt; {
  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
  static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;
  static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\{(&quot; + PARAM + &quot;)\\}&quot;);
  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);

  final okhttp3.Call.Factory callFactory;
  final CallAdapter&lt;?&gt; callAdapter;

  private final HttpUrl baseUrl; 主机地址
  private final Converter&lt;ResponseBody, T&gt; responseConverter;
  private final String httpMethod; 
  private final String relativeUrl; 相对路径
  private final Headers headers;    请求头部信息
  private final MediaType contentType; 请求参数类型
  private final boolean hasBody;  是否有请求体
  private final boolean isFormEncoded; 是否是格式化的表单
  private final boolean isMultipart; 是不是分块
  private final ParameterHandler&lt;?&gt;[] parameterHandlers;

  ServiceMethod(Builder&lt;T&gt; builder) {
    this.callFactory = builder.retrofit.callFactory();
    this.callAdapter = builder.callAdapter;
    this.baseUrl = builder.retrofit.baseUrl();
    this.responseConverter = builder.responseConverter;
    this.httpMethod = builder.httpMethod;
    this.relativeUrl = builder.relativeUrl;
    this.headers = builder.headers;
    this.contentType = builder.contentType;
    this.hasBody = builder.hasBody;
    this.isFormEncoded = builder.isFormEncoded;
    this.isMultipart = builder.isMultipart;
    this.parameterHandlers = builder.parameterHandlers;
  }
}
</code></pre>
<p>ServiceMethod是采用Builder模式创建的。</p>
<pre><code class="language-java">static final class Builder&lt;T&gt; {
  final Retrofit retrofit;
  final Method method; 		//接口里生命的方法
  final Annotation[] methodAnnotations;  //方法的注解，get/post/header之类的
  final Annotation[][] parameterAnnotationsArray; //方法的参数注解数组，二维数组
  final Type[] parameterTypes;  //方法的参数数组

  Type responseType;
  boolean gotField;
  boolean gotPart;
  boolean gotBody;
  boolean gotPath;
  boolean gotQuery;
  boolean gotUrl;
  String httpMethod;
  boolean hasBody;
  boolean isFormEncoded;
  boolean isMultipart;
  String relativeUrl;
  Headers headers;
  MediaType contentType;
  Set&lt;String&gt; relativeUrlParamNames;
  ParameterHandler&lt;?&gt;[] parameterHandlers;
  Converter&lt;ResponseBody, T&gt; responseConverter;
  CallAdapter&lt;?&gt; callAdapter;

  public Builder(Retrofit retrofit, Method method) {
    this.retrofit = retrofit;
    this.method = method;
    this.methodAnnotations = method.getAnnotations(); //获取方法的注解
    this.parameterTypes = method.getGenericParameterTypes(); //获取被注解修饰的方法，一个数组
    this.parameterAnnotationsArray = method.getParameterAnnotations(); //获取方法的参数注解信息，是一个二维数组
  }
</code></pre>
<p>Builder的构造参数需要一个Retrofit对象和一个Method对象。</p>
<p>首先解析方法对象，将其注解和参数注解放到对应的数组里。</p>
<p>首先在构造方法里获取该方法的注解,方法的参数，以及每个参数的注解。</p>
<p>关键就在build方法，在build方法里对方法做了一个彻底的分解</p>
<pre><code class="language-java">public ServiceMethod build() {
  //1 处理返回结果，做一定的转换
  callAdapter = createCallAdapter();
  responseType = callAdapter.responseType();
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;'&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;' is not a valid response body type. Did you mean ResponseBody?&quot;);
  }
  responseConverter = createResponseConverter();

    //2提取方法的注解
  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }
	//如果httpMethod为null，即没有使用方法类型注解修饰，抛出异常进行提示
  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }
//如果没有请求体，即使用了GET，HEAD，DELETE，OPTIONS等所修饰，即不涉及到表单的提交，但是同时使用了Multipart，或者FormUrlEncoded所修饰，就报错
  if (!hasBody) {
    if (isMultipart) {
      throw methodError(
          &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);
    }
    if (isFormEncoded) {
      throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;
          + &quot;request body (e.g., @POST).&quot;);
    }
  }

  //3提取方法的参数
  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  //相对路径为null且gotURL为false的话，抛出异常，因为没有相对路径无法请求。
  if (relativeUrl == null &amp;&amp; !gotUrl) {
    throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);
  }
  //没有使用@FormUrlEncoded，@Multipart主机并且hasBody为false，但是gotBody为true，抛出异常，提示
    Non-Body类型的HTTP method 不能参数不能使用@Body注解
  if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) {
    throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);
  }
  //使用@FormUrlEncoded修饰的方法中的参数至少有一个参数被@Field注解修饰
  if (isFormEncoded &amp;&amp; !gotField) {
    throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);
  }
    
  //使用@Multipart修饰的方法中的参数至少有一个参数被@Part注解修饰
  if (isMultipart &amp;&amp; !gotPart) {
    throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);
  }

 //4 当前Builder对象初始化完毕，可以用来够着ServiceMethod对象。
  return new ServiceMethod&lt;&gt;(this);
}
</code></pre>
<h2 id="处理返回结果">处理返回结果</h2>
<pre><code class="language-java">private CallAdapter&lt;?&gt; createCallAdapter() {
  //获取方法的返回结果,如果有不能解析的类型则抛出异常，也就是说接口中定义的方法的返回值不能使用泛型
  Type returnType = method.getGenericReturnType();
  if (Utils.hasUnresolvableType(returnType)) {
    throw methodError(
        &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
  }
   //接口里的方法不能返回void
  if (returnType == void.class) {
    throw methodError(&quot;Service methods cannot return void.&quot;);
  }
  Annotation[] annotations = method.getAnnotations();
  try {
    return retrofit.callAdapter(returnType, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
    //用户自定义的Adapter可能不能正确的处理返回结果，这时候抛出异常
    throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);
  }
}
</code></pre>
<h2 id="解析方法注解">解析方法注解</h2>
<p>1处处理方法的注解，就是先处理GET/POST/Header等注解信息</p>
<pre><code>private void parseMethodAnnotation(Annotation annotation) {
  if (annotation instanceof DELETE) {
    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
  } else if (annotation instanceof GET) {
    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
  } else if (annotation instanceof HEAD) {
    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);
    if (!Void.class.equals(responseType)) {
      throw methodError(&quot;HEAD method must use Void as response type.&quot;);
    }
  } else if (annotation instanceof PATCH) {
    parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);
  } else if (annotation instanceof POST) {
    parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
  } else if (annotation instanceof PUT) {
    parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);
  } else if (annotation instanceof OPTIONS) {
    parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);
  } else if (annotation instanceof HTTP) {
    HTTP http = (HTTP) annotation;
    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
  } else if (annotation instanceof retrofit2.http.Headers) {
  headers注解
    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    if (headersToParse.length == 0) {
      throw methodError(&quot;@Headers annotation is empty.&quot;);
    }
    headers = parseHeaders(headersToParse);
  } else if (annotation instanceof Multipart) {//如果是Multipart注解
    if (isFormEncoded) {
    //如果同时使用了FormUrlEncoded注解报错
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isMultipart = true;
  } else if (annotation instanceof FormUrlEncoded) {
    if (isMultipart) {
    //如果同时使用了Multipart注解报错,从这我们可以看出一个方法不能同时被Multipart和FormUrlEncoded所修饰
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isFormEncoded = true;
  }
}
</code></pre>
<p>然后根据具体的注解类型，在做进一步的处理，这里主要分析GET/POST/HEADER/ 等注解</p>
<h3 id="get">@GET</h3>
<pre><code class="language-java">else if (annotation instanceof GET) {
  parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
} 
</code></pre>
<p>get类型的请求，没有请求体</p>
<pre><code class="language-java">private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
 //如果该Builder已经有HTTPMethod了就不能改变了，直接抛异常
    if (this.httpMethod != null) {
    throw methodError(&quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,
        this.httpMethod, httpMethod);
  }
  //将HTTPMethod赋值给httpMethod对象，Get、Post、Delete等
  this.httpMethod = httpMethod;
  this.hasBody = hasBody;//是否有请求体

    //如果value为null，返回，因为value参数的值其实就是relativeURL。所以不能为null
  if (value.isEmpty()) {
    return;
  }

  // Get the relative URL path and existing query string, if present.
  int question = value.indexOf('?');
  if (question != -1 &amp;&amp; question &lt; value.length() - 1) {
    // Ensure the query string does not have any named parameters.
    String queryParams = value.substring(question + 1);
      //获取查询参数
    Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
    if (queryParamMatcher.find()) {
        //如果在value里面找到里查询参数的话，抛出异常。因为查询参数可以使用@Query注解来动态配置。
      throw methodError(&quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;
          + &quot;For dynamic query parameters use @Query.&quot;, queryParams);
    }
  }

  this.relativeUrl = value; //将value赋值给relativeUrl
  this.relativeUrlParamNames = parsePathParameters(value); //获取value里面的path占位符，如果有的话
}
</code></pre>
<p>再来看下解析value里的path占位符的方法。</p>
<pre><code>/**
获取已知URI里面的路径集合，如果一个参数被使用了两次，它只会在set中出现一次，好拗口啊，使用LinkedHashSet来保存path参数集合，保证了路径参数的顺序。
 * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
 * in the URI, it will only show up once in the set.
 */
static Set&lt;String&gt; parsePathParameters(String path) {
  Matcher m = PARAM_URL_REGEX.matcher(path);
  Set&lt;String&gt; patterns = new LinkedHashSet&lt;&gt;();
  while (m.find()) {
    patterns.add(m.group(1));
  }
  return patterns;
}
</code></pre>
<p>至此，GET方法的相关的注解分析完毕</p>
<h3 id="post">@POST</h3>
<pre><code class="language-Java">else if (annotation instanceof POST) {
  parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
} 
</code></pre>
<p>POST类型的请求，没有请求体。所以hasBody参数为true。</p>
<p>parseHttpMethodAndPath()方法已将在GET方法里面分析过了，这里面都一样。</p>
<p>其他的请求类型也是大同小异。</p>
<p>然后接着分析方法的Header注解</p>
<h3 id="headers">@Headers</h3>
<pre><code class="language-java">else if (annotation instanceof retrofit2.http.Headers) {
 //   首先获取Headers注解的值，是一个字符串数组。
  String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    如果header注解长度为0，抛出异常，所以使用了header注解必须设置值，不能存在空的header
  if (headersToParse.length == 0) {
    throw methodError(&quot;@Headers annotation is empty.&quot;);
  }
    处理header信息，我猜肯定是一个map
  headers = parseHeaders(headersToParse);
</code></pre>
<p>啊，居然不是，666.因为header不是KV结构的数据类型，而是一个key可以对应多个值。理论上可以使用Map&lt;String,Set<String>&gt;表示。</p>
<pre><code>private Headers parseHeaders(String[] headers) {
  Headers.Builder builder = new Headers.Builder();
  for (String header : headers) {
  // header以“:&quot;分割，前面是key,后面是value
    int colon = header.indexOf(':');
    if (colon == -1 || colon == 0 || colon == header.length() - 1) {
    //header必须是key:value格式表示，不然报错
      throw methodError(
          &quot;@Headers value must be in the form \&quot;Name: Value\&quot;. Found: \&quot;%s\&quot;&quot;, header);
    }
    String headerName = header.substring(0, colon); //key值
    String headerValue = header.substring(colon + 1).trim(); //value值，必须是一个数组，艹，又猜错了。
    if (&quot;Content-Type&quot;.equalsIgnoreCase(headerName)) {
    //遇到&quot;Content-Type&quot;字段。还需要获得具体的MediaType。
      MediaType type = MediaType.parse(headerValue);
      if (type == null) {
      //如果mediaType为null。抛出一个type畸形的错误。
        throw methodError(&quot;Malformed content type: %s&quot;, headerValue);
      }
      contentType = type;
    } else {
    将header的key和value加入到Builder里面。
      builder.add(headerName, headerValue);
    }
  }
  最后调用build方法生成一个Header对爱。
  return builder.build();
}
</code></pre>
<pre><code class="language-java">/**
 * Add a header with the specified name and value. Does validation of header names and values.
 */
public Builder add(String name, String value) {
  checkNameAndValue(name, value);
  return addLenient(name, value);
}
</code></pre>
<pre><code class="language-Java">Builder addLenient(String name, String value) {
  namesAndValues.add(name);
  namesAndValues.add(value.trim());
  return this;
}
</code></pre>
<pre><code class="language-java">final List&lt;String&gt; namesAndValues = new ArrayList&lt;&gt;(20);
</code></pre>
<p>namesAndValues是Header.Builder类的一种子段。可见在Builder内部header信息是按照key/value异常放到一个String集合里面的。为什么不放到一个Map里面呢，不懂。</p>
<p>总之，最后就是讲方法的Headers注解信息提取完毕。</p>
<h2 id="处理方法参数">处理方法参数</h2>
<pre><code class="language-java">int parameterCount = parameterAnnotationsArray.length; //求得数组的长度
parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
for (int p = 0; p &lt; parameterCount; p++) {
  Type parameterType = parameterTypes[p]; //便利参数，依次处理参数
    //如果参数不能解析，抛出异常
  if (Utils.hasUnresolvableType(parameterType)) {
    throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
        parameterType);
  }
//获取第p个参数的注解数组，如果没有注解抛出异常，可见，使用了Retrofit，接口方法中每个参数都必须使用注解进行修饰。
  Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
  if (parameterAnnotations == null) {
    throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
  }

   //解析方法中的参数，存入parameterHandlers[]数组中。
  parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
}
</code></pre>
<h2 id="参数校验">参数校验</h2>
<p>Utils.hasUnresolvableType(parameterType)，这个方法是对参数的类型做个校验。</p>
<pre><code>static boolean hasUnresolvableType(Type type) {
  //如果参数是引用数据类型，返回false，可见，接口定义中方法的参数只能是基本数据类型
  if (type instanceof Class&lt;?&gt;) {
    return false;
  }
  //如果参数是泛型
  if (type instanceof ParameterizedType) {
    ParameterizedType parameterizedType = (ParameterizedType) type;
    //去除泛型类中的实际类型，遍历
    for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
    //如果有一个泛型参数是基本数据类型，返回true，都不是返回false
      if (hasUnresolvableType(typeArgument)) {
        return true;
      }
    }
    return false;
  }
  //如果参数是泛型数组类型
  if (type instanceof GenericArrayType) {
    return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
  }
  if (type instanceof TypeVariable) {
    return true;
  }
  if (type instanceof WildcardType) {
    return true;
  }
  String className = type == null ? &quot;null&quot; : type.getClass().getName();
  throw new IllegalArgumentException(&quot;Expected a Class, ParameterizedType, or &quot;
      + &quot;GenericArrayType, but &lt;&quot; + type + &quot;&gt; is of type &quot; + className);
}

</code></pre>
<h2 id="解析参数">解析参数</h2>
<pre><code class="language-java">parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
private ParameterHandler&lt;?&gt; parseParameter(
        int p, Type parameterType, Annotation[] annotations) {
      ParameterHandler&lt;?&gt; result = null;
    //遍历参数的注解数组，调用parseParameterAnnotation()
      for (Annotation annotation : annotations) {
        ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(
            p, parameterType, annotations, annotation);
		//如果该注解没有返回，则解析下一个注解
        if (annotationAction == null) {
          continue;
        }

        if (result != null) {
          throw parameterError(p, &quot;Multiple Retrofit annotations found, only one allowed.&quot;);
        }
		
        result = annotationAction; //将解析的结果赋值给Result
      }

    //如果注解为null，抛出异常。这个地方永远不会调用，因为在获取注解数组之前就做过判断了，如果注解数组为null，直接抛异常，Line197-Line200 in ServiceMethod.Builder中
      if (result == null) {
        throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
      }

      return result;
    }
</code></pre>
<h2 id="获取参数注解信息">获取参数注解信息</h2>
<p>再来看看parseParameterAnnotation()方法,内容略多</p>
<pre><code class="language-Java">private ParameterHandler&lt;?&gt; parseParameterAnnotation(
    int p, Type type, Annotation[] annotations, Annotation annotation) {
  if (annotation instanceof Url) {
      //如果使用了Url注解，
    if (gotUrl) {
        //如果gotUrl为true，因为gotURL默认为false，说明之前处理过Url注解了,抛出多个@Url注解异常
      throw parameterError(p, &quot;Multiple @Url method annotations found.&quot;);
    }
    if (gotPath) {
        //如果gotPath为true，抛出异常，说明@Path注解不能和@Url注解一起使用
      throw parameterError(p, &quot;@Path parameters may not be used with @Url.&quot;);
    }
    if (gotQuery) {
        //如果gotQuery为true，抛出异常，说明@Url注解不能用在@Query注解后面
      throw parameterError(p, &quot;A @Url parameter must not come after a @Query&quot;);
    }
    if (relativeUrl != null) {
        //如果relativeUrl不为null,抛出异常，说明使用了@Url注解，relativeUrl必须为null
      throw parameterError(p, &quot;@Url cannot be used with @%s URL&quot;, httpMethod);
    }

    gotUrl = true;
      
----------------------------------------------------------------------------------------    
      //如果参数类型是HttpURL，String，URI或者参数类型是“android.net.Uri&quot;,返回ParameterHandler.RelativeUrl()，实际是交由这个类处理
    if (type == HttpUrl.class
        || type == String.class
        || type == URI.class
        || (type instanceof Class &amp;&amp; &quot;android.net.Uri&quot;.equals(((Class&lt;?&gt;) type).getName()))) {
      return new ParameterHandler.RelativeUrl();
    } else {
        //不然就抛出异常，也就是说@Url注解必须使用在okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri 这几种类型的参数上。
      throw parameterError(p,
          &quot;@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.&quot;);
    }
------------------------------------------------------------------------------------------
  } else if (annotation instanceof Path) { //@Path注解
     //如果gotQuery为true。抛出异常，因为@Path修饰的参数是路径的占位符。不是查询参数，不能使用@Query注解修饰
    if (gotQuery) {
      throw parameterError(p, &quot;A @Path parameter must not come after a @Query.&quot;);
    }
    if (gotUrl) {
      throw parameterError(p, &quot;@Path parameters may not be used with @Url.&quot;);
    }
      //如果相对路径为null，那@path注解也就无意义了。
    if (relativeUrl == null) {
      throw parameterError(p, &quot;@Path can only be used with relative url on @%s&quot;, httpMethod);
    }
    gotPath = true;

    Path path = (Path) annotation;
    String name = path.value(); //获取@Path注解的值
    validatePathName(p, name); //对改值进行校验，1该value必须是合法字符，2:该相对路径必须包含相应的占位符
 
      //然后将改参数的所有注解进行处理，最终调用ParameterHandler.Path进行处理。
    Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);
    return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded());

  } else if (annotation instanceof Query) { //Query注解，看不太懂，最后也是调用ParameterHandler.Query进行处理
    Query query = (Query) annotation;
    String name = query.value();
    boolean encoded = query.encoded();

    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    gotQuery = true;
    if (Iterable.class.isAssignableFrom(rawParameterType)) {
      if (!(type instanceof ParameterizedType)) {
        throw parameterError(p, rawParameterType.getSimpleName()
            + &quot; must include generic type (e.g., &quot;
            + rawParameterType.getSimpleName()
            + &quot;&lt;String&gt;)&quot;);
      }
      ParameterizedType parameterizedType = (ParameterizedType) type;
      Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(iterableType, annotations);
      return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();
    } else if (rawParameterType.isArray()) {
      Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(arrayComponentType, annotations);
      return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).array();
    } else {
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(type, annotations);
      return new ParameterHandler.Query&lt;&gt;(name, converter, encoded);
    }

  } else if (annotation instanceof QueryMap) {
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@QueryMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p, &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;
    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@QueryMap keys must be of type String: &quot; + keyType);
    }
    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    Converter&lt;?, String&gt; valueConverter =
        retrofit.stringConverter(valueType, annotations);

    return new ParameterHandler.QueryMap&lt;&gt;(valueConverter, ((QueryMap) annotation).encoded());

  } else if (annotation instanceof Header) {
    Header header = (Header) annotation;
    String name = header.value();

    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (Iterable.class.isAssignableFrom(rawParameterType)) {
      if (!(type instanceof ParameterizedType)) {
        throw parameterError(p, rawParameterType.getSimpleName()
            + &quot; must include generic type (e.g., &quot;
            + rawParameterType.getSimpleName()
            + &quot;&lt;String&gt;)&quot;);
      }
      ParameterizedType parameterizedType = (ParameterizedType) type;
      Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(iterableType, annotations);
      return new ParameterHandler.Header&lt;&gt;(name, converter).iterable();
    } else if (rawParameterType.isArray()) {
      Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(arrayComponentType, annotations);
      return new ParameterHandler.Header&lt;&gt;(name, converter).array();
    } else {
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(type, annotations);
      return new ParameterHandler.Header&lt;&gt;(name, converter);
    }

  } else if (annotation instanceof HeaderMap) {
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@HeaderMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p, &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;
    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@HeaderMap keys must be of type String: &quot; + keyType);
    }
    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    Converter&lt;?, String&gt; valueConverter =
        retrofit.stringConverter(valueType, annotations);

    return new ParameterHandler.HeaderMap&lt;&gt;(valueConverter);

  } else if (annotation instanceof Field) {
    if (!isFormEncoded) {
      throw parameterError(p, &quot;@Field parameters can only be used with form encoding.&quot;);
    }
    Field field = (Field) annotation;
    String name = field.value();
    boolean encoded = field.encoded();

    gotField = true;

    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (Iterable.class.isAssignableFrom(rawParameterType)) {
      if (!(type instanceof ParameterizedType)) {
        throw parameterError(p, rawParameterType.getSimpleName()
            + &quot; must include generic type (e.g., &quot;
            + rawParameterType.getSimpleName()
            + &quot;&lt;String&gt;)&quot;);
      }
      ParameterizedType parameterizedType = (ParameterizedType) type;
      Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(iterableType, annotations);
      return new ParameterHandler.Field&lt;&gt;(name, converter, encoded).iterable();
    } else if (rawParameterType.isArray()) {
      Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(arrayComponentType, annotations);
      return new ParameterHandler.Field&lt;&gt;(name, converter, encoded).array();
    } else {
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(type, annotations);
      return new ParameterHandler.Field&lt;&gt;(name, converter, encoded);
    }

  } else if (annotation instanceof FieldMap) {
    if (!isFormEncoded) {
      throw parameterError(p, &quot;@FieldMap parameters can only be used with form encoding.&quot;);
    }
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@FieldMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p,
          &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;
    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@FieldMap keys must be of type String: &quot; + keyType);
    }
    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    Converter&lt;?, String&gt; valueConverter =
        retrofit.stringConverter(valueType, annotations);

    gotField = true;
    return new ParameterHandler.FieldMap&lt;&gt;(valueConverter, ((FieldMap) annotation).encoded());

  } else if (annotation instanceof Part) {
    if (!isMultipart) {
      throw parameterError(p, &quot;@Part parameters can only be used with multipart encoding.&quot;);
    }
    Part part = (Part) annotation;
    gotPart = true;

    String partName = part.value();
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (partName.isEmpty()) {
      if (Iterable.class.isAssignableFrom(rawParameterType)) {
        if (!(type instanceof ParameterizedType)) {
          throw parameterError(p, rawParameterType.getSimpleName()
              + &quot; must include generic type (e.g., &quot;
              + rawParameterType.getSimpleName()
              + &quot;&lt;String&gt;)&quot;);
        }
        ParameterizedType parameterizedType = (ParameterizedType) type;
        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
          throw parameterError(p,
              &quot;@Part annotation must supply a name or use MultipartBody.Part parameter type.&quot;);
        }
        return ParameterHandler.RawPart.INSTANCE.iterable();
      } else if (rawParameterType.isArray()) {
        Class&lt;?&gt; arrayComponentType = rawParameterType.getComponentType();
        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
          throw parameterError(p,
              &quot;@Part annotation must supply a name or use MultipartBody.Part parameter type.&quot;);
        }
        return ParameterHandler.RawPart.INSTANCE.array();
      } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
        return ParameterHandler.RawPart.INSTANCE;
      } else {
        throw parameterError(p,
            &quot;@Part annotation must supply a name or use MultipartBody.Part parameter type.&quot;);
      }
    } else {
      Headers headers =
          Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + partName + &quot;\&quot;&quot;,
              &quot;Content-Transfer-Encoding&quot;, part.encoding());

      if (Iterable.class.isAssignableFrom(rawParameterType)) {
        if (!(type instanceof ParameterizedType)) {
          throw parameterError(p, rawParameterType.getSimpleName()
              + &quot; must include generic type (e.g., &quot;
              + rawParameterType.getSimpleName()
              + &quot;&lt;String&gt;)&quot;);
        }
        ParameterizedType parameterizedType = (ParameterizedType) type;
        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
          throw parameterError(p, &quot;@Part parameters using the MultipartBody.Part must not &quot;
              + &quot;include a part name in the annotation.&quot;);
        }
        Converter&lt;?, RequestBody&gt; converter =
            retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
        return new ParameterHandler.Part&lt;&gt;(headers, converter).iterable();
      } else if (rawParameterType.isArray()) {
        Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
          throw parameterError(p, &quot;@Part parameters using the MultipartBody.Part must not &quot;
              + &quot;include a part name in the annotation.&quot;);
        }
        Converter&lt;?, RequestBody&gt; converter =
            retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
        return new ParameterHandler.Part&lt;&gt;(headers, converter).array();
      } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
        throw parameterError(p, &quot;@Part parameters using the MultipartBody.Part must not &quot;
            + &quot;include a part name in the annotation.&quot;);
      } else {
        Converter&lt;?, RequestBody&gt; converter =
            retrofit.requestBodyConverter(type, annotations, methodAnnotations);
        return new ParameterHandler.Part&lt;&gt;(headers, converter);
      }
    }

  } else if (annotation instanceof PartMap) {
    if (!isMultipart) {
      throw parameterError(p, &quot;@PartMap parameters can only be used with multipart encoding.&quot;);
    }
    gotPart = true;
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@PartMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p, &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;

    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@PartMap keys must be of type String: &quot; + keyType);
    }

    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
      throw parameterError(p, &quot;@PartMap values cannot be MultipartBody.Part. &quot;
          + &quot;Use @Part List&lt;Part&gt; or a different value type instead.&quot;);
    }

    Converter&lt;?, RequestBody&gt; valueConverter =
        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);

    PartMap partMap = (PartMap) annotation;
    return new ParameterHandler.PartMap&lt;&gt;(valueConverter, partMap.encoding());

  } else if (annotation instanceof Body) {
    if (isFormEncoded || isMultipart) {
      throw parameterError(p,
          &quot;@Body parameters cannot be used with form or multi-part encoding.&quot;);
    }
    if (gotBody) {
      throw parameterError(p, &quot;Multiple @Body method annotations found.&quot;);
    }

    Converter&lt;?, RequestBody&gt; converter;
    try {
      converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
    } catch (RuntimeException e) {
      // Wide exception range because factories are user code.
      throw parameterError(e, p, &quot;Unable to create @Body converter for %s&quot;, type);
    }
    gotBody = true;
    return new ParameterHandler.Body&lt;&gt;(converter);
  }

  return null; // Not a Retrofit annotation.找不到该注解
}
</code></pre>
<p>从上面可以看出，改立参数注解的套路就是：先判断该注解的类型，然后使用策略模式分别调用ParameterHandler里对应的子类来处理</p>
<p>写到这里我已经晕了。晕晕乎乎好舒服</p>
<h3 id="header">@Header</h3>
<h4 id="使用场景">使用场景</h4>
<p>有时候我们需要动态的设置请求header中的某个请求头的值，这个时候就可以使用@Header来修饰个参数。</p>
<p>最终都是讲header里的信息提取到Request里面</p>
<pre><code class="language-java">static final class Header&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name;
  private final Converter&lt;T, String&gt; valueConverter;

  Header(String name, Converter&lt;T, String&gt; valueConverter) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) return; // Skip null values.
    builder.addHeader(name, valueConverter.convert(value));
  }
}
</code></pre>
<pre><code class="language-java">void addHeader(String name, String value) {
  if (&quot;Content-Type&quot;.equalsIgnoreCase(name)) {
    MediaType type = MediaType.parse(value);
    if (type == null) {
      throw new IllegalArgumentException(&quot;Malformed content type: &quot; + value);
    }
    contentType = type;
  } else {
    requestBuilder.addHeader(name, value);
  }
}
</code></pre>
<p>调用requestBuilder.addHeader()方法。</p>
<p>这个requestBuilder是OKHttp中Request的内部静态类Builder类的一个对象。</p>
<pre><code>private final Request.Builder requestBuilder;
</code></pre>
<p>从中我们可以看出最后将@Header注释的参数的值解析后添加到Request对象中的Header信息里。</p>
<h3 id="path">@Path</h3>
<h4 id="使用场景-2">使用场景</h4>
<p>有时候请求路径是不定的，即请求路径里的某个segment是变化的，也就是需要我们使用参数来动态的改变，这个时候我们就需要使用@Path 来修饰这个参数</p>
<pre><code class="language-java">static final class Path&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name; //参数名，占位符
  private final Converter&lt;T, String&gt; valueConverter;
  private final boolean encoded; //是否编码

  Path(String name, Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) {
      throw new IllegalArgumentException(
          &quot;Path parameter \&quot;&quot; + name + &quot;\&quot; value must not be null.&quot;);
    }
    builder.addPathParam(name, valueConverter.convert(value), encoded);
  }
}
</code></pre>
<pre><code class="language-java">void addPathParam(String name, String value, boolean encoded) {
  if (relativeUrl == null) {
    // The relative URL is cleared when the first query parameter is set.
    throw new AssertionError();
  }
   //将占位符”{name}”使用value替换
  relativeUrl = relativeUrl.replace(&quot;{&quot; + name + &quot;}&quot;, canonicalizeForPath(value, encoded));
}
</code></pre>
<h3 id="query">@Query</h3>
<h4 id="使用场景-3">使用场景</h4>
<p>@Query用来修饰接口方法中的查询字段</p>
<pre><code class="language-java">static final class Query&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name;
  private final Converter&lt;T, String&gt; valueConverter;
  private final boolean encoded;

  Query(String name, Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) return; // Skip null values.
    builder.addQueryParam(name, valueConverter.convert(value), encoded);
  }
}
</code></pre>
<pre><code class="language-Java">//将查询参数组合到相对路径上。
void addQueryParam(String name, String value, boolean encoded) {
  if (relativeUrl != null) {
    // Do a one-time combination of the built relative URL and the base URL.
    urlBuilder = baseUrl.newBuilder(relativeUrl);
    if (urlBuilder == null) {
      throw new IllegalArgumentException(
          &quot;Malformed URL. Base: &quot; + baseUrl + &quot;, Relative: &quot; + relativeUrl);
    }
    relativeUrl = null;
  }

  if (encoded) {
    urlBuilder.addEncodedQueryParameter(name, value);
  } else {
    urlBuilder.addQueryParameter(name, value);
  }
}
</code></pre>
<h3 id="querymap">@QueryMap</h3>
<h4 id="使用场景-4">使用场景</h4>
<p>当接口中的一个 方法有比较多的查询字段时，全部定义到方法中时比较麻烦且容易出错，这个使用我们完全可以将所有的查询参数放到一个Map里面。</p>
<p>可想而知，其内部实现必定是遍历map ，然后像处理@Query参数一样调用addQueryParam()处理每个查询参数。</p>
<pre><code>static final class FieldMap&lt;T&gt; extends ParameterHandler&lt;Map&lt;String, T&gt;&gt; {
  private final Converter&lt;T, String&gt; valueConverter;
  private final boolean encoded;

  FieldMap(Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, Map&lt;String, T&gt; value) throws IOException {
    if (value == null) {
      throw new IllegalArgumentException(&quot;Field map was null.&quot;);
    }

    for (Map.Entry&lt;String, T&gt; entry : value.entrySet()) {
      String entryKey = entry.getKey();
      if (entryKey == null) {
        throw new IllegalArgumentException(&quot;Field map contained null key.&quot;);
      }
      T entryValue = entry.getValue();
      if (entryValue == null) {
        throw new IllegalArgumentException(
            &quot;Field map contained null value for key '&quot; + entryKey + &quot;'.&quot;);
      }
      //果然不假
      builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
    }
  }
}
</code></pre>
<h3 id="field">@Field</h3>
<h4 id="使用场景-5">使用场景</h4>
<p>@Field注解一般用在表单参数的提交上</p>
<pre><code class="language-java">static final class Field&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name; //参数名字
  private final Converter&lt;T, String&gt; valueConverter; //参数值转换器
  private final boolean encoded; //是否编码

  Field(String name, Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) return; // Skip null values. 所以使用@Field修饰的字段，是不会上传到服务器的。
    //调用ResuestBuilder对象的具体想法来处理@Field修饰的表单字段
    builder.addFormField(name, valueConverter.convert(value), encoded);
  }
}
</code></pre>
<pre><code>void addFormField(String name, String value, boolean encoded) {
//根据参数值是否被编码，调用不同的方法。formBuilder是OKHttp中的一个类。也是使用Builder模式创建的。
  if (encoded) {
    formBuilder.addEncoded(name, value);
  } else {
    formBuilder.add(name, value);
  }
}
</code></pre>
<h3 id="fieldmap">@FieldMap</h3>
<p>@FieldMap</p>
<h4 id="使用场景-6">使用场景</h4>
<p>假如表单参数有很多个，我们可以使用一个Map&lt;String,String&gt;来表示，然后使用@FieldMap注解来修饰该参数就行了。可想而知，如同@QueryMap一样，其内部实现肯定是遍历Map，然后像处理@Field参数一样调用</p>
<p>builder.addFormField(name, valueConverter.convert(value), encoded);</p>
<h3 id="body">@Body</h3>
<h4 id="使用场景-7">使用场景</h4>
<p>在以下需要提交表单的请求里，我们可以使用@Field,@FieldMap,我们还可以使用@Body来修饰我们提交的表单数据，这个时候我们需要定义一个Bean类，Bean类的各个Field必须和表单字段的key一样</p>
<pre><code class="language-java">static final class Body&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final Converter&lt;T, RequestBody&gt; converter;

  Body(Converter&lt;T, RequestBody&gt; converter) {
    this.converter = converter;
  }

  @Override void apply(RequestBuilder builder, T value) {
    if (value == null) {
      throw new IllegalArgumentException(&quot;Body parameter value must not be null.&quot;);
    }
    RequestBody body;
    try {
      body = converter.convert(value);
    } catch (IOException e) {
      throw new RuntimeException(&quot;Unable to convert &quot; + value + &quot; to RequestBody&quot;, e);
    }
    builder.setBody(body);
  }
}
</code></pre>
<p>这里Retrofit并没有像@Field一样处理表单参数。仔细想想也对，因为凡是提交的表单数据都需要放到请求体里面，即使使用@Field，@FieldMap提交的数据，最终还是需要放到请求体里面。</p>
<h3 id="part">@Part</h3>
<h3 id="rawpart">@RawPart</h3>
<h3 id="partmap">@PartMap</h3>
<p>以上三个注解都是使用修饰上传文件的参数的，</p>
<h3 id="结论">结论</h3>
<p>从对上面的分析可以知道，我们在提取使用注解修饰的参数后将值存放到RequestBuilder对象里。</p>
<p>这里又引入了RequestBuilder类</p>
<h1 id="requestbuilder">RequestBuilder</h1>
<pre><code class="language-java">final class RequestBuilder {
  private static final char[] HEX_DIGITS =
      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = &quot; \&quot;&lt;&gt;^`{}|\\?#&quot;;

  private final String method; //方法类型

  private final HttpUrl baseUrl; //scheme+host
  private String relativeUrl; 	//相对路径
  private HttpUrl.Builder urlBuilder; //URL构造器

  private final Request.Builder requestBuilder; //OkHttp中Request构造器
  private MediaType contentType;		//提交表单的数据类型

  private final boolean hasBody;		//是否有请求体
  private MultipartBody.Builder multipartBuilder; //上传文件的构造器
  private FormBody.Builder formBuilder;				//表单数据的构造器
  private RequestBody body;							//请求体

  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
    this.method = method;
    this.baseUrl = baseUrl;
    this.relativeUrl = relativeUrl;
    this.requestBuilder = new Request.Builder();
    this.contentType = contentType;
    this.hasBody = hasBody;

    if (headers != null) {
      requestBuilder.headers(headers);
    }

    if (isFormEncoded) {
      // Will be set to 'body' in 'build'.
      formBuilder = new FormBody.Builder();
    } else if (isMultipart) {
      // Will be set to 'body' in 'build'.
      multipartBuilder = new MultipartBody.Builder();
      multipartBuilder.setType(MultipartBody.FORM);
    }
  }

  void setRelativeUrl(Object relativeUrl) {
    if (relativeUrl == null) throw new NullPointerException(&quot;@Url parameter is null.&quot;);
    this.relativeUrl = relativeUrl.toString();
  }

  void addHeader(String name, String value) {
    if (&quot;Content-Type&quot;.equalsIgnoreCase(name)) {
      MediaType type = MediaType.parse(value);
      if (type == null) {
        throw new IllegalArgumentException(&quot;Malformed content type: &quot; + value);
      }
      contentType = type;
    } else {
      requestBuilder.addHeader(name, value);
    }
  }

  void addPathParam(String name, String value, boolean encoded) {
    if (relativeUrl == null) {
      // The relative URL is cleared when the first query parameter is set.
      throw new AssertionError();
    }
    relativeUrl = relativeUrl.replace(&quot;{&quot; + name + &quot;}&quot;, canonicalizeForPath(value, encoded));
  }

  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
    int codePoint;
    for (int i = 0, limit = input.length(); i &lt; limit; i += Character.charCount(codePoint)) {
      codePoint = input.codePointAt(i);
      if (codePoint &lt; 0x20 || codePoint &gt;= 0x7f
          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
          || (!alreadyEncoded &amp;&amp; (codePoint == '/' || codePoint == '%'))) {
        // Slow path: the character at i requires encoding!
        Buffer out = new Buffer();
        out.writeUtf8(input, 0, i);
        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
        return out.readUtf8();
      }
    }

    // Fast path: no characters required encoding.
    return input;
  }

  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
      boolean alreadyEncoded) {
    Buffer utf8Buffer = null; // Lazily allocated.
    int codePoint;
    for (int i = pos; i &lt; limit; i += Character.charCount(codePoint)) {
      codePoint = input.codePointAt(i);
      if (alreadyEncoded
          &amp;&amp; (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
        // Skip this character.
      } else if (codePoint &lt; 0x20 || codePoint &gt;= 0x7f
          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
          || (!alreadyEncoded &amp;&amp; (codePoint == '/' || codePoint == '%'))) {
        // Percent encode this character.
        if (utf8Buffer == null) {
          utf8Buffer = new Buffer();
        }
        utf8Buffer.writeUtf8CodePoint(codePoint);
        while (!utf8Buffer.exhausted()) {
          int b = utf8Buffer.readByte() &amp; 0xff;
          out.writeByte('%');
          out.writeByte(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0xf]);
          out.writeByte(HEX_DIGITS[b &amp; 0xf]);
        }
      } else {
        // This character doesn't need encoding. Just copy it over.
        out.writeUtf8CodePoint(codePoint);
      }
    }
  }

  void addQueryParam(String name, String value, boolean encoded) {
    if (relativeUrl != null) {
      // Do a one-time combination of the built relative URL and the base URL.
      urlBuilder = baseUrl.newBuilder(relativeUrl);
      if (urlBuilder == null) {
        throw new IllegalArgumentException(
            &quot;Malformed URL. Base: &quot; + baseUrl + &quot;, Relative: &quot; + relativeUrl);
      }
      relativeUrl = null;
    }

    if (encoded) {
      urlBuilder.addEncodedQueryParameter(name, value);
    } else {
      urlBuilder.addQueryParameter(name, value);
    }
  }

  void addFormField(String name, String value, boolean encoded) {
    if (encoded) {
      formBuilder.addEncoded(name, value);
    } else {
      formBuilder.add(name, value);
    }
  }

  void addPart(Headers headers, RequestBody body) {
    multipartBuilder.addPart(headers, body);
  }

  void addPart(MultipartBody.Part part) {
    multipartBuilder.addPart(part);
  }

  void setBody(RequestBody body) {
    this.body = body;
  }

  Request build() {
    HttpUrl url;
    HttpUrl.Builder urlBuilder = this.urlBuilder;
    if (urlBuilder != null) {
      url = urlBuilder.build();
    } else {
      // No query parameters triggered builder creation, just combine the relative URL and base URL.
      url = baseUrl.resolve(relativeUrl);
      if (url == null) {
        throw new IllegalArgumentException(
            &quot;Malformed URL. Base: &quot; + baseUrl + &quot;, Relative: &quot; + relativeUrl);
      }
    }

    RequestBody body = this.body;
    if (body == null) {
      // Try to pull from one of the builders.
      if (formBuilder != null) {
        body = formBuilder.build();
      } else if (multipartBuilder != null) {
        body = multipartBuilder.build();
      } else if (hasBody) {
        // Body is absent, make an empty body.
        body = RequestBody.create(null, new byte[0]);
      }
    }

    MediaType contentType = this.contentType;
    if (contentType != null) {
      if (body != null) {
        body = new ContentTypeOverridingRequestBody(body, contentType);
      } else {
        requestBuilder.addHeader(&quot;Content-Type&quot;, contentType.toString());
      }
    }

    //生成一个Request对象
    return requestBuilder
        .url(url)
        .method(method, body)
        .build();
  }

  private static class ContentTypeOverridingRequestBody extends RequestBody {
    private final RequestBody delegate;
    private final MediaType contentType;

    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
      this.delegate = delegate;
      this.contentType = contentType;
    }

    @Override public MediaType contentType() {
      return contentType;
    }

    @Override public long contentLength() throws IOException {
      return delegate.contentLength();
    }

    @Override public void writeTo(BufferedSink sink) throws IOException {
      delegate.writeTo(sink);
    }
  }
}
</code></pre>
<h1 id="okhttpcall">OkHttpCall</h1>
<pre><code class="language-java">OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre>
<p>在创建了ServiceMethod对象后，使用该ServiceMethod对象和其参数创建一个OKHttPCall对象</p>
<pre><code class="language-java">OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre>
<p>在合适的时候调用ServiceMethod对象的toRequest方法生成一个Request对象，toReques()的内部实现就是调用RequestBuilder对象的build方法。</p>
<pre><code>/** Builds an HTTP request from method arguments. */
Request toRequest(Object... args) throws IOException {
  RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
      contentType, hasBody, isFormEncoded, isMultipart);

  @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;

  int argumentCount = args != null ? args.length : 0;
  if (argumentCount != handlers.length) {
    throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount
        + &quot;) doesn't match expected count (&quot; + handlers.length + &quot;)&quot;);
  }

  for (int p = 0; p &lt; argumentCount; p++) {
    handlers[p].apply(requestBuilder, args[p]);
  }

  return requestBuilder.build();
}
</code></pre>
<p>OkHttpCall 实现了Call接口，这个Call接口和OkHttp中的Call接口一样，毕竟一家公司嘛。</p>
<p>其实就是对OkHttpCall 做了一层包装。</p>
<p>最后方法的执行时通过调用</p>
<pre><code>return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre>
<p>返回接口中方法定义的返回值。</p>
<p>这块的流程就是构造一个OKHttp对象需要使用ServiceMethod对象和相应的参数。</p>
<pre><code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre>
<p>最后创建具体的Call对象时</p>
<pre><code class="language-java">private okhttp3.Call createRawCall() throws IOException {
  Request request = serviceMethod.toRequest(args);
  okhttp3.Call call = serviceMethod.callFactory.newCall(request);
  if (call == null) {
    throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
  }
  return call;
}
</code></pre>
<p>调用了ServiceMethod对象的toRequest方法，然后使用这个request对象创建了一个Call对象。</p>
<pre><code class="language-java">/** Builds an HTTP request from method arguments. */
Request toRequest(Object... args) throws IOException {
  RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
      contentType, hasBody, isFormEncoded, isMultipart);

  @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;

  int argumentCount = args != null ? args.length : 0;
  if (argumentCount != handlers.length) {
    throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount
        + &quot;) doesn't match expected count (&quot; + handlers.length + &quot;)&quot;);
  }

  for (int p = 0; p &lt; argumentCount; p++) {
    handlers[p].apply(requestBuilder, args[p]);
  }
//生成一个Request对象
  return requestBuilder.build();
}
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://philadelphia.github.io/post/okhttp-yuan-ma-fen-xi">
                  <h3 class="post-title">
                    OkHttp 源码分析
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
