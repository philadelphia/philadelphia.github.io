<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philadelphia.github.io</id>
    <title>philadelphia</title>
    <updated>2020-11-17T07:36:47.183Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philadelphia.github.io"/>
    <link rel="self" href="https://philadelphia.github.io/atom.xml"/>
    <subtitle>德不孤，必有邻</subtitle>
    <logo>https://philadelphia.github.io/images/avatar.png</logo>
    <icon>https://philadelphia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, philadelphia</rights>
    <entry>
        <title type="html"><![CDATA[ JetPack 系列之Lifecycle]]></title>
        <id>https://philadelphia.github.io/post/jetpack-xi-lie-zhi-lifecycle</id>
        <link href="https://philadelphia.github.io/post/jetpack-xi-lie-zhi-lifecycle">
        </link>
        <updated>2020-07-10T07:37:26.000Z</updated>
        <content type="html"><![CDATA[<p>在JetPack出来之前，我们在做一些比如BroadCastReceiver 之类的注册/解注册之类的活动都需要在Activity的onResume和OnPause之中做处理。如果在Activity销毁时忘记解绑则会导致内存泄露的风险，进而可能引发OOM。不过google官方现在给Activity提供了Lifecycle的监听的功能，我们只需要监听Activity对应的状态并给它设置一个LifecycleObserver，然后处理相应的逻辑就好了。</p>
<h2 id="lifecycle">Lifecycle</h2>
<pre><code>public abstract class Lifecycle {
   
    @MainThread
    public abstract void addObserver(@NonNull LifecycleObserver observer);

 
    @MainThread
    public abstract void removeObserver(@NonNull LifecycleObserver observer);


    @MainThread
    @NonNull
    public abstract State getCurrentState();

    @SuppressWarnings(&quot;WeakerAccess&quot;)
    public enum Event {
      	ON_CREATE,
        ON_START,
        ON_RESUME,
        ON_PAUSE,
        ON_STOP,
        ON_DESTROY,
        ON_ANY
    }

   
    @SuppressWarnings(&quot;WeakerAccess&quot;)
    public enum State {
        DESTROYED,
        INITIALIZED,
        CREATED,
        STARTED,
        RESUMED;

        public boolean isAtLeast(@NonNull State state) {
            return compareTo(state) &gt;= 0;
        }
    }
}
</code></pre>
<p>Lifecyle 类提供了添加和删除观察者的方法，此外还有两个内部类，Event和Status分别表示生命周期中的事件和状态。</p>
<p>Lifecycle 只有一个直接实现类LifecycleRegistry</p>
<p>负责Lifecycle 的添加，移出观察者。该类的构造方法如下：</p>
<pre><code>public LifecycleRegistry(@NonNull LifecycleOwner provider) {
    mLifecycleOwner = new WeakReference&lt;&gt;(provider);
    mState = INITIALIZED;//将当前状态设置为初始化状态
}
</code></pre>
<h2 id="lifecycleowner">LifecycleOwner</h2>
<p>现在Android 提供了一个LifecycleOwner接口,提供了一个Lifecycle 的拥有者的概念</p>
<pre><code>/**
 * A class that has an Android lifecycle. These events can be used by custom components to
 * handle lifecycle changes without implementing any code inside the Activity or the Fragment.
 *
 * @see Lifecycle
 */
@SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})
public interface LifecycleOwner {
    @NonNull
    Lifecycle getLifecycle();
}

</code></pre>
<p>该接口有以下实现类：</p>
<pre><code>public class SupportActivity extends Activity implements LifecycleOwner, Component {
		......
    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);

    public Lifecycle getLifecycle() {
        return this.mLifecycleRegistry;
    }
    ......
   }
   
  
  //注意改Fragment是support包下面的，原生的Fragment类没有实现该接口
  public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner {
    LifecycleOwner mViewLifecycleOwner;
    ......
    
      public Lifecycle getLifecycle() {
        return this.mLifecycleRegistry;
    }
    
    ......
    
    }
</code></pre>
<p>当我们在需要关注Activity/Fragment的声明周期时可以调用getLifecycle，前提是该对象是包含生命周期的。</p>
<p>SupportActivity/Fragment 继承了该接口，所以我们日常使用的Activity/Fragment(support包下面的) 只要继承了该类就自动具有了获取生命周期的能力。</p>
<p>从该类的提示可知，如果我们想得到一个View的生命周期，只需要View实现该接口即可。</p>
<pre><code>getLifecycle().addObserver(new DefaultLifecycleObserver() {
            @Override
            public void onCreate(@NonNull LifecycleOwner owner) {

            }

            @Override
            public void onStart(@NonNull LifecycleOwner owner) {

            }

            @Override
            public void onResume(@NonNull LifecycleOwner owner) {

            }

            @Override
            public void onPause(@NonNull LifecycleOwner owner) {

            }

            @Override
            public void onStop(@NonNull LifecycleOwner owner) {

            }

            @Override
            public void onDestroy(@NonNull LifecycleOwner owner) {

            }
        });
</code></pre>
<h2 id="lifecycleobserver">LifecycleObserver</h2>
<p>LifecycleObserver 只是一个空的接口，有一个子接口<code>FullLifecycleObserver</code> 共有6个方法。</p>
<pre><code>interface FullLifecycleObserver extends LifecycleObserver {

    void onCreate(LifecycleOwner owner);

    void onStart(LifecycleOwner owner);

    void onResume(LifecycleOwner owner);

    void onPause(LifecycleOwner owner);

    void onStop(LifecycleOwner owner);

    void onDestroy(LifecycleOwner owner);
}
</code></pre>
<p><code>FullLifecycleObserver</code> 又给子类DefaultLifecycleObserver ，DefaultLifecycleObserver依然是一个接口，我们在getLifecycle.addObserver()方法中只需要new 一个该对象并复写我们关注的声明周期回调方法就行了</p>
<p>这里面最重要的就是LifecycleRegistry类。该类在Lifecycle理念里边扮演了极其重要的概念。</p>
<p>到此貌似没有头绪了，那么Activity作为Lifecycle的拥有者，当其生命周期变化时会通知LifecycleObserver 的。那么看看其中有没有处理lifeEvent 的方法，发现了handleLifecycleEvent方法</p>
<pre><code>public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
    State next = getStateAfter(event);
    moveToState(next);
}
</code></pre>
<p>那么该方法在哪里被调用的呢？<br>
<img src="https://philadelphia.github.io/post-images/1594367619096.png" alt=""></p>
<p>可见有四处调用</p>
<h2 id="lifecycledispatcher">LifecycleDispatcher</h2>
<pre><code>/**
 * When initialized, it hooks into the Activity callback of the Application and observes
 * Activities. It is responsible to hook in child-fragments to activities and fragments to report
 * their lifecycle events. Another responsibility of this class is to mark as stopped all lifecycle
 * providers related to an activity as soon it is not safe to run a fragment transaction in this
 * activity.
 */
class LifecycleDispatcher {}
</code></pre>
<p>从该类的注释可以看出：当该类创建时，它hookActivity的回调并观察Activity。它复制Activity的子Fragment 并报告它们的声明周期。该类的另一只职责是：一旦该Activity 不安全地执行Fragment 事务时。它将所有与改Activity相关的Lifecycle provider 的Fragment标记为Stopped 状态</p>
<h2 id="processlifecycleowner">ProcessLifecycleOwner</h2>
<p>该类提供了整个Application进程的声明周期回调</p>
<h2 id="servicelifecycledispatcher">ServiceLifecycleDispatcher</h2>
<pre><code>/**
 * Helper class to dispatch lifecycle events for a service. Use it only if it is impossible
 * to use {@link LifecycleService}.
 */
</code></pre>
<p>该类复制提供Service的声明周期，只有当你使用LifecycleService时，所以以后如果想监听Service的声明周期，就需求我们使用继承LifecycleService的子类了。</p>
<h2 id="reportfragment">ReportFragment</h2>
<p>该类是SupportActivity内部的一个分发初始化lifecycle 事件的内部Fragment，我们使用不到，</p>
<p>我们知道</p>
<p>LifecycleDispatcher 和ProcessLifecycleOwner 分别是监听Activity 和Appliction 的生命周期的，</p>
<p>那么它们是什么时候初始化的呢，既然ProcessLifecycleOwner是监听Application的声明周期的，那么它肯定是在Application对象创建的时候初始化的。</p>
<pre><code>@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public class ProcessLifecycleOwnerInitializer extends ContentProvider {
    @Override
    public boolean onCreate() {
        LifecycleDispatcher.init(getContext());
        ProcessLifecycleOwner.init(getContext());
        return true;
    }
}
</code></pre>
<p>系统提供了一个ContentProvider ，它存在于/app/build/intermediates/manifests/full/debug/AndroidManifest.xml，是我们应用在构建完成之后完整生成的AndroidManifest.xml文件。其中，我们可以找到Lifecycle-Aware组件在AndroidManifest的定义。</p>
<pre><code class="language-java"> &lt;provider
        android:name=&quot;android.arch.lifecycle.ProcessLifecycleOwnerInitializer&quot;
        android:authorities=&quot;com.boohee.one.lifecycle-trojan&quot;
        android:exported=&quot;false&quot;
        android:multiprocess=&quot;true&quot; /&gt;
</code></pre>
<p>ProcessLifecycleOwnerInitializer是ContentProvider的子类，利用其onCreate()生命周期方法，处理Lifecycle组件初始化。因此，这是一种隐式初始化的方式。</p>
<p>在ProcessLifecycleOwnerInitializer的onCreate()方法中调用了</p>
<pre><code>  LifecycleDispatcher.init(getContext());
  ProcessLifecycleOwner.init(getContext());
</code></pre>
<p>看下LifecycleDispatcher的init（）方法：</p>
<pre><code>private static AtomicBoolean sInitialized = new AtomicBoolean(false);

static void init(Context context) {
	//如果已经初始化过了直接return
    if (sInitialized.getAndSet(true)) {
        return;
    }
    然后对该对象设置ActivityLifecycleCallbacks监听
    ((Application) context.getApplicationContext())
            .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());
}
</code></pre>
<p>首先调用sInitialized的getAndSet方法，改变量是个AtomicBoolean类型，初始值是false</p>
<p>它这里注册的是个DispatcherActivityCallback对象，该类继承自EmptyActivityLifecycleCallbacks</p>
<p>EmptyActivityLifecycleCallbacks又实现了Application.ActivityLifecycleCallbacks接口。</p>
<pre><code>@Override
public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
    if (activity instanceof FragmentActivity) {
        ((FragmentActivity) activity).getSupportFragmentManager()
                .registerFragmentLifecycleCallbacks(mFragmentCallback, true);
    }
    ReportFragment.injectIfNeededIn(activity);
}
</code></pre>
<p>其目的是为了监听Fragment的生命周期</p>
<p>当前的Activity对象如果继承自FragmentActivity，那么其内部的Fragment 会设置FragmentLifecycleCallbacks回调。而对于那些没有继承自FragmentActivity的Activity，我们给其内部设置一个 ReportFragmet来监听其生命周期。</p>
<pre><code>// ProcessLifecycleOwner should always correctly work and some activities may not extend
// FragmentActivity from support lib, so we use framework fragments for activities
ProcessLifecycleOwner一般能正常工作，但是一些Activity可能没有继承FragmentActivity,所以我们使用内部Fragment来监听其生命周期
ReportFragment.injectIfNeededIn(activity);
</code></pre>
<h2 id="lifecycle-的分发">Lifecycle 的分发</h2>
<p>从上面的分析可以，当lifecycleOwner 的生命周期事件发生变化时会回调LifecycleRegistry 的handleLifecycleEvent的。在该方法里处理生命周期回调。</p>
<pre><code>public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
    //根据传入的时间得到一个状态值。
    State next = getStateAfter(event);
    moveToState(next);
}
</code></pre>
<pre><code>static State getStateAfter(Event event) {
    switch (event) {
    	//ON_CREATE，ON_STOP 事件发生时将状态设为CREATED
        case ON_CREATE:
        case ON_STOP:
            return CREATED;
     //ON_START，ON_PAUSE 事件发生时将状态设为STARTED
        case ON_START:
        case ON_PAUSE:
            return STARTED;
        case ON_RESUME:
            return RESUMED;
        case ON_DESTROY:
            return DESTROYED;
        case ON_ANY:
            break;
    }
    throw new IllegalArgumentException(&quot;Unexpected event value &quot; + event);
}
</code></pre>
<p>接下来调用moveToState(next);</p>
<pre><code>private void moveToState(State next) {
    if (mState == next) {
        return;
    }
    mState = next;
    if (mHandlingEvent || mAddingObserverCounter != 0) {
        mNewEventOccurred = true;
        // we will figure out what to do on upper level.
        return;
    }
    mHandlingEvent = true;
    sync();
    mHandlingEvent = false;
}
</code></pre>
<pre><code>private void sync() {
		//首先获取LifecycleOwner，如果为null，证明当前Activity 已经被垃圾回收了。直接返回
    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
    if (lifecycleOwner == null) {
        Log.w(LOG_TAG, &quot;LifecycleOwner is garbage collected, you shouldn't try dispatch &quot;
                + &quot;new events from it.&quot;);
        return;
    }
    //同步没有完成前，一直循环
    while (!isSynced()) {
        mNewEventOccurred = false;
        // no need to check eldest for nullability, because isSynced does it for us.
        if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) {
            backwardPass(lifecycleOwner);
        }
        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();
        if (!mNewEventOccurred &amp;&amp; newest != null
                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) {
            forwardPass(lifecycleOwner);
        }
    }
    mNewEventOccurred = false;
}
</code></pre>
<p>至此，我们可以知道，当lifecycle发生变化时，handleLifecycleEvent<br>
会通过 getStateAfter()方法获取当前应处的状态并修改mState值，紧接着遍历所有 ObserverWithState并调用他们的sync方法来同步且通知LifecycleObserver状态发生变化</p>
<h2 id="总结">总结</h2>
<p>最后来总结这个监测的流程</p>
<pre><code>@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public class ProcessLifecycleOwnerInitializer extends ContentProvider {
    @Override
    public boolean onCreate() {
        LifecycleDispatcher.init(getContext());
        ProcessLifecycleOwner.init(getContext());
        return true;
    }
}
</code></pre>
<p>1：在ProcessLifecycleOwnerInitializer首先调用 LifecycleDispatcher.init(getContext());</p>
<p>该方法给每个Acitivity 内部设置一个Fragment。</p>
<p>2： ProcessLifecycleOwner.init(getContext());</p>
<pre><code>  static void init(Context context) {
        sInstance.attach(context);
    }
    
    void attach(Context context) {
        mHandler = new Handler();
        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);
        Application app = (Application) context.getApplicationContext();
        app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {
            @Override
            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                ReportFragment.get(activity).setProcessListener(mInitializationListener);
            }

            @Override
            public void onActivityPaused(Activity activity) {
                activityPaused();
            }

            @Override
            public void onActivityStopped(Activity activity) {
                activityStopped();
            }
        });
    }

</code></pre>
<p>在init 方法中调用attch方法，给Application对象设置ActivityLifecycleCallbacks</p>
<p>当Activity的oncreate()方法调用时,获取Activity对象的ReportFragment。并设置ProcessListener</p>
<pre><code>ReportFragment.get(activity).setProcessListener(mInitializationListener);
</code></pre>
<pre><code>//1：获取Activity内部的ReportFragment
static ReportFragment get(Activity activity) {
    return (ReportFragment) activity.getFragmentManager().findFragmentByTag(
            REPORT_FRAGMENT_TAG);
}
//2：setProcessListener
void setProcessListener(ActivityInitializationListener processListener) {
    mProcessListener = processListener;
}
</code></pre>
<p>然后在ReportFragment对应的声明周期中回调mProcessListener的相关方法并调用dispatch()方法。</p>
<p>比如onStart()方法</p>
<pre><code>  @Override
    public void onStart() {
        super.onStart();
       1： dispatchStart(mProcessListener);
       2： dispatch(Lifecycle.Event.ON_START);
    }
   	//方法1： 
     private void dispatchStart(ActivityInitializationListener listener) {
        if (listener != null) {
            listener.onStart();
        }
    }
    
    //方法2
    private void dispatch(Lifecycle.Event event) {
        Activity activity = getActivity();
        if (activity instanceof LifecycleRegistryOwner) {
            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);
            return;
        }

        if (activity instanceof LifecycleOwner) {
            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();
            if (lifecycle instanceof LifecycleRegistry) {
                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);
            }
        }
    }
</code></pre>
<p>在方法2 void dispatch(Lifecycle.Event event)中</p>
<p>先得到当前的Activity对象，并根据器类型调用其liftLycye 的handleLifecycleEvent(event)方法，这样就将其生命周期事件回调给了LifecycleObserver中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 使用Callable 和Future创建线程]]></title>
        <id>https://philadelphia.github.io/post/shi-yong-callable-he-future-chuang-jian-xian-cheng</id>
        <link href="https://philadelphia.github.io/post/shi-yong-callable-he-future-chuang-jian-xian-cheng">
        </link>
        <updated>2020-06-30T02:25:43.000Z</updated>
        <content type="html"><![CDATA[<p>除了常用的创建线程的方式，我们也可以使用Callable和Future创建线程。前面已经说过，这种方式的本质上和其他创建线程的方式是一致的，只有这种创建线程的方式是可以回去线程的返回结果的。</p>
<p>传统的runnable接口的定义</p>
<pre><code>public interface Runnable {
    /**
     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used
     * to create a thread, starting the thread causes the object's
     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing
     * thread.
     * &lt;p&gt;
     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}
</code></pre>
<p>runnable只提供了一个返回void的run方法，而且执行失败也不会抛出异常。</p>
<p>这就导致使用runnable方式创建的线程执行时我们无法获取到返回值，而且失败我们也无法获取到具体的失败信息。</p>
<p>而且提交到线程池的Runnable任务时无法取消的，这就意味着如果我们想要取消某个任务是不可能的，只能关闭整个线程池。</p>
<p>综合以上，java在JDK1.5退出了Callable和Future。</p>
<pre><code>@FunctionalInterface
public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
</code></pre>
<p>从Callable接口的定义可以看出其支持泛型，返回值类型为传入的泛型参数。而且支持抛出异常。</p>
<p>下面是Future接口的定义</p>
<pre><code>public interface Future&lt;V&gt; {

    /**
     * 尝试去取消整个任务，可能还失败如果该任务已经完成或者已经被取消，或者由于其他原因不能被取消。
     * 取过取消任务成功，整个任务的cancel方法被调用时任务还没有开始。如果这个任务已经启动了，参数 
   	 *	  mayInterruptIfRunning 决定了是否给执行任务的线程发送中断信号。
   	 *	  这个方法返回后，后续的isDone调用总是返回true。
   	 *	  后续的isCancelled调用总是返回true，如果这个方法返回了true。
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns {@code true} if this task was cancelled before it completed
     * normally.
     *
     * @return {@code true} if this task was cancelled before it completed
     */
    boolean isCancelled();

    /**
     * Returns {@code true} if this task completed.
     *
     * Completion may be due to normal termination, an exception, or
     * cancellation -- in all of these cases, this method will return
     * {@code true}.
     *
     * @return {@code true} if this task completed
     */
    boolean isDone();

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     * @throws TimeoutException if the wait timed out
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>Future接口提供了4个方法</p>
<pre><code>boolean cancel(boolean mayInterruptIfRunning);
boolean isCancelled();
boolean isDone();
V get() throws InterruptedException, ExecutionException;
V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
</code></pre>
<h3 id="get">get</h3>
<p>get方法用于获取Callable的执行结果，通常有5中情况发生</p>
<ol>
<li>
<p>任务已经正常结束，此时获取到Callable的返回结果。</p>
</li>
<li>
<p>任务还没有结束，这是很有可能的，因为我么你通常将任务放到线程池中，有可能你调用get方法是，任务还在任务队列中没被执行呢，另外一种情况是任务已经执行了，但是可能需要很长时间才能返回，</p>
<p>这两种情况下，调用get方法时自然是获取不到结果的，都会阻塞当前线程。知道任务完成返回结果。</p>
</li>
<li>
<p>任务执行过程中被cancel，这个时候任务会抛出CancellationException异常</p>
</li>
<li>
<p>任务执行过程中失败，这个时候任务会抛出ExecutionException异常。</p>
</li>
<li>
<p>任务超时。get方法有个带有参数的重载方法。调用带有延迟参数的get方法后，如果在指定时间内任务执行完毕，返回结果，如果任务无法完成工作，直接抛出TimeoutException异常。</p>
</li>
</ol>
<h3 id="isdone">isDone</h3>
<p>用来判断任务是否执行完毕</p>
<p>如果任务完成了返回true。如果任务没有完成返回false。</p>
<p>需要注意的是该方法返回true不代表任务是成功执行了，只代表任务结束了。如果任务执行过程中被取消了。该方法依旧返回true。因为该任务确实执行完毕了，以后不会在被执行了。</p>
<h2 id="用-futuretask-来创建-future">用 FutureTask 来创建 Future</h2>
<pre><code>ExecutorService executorService = Executors.newCachedThreadPool();
Future&lt;Integer&gt; submit = executorService.submit(new Callable&lt;Integer&gt;() {
    @Override
    public Integer call() throws Exception {
        return null;
    }
});
</code></pre>
<p>除了使用线程池提交一个Callable任务会返回一个Future对象外，我们也可以使用FutureTask来获取Future类的结果</p>
<pre><code>Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() {
    @Override
    public Integer call() throws Exception {
        return null;
    }
};
FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(callable);
new Thread(integerFutureTask).start();
</code></pre>
<p>典型用法是，把 Callable 实例当作 FutureTask 构造函数的参数，生成 FutureTask 的对象，然后把这个对象当作一个 Runnable 对象，这里使用了桥接的设计模式。放到线程池中或另起线程去执行，最后还可以通过 FutureTask 获取任务执行的结果。但是使用Future获取结果时需要注意，get方法在没有任务没有执行完毕时会阻塞调用者线程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java-线程基础]]></title>
        <id>https://philadelphia.github.io/post/java-xian-cheng-ji-chu</id>
        <link href="https://philadelphia.github.io/post/java-xian-cheng-ji-chu">
        </link>
        <updated>2020-06-30T02:24:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="创建线程">创建线程</h2>
<p>在java编程中，我们可以继承Tread类并复写其run方法，然后new 一个该对象，并调用其start方法，这样就可以开启一个新线程了。</p>
<p>或者创建实现一个Runnable 接口的类。然后将该对象传递给一个Thread队象。这样也可以开启一个线程。</p>
<p>另外还一个使用线程池创建线程，或者使用带有返回值的Callable创建线程</p>
<p>其实这些方式的本质都是一样的，本质上只有一种创建线程的方式。</p>
<p>我们可以看一下JDK中Thread的定义</p>
<pre><code>public class Thread implements Runnable {

    /* What will be run. */
    private Runnable target;
}
</code></pre>
<p>发现Thread 类也实现了Runnable 接口。那么肯定也复写了run方法。</p>
<p>我们创建Thread对象后需要调用其start方法才能开启线程。看下start方法的定义。</p>
<pre><code>/**
 *	开启线程的执行，JVM 调用当前线程的run方法。
 * Causes this thread to begin execution; the Java Virtual Machine
 * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
 * &lt;p&gt;
 * 结果会有两个线程并发执行。当前线程(调用start方法的线程)和另一个线程(执行run方法的线程)
 * The result is that two threads are running concurrently: the
 * current thread (which returns from the call to the
 * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
 * &lt;code&gt;run&lt;/code&gt; method).
 * &lt;p&gt;
 * 开启一个线程超过一次不合法的。一个线程一旦完成不能重新启动。
 * It is never legal to start a thread more than once.
 * In particular, a thread may not be restarted once it has completed
 * execution.
 *
 * @exception  IllegalThreadStateException  if the thread was already
 *               started.
 * @see        #run()
 * @see        #stop()
 */
public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or &quot;system&quot;
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state &quot;NEW&quot;.
     */
    // Android-changed: Replace unused threadStatus field with started field.
    // The threadStatus field is unused on Android.
    if (started)
        throw new IllegalThreadStateException();

    /* Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    group.add(this);

    // Android-changed: Use field instead of local variable.
    // It is necessary to remember the state of this across calls to this method so that it
    // can throw an IllegalThreadStateException if this method is called on an already
    // started thread.
    started = false;
    try {
        // Android-changed: Use Android specific nativeCreate() method to create/start thread.
        // start0();
        nativeCreate(this, stackSize, daemon);
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
              it will be passed up the call stack */
        }
    }
}
</code></pre>
<p>看下Thread类的run方法。</p>
<pre><code>@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
</code></pre>
<p>可以发现其run方法里面调用了target对象的run 方法，这个target对象就是我们传递进来的runnable对象。</p>
<p>如果我们采用继承Thread 并复写run方法的方式实现线程，这个时候虽然没有target 了，但是我们重写了run方法，所以这个时候jvm调用run的时候实际上执行的是我们复写的run 方法。</p>
<p>所以说这两种创建线程的方法本质上是一种。</p>
<p>实际编程中，受限于java的单继承模型。我们一般使用runnable方式创建线程。</p>
<p>使得Runnable作为一个单独的任务可以被多个线程共同执行，有利于实现并发。提高系统效率、</p>
<p>这样解耦了runnable和Thread。同时提高了程序的灵活性</p>
<p>Thread 类负责线程启动和属性设置等内容，权责分明。而runnable则专注于实现共享资源的操作。</p>
<p>但是如果需要获取到线程的返回结果，那就需要使用Callable 的Future的方式创建线程了。</p>
<h2 id="如何正确的停止一个线程">如何正确的停止一个线程</h2>
<p>通常情况下我们是不需要手动停止一个线程的，而是待其运行完毕后自动结束。但是依然会有许多特殊的情况需要我们提前停止线程，比如：用户突然关闭程序，或程序运行出错重启等</p>
<p>在这种情况下，即将停止的线程在很多业务场景下仍然很有价值。尤其是我们想写一个健壮性很好，能够安全应对各种场景的程序时，正确停止线程就显得格外重要。但是Java 并没有提供简单易用，能够直接安全停止线程的能力。</p>
<p>对接线程而言。最正确的方式是使用Interrupt的方式停止线程。它不会立刻停止线程，而是给需要停止的线程发送一个中断信号通知，而需要被中断的线程是否选择中断。由其自己决定。它可以立即停止，也可以将手头工作做完在停止，这也符合java多线程的初衷。直接停止该线程可能会造成数据丢失。任务执行失败。</p>
<p>实际上java希望线程直接可以相互协作。如果不了解对方的工作而冒然停止了对方。就可能会造成一些线程安全的问题，正确的方法是给对方留出收尾的时间让其对未完成的工作有个保存的机会。</p>
<h2 id="如何用-interrupt-停止线程">如何用 interrupt 停止线程</h2>
<pre><code>while (!Thread.currentThread().islnterrupted() &amp;&amp; more work to do) {
		do more work
}
</code></pre>
<p>一旦调用某个线程的 interrupt() 之后，这个线程的中断标记位就会被设置成 true。每个线程都有这样的标记位，当线程执行时，应该定期检查这个标记位，如果标记位被设置成 true，就说明有程序想终止该线程。回到源码，可以看到在 while 循环体判断语句中，首先通过 Thread.currentThread().isInterrupt() 判断线程是否被中断，随后检查是否还有工作要做。&amp;&amp; 逻辑表示只有当两个判断条件同时满足的情况下，才会去执行下面的工作。</p>
<p>sleep，wait这些让线程阻塞进入休眠状态是，线程依然是可以相应中断的，假如进入休眠状态的线程无法相应中断，只能休眠结束后才能相应中断，这样的话就会导致相应中断不及时，可能带来严重的后果。</p>
<h3 id="线程的六种状态">线程的六种状态</h3>
<p>线程整个生命周期可以分为6不，从Thread.State中可以看出</p>
<pre><code>public enum State {
    /**
     * Thread state for a thread which has not yet started.
     */
    NEW,

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE,

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED,

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
     *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
     *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
     * on an object is waiting for another thread to call
     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
     * is waiting for a specified thread to terminate.
     */
    WAITING,

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
     *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
     *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
     *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
     *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
     * &lt;/ul&gt;
     */
    TIMED_WAITING,

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED;
}
</code></pre>
<ol>
<li>New 新建</li>
<li>Runnable 运行态</li>
<li>Blocked 阻塞装填</li>
<li>Waiting 等待状态</li>
<li>Timed_Waiting 等待超时</li>
<li>Terminated 结束装填</li>
</ol>
<h3 id="new">new</h3>
<p>当常见了Thread 对象后，该线程就进入了新建状态</p>
<h3 id="runnable">Runnable</h3>
<p>当调用了线程对象的start方法后，线程就进入了该状态，Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready</p>
<p>此时线程已经被创建，被添加到等待队列中，等待系统给分配CPU资源。此时线程出入Ready就绪态。</p>
<p>当线程获得CPU资源是，线程进入Running运行态。</p>
<h3 id="blocked">Blocked</h3>
<p>在 Java 中阻塞状态通常不仅仅是 Blocked，实际上它包括三种状态，分别是 Blocked(被阻塞）、Waiting(等待）、Timed Waiting(计时等待），这三 种状态统称为阻塞状态，</p>
<h3 id="waiting">Waiting</h3>
<p>线程进入 Waiting 状态有三种可能性。</p>
<ol>
<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>
<li>LockSupport.park() 方法。</li>
</ol>
<p>刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。</p>
<p>Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。</p>
<h3 id="timed-waiting-限期等待">Timed Waiting 限期等待</h3>
<p>以下情况会让线程进入 Timed Waiting 状态。</p>
<ol>
<li>设置了时间参数的 Thread.sleep(long millis) 方法；</li>
<li>设置了时间参数的 Object.wait(long timeout) 方法；</li>
<li>设置了时间参数的 Thread.join(long millis) 方法；</li>
<li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li>
</ol>
<p>想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。</p>
<p>只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。</p>
<p>如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。</p>
<p>同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。</p>
<p>当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。</p>
<h3 id="terminated">Terminated</h3>
<p>Terminated 终止状态，要想进入这个状态有两种可能。</p>
<ol>
<li>run() 方法执行完毕，线程正常退出。</li>
<li>出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。</li>
</ol>
<p>最后我们再看线程转换的两个注意点。</p>
<p>线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。</p>
<p>线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。</p>
<p>也就是说线程可以再Runnable，Blocked,Waiting，TimedWaiting 状态之间转换</p>
<p>处于Runnable 状态的线程无法获取到锁会进入到Blocked状态，处于Waiting 状态的线程获取锁后会进入到Runnable状态。</p>
<h2 id="waitnotifynotifyall-方法的使用注意事项">wait/notify/notifyAll 方法的使用注意事项</h2>
<p>有三个问题需要注意</p>
<ol>
<li>Q：为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</li>
<li>Q2：为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</li>
<li>Q3：wait/notify 和 sleep 方法的异同？</li>
</ol>
<p>A1:</p>
<p>A2:</p>
<ol>
<li>因为 Java 中每个对象都有一把称之为 monitor 监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait/notify/notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。</li>
<li>因为如果把 wait/notify/notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。</li>
</ol>
<p>A3:</p>
<p>相同点：</p>
<ol>
<li>wait/sleep都可以让线程进入到阻塞</li>
<li>它们都可以响应中断，在等待或者休眠时如果收到中断信号，都会响应中断并抛出InterruptedException异常</li>
</ol>
<p>不同点：</p>
<ol>
<li>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求</li>
<li>wait方法属于对象。它会让线程让出当前持有的对象锁，而sleep属于Thread的方法。不会让线程让出锁。</li>
<li>sleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 内存模型-Java memory model]]></title>
        <id>https://philadelphia.github.io/post/java-nei-cun-mo-xing-java-memory-model</id>
        <link href="https://philadelphia.github.io/post/java-nei-cun-mo-xing-java-memory-model">
        </link>
        <updated>2020-06-29T02:35:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java内存模型">Java内存模型</h1>
<p>Java 里面的内存模型和内存结构是很容易混淆的概念</p>
<h2 id="java内存结构">java内存结构</h2>
<p>java的内存结构指的是JVM虚拟机在运行时的一种内存划分机制。</p>
<p>Java 代码是要运行在虚拟机上的，而虚拟机在执行 Java 程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。在《Java 虚拟机规范（Java SE 8）》中描述了 JVM 运行时内存区域结构可分为以下 6 个区</p>
<h3 id="堆区heap">堆区（Heap）</h3>
<p>堆是存储类实例和数组的，通常是内存中最大的一块。实例很好理解，比如 new Object() 就会生成一个实例；而数组也是保存在堆上面的，因为在 Java 中，数组也是对象。</p>
<h3 id="虚拟机栈java-virtual-machine-stacks">虚拟机栈（Java Virtual Machine Stacks）</h3>
<p>它保存局部变量和部分结果，并在方法调用和返回中起作用。</p>
<h3 id="方法区method-area">方法区（Method Area）</h3>
<p>它存储每个类的结构，例如运行时的常量池、字段和方法数据，以及方法和构造函数的代码，包括用于类初始化以及接口初始化的特殊方法。</p>
<h3 id="本地方法栈native-method-stacks">本地方法栈（Native Method Stacks）</h3>
<p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的 Java 方法服务，而本地方法栈则是为 Native 方法服务。</p>
<h3 id="程序计数器the-pc-register">程序计数器（The PC Register）</h3>
<p>是最小的一块内存区域，它的作用通常是保存当前正在执行的 JVM 指令地址。</p>
<h3 id="运行时常量池run-time-constant-pool">运行时常量池（Run-Time Constant Pool）</h3>
<p>是方法区的一部分，包含多种常量，范围从编译时已知的数字到必须在运行时解析的方法和字段引用。</p>
<p>注意，以上是 Java 虚拟机规范，不同的虚拟机实现会各有不同，一般会遵守规范。</p>
<h2 id="java内存模型-2">java内存模型</h2>
<p>java的内存模型和java的并发编程有关</p>
<p>明白了java的内存模型，有利于我们写出线程安全的代码</p>
<p>java 并发编程里有三个重要的概念</p>
<ol>
<li>有序性</li>
<li>可见性</li>
<li>原子性</li>
</ol>
<p>只要符合以上三个特性，我们这就这个程序是线程安全的。</p>
<h3 id="有序性">有序性</h3>
<p>即程序执行的顺序按照代码的先后顺序执行。</p>
<p>我们知道java源代码在编译器编译后升级java字节码。java字节码在执行的时候会被翻译成具体平台的指令码。然后JVM把这些指令加载到内存执行。但是为了提高效率，JVM在执行时会动态的调整这些指令的加载顺序。但是这样可能会影响到线程的执行结果，在java中主要使用volatile来禁止执行重拍。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<h3 id="可见性">可见性</h3>
<p>因为现在的CPU都是多核的。即使是单核的CPU，因为CPU的运算频率远远超过了内存的读写效率，很多时候CPU计算出的结果写入到内存都需要等待很长时间，为了提高CPU的工作效率，现代的CPU都提供了多级缓存的概念。CPU将结果写入到高速缓存后就接着工作了。这样大大提高了CPU的效率。也提高了系统的效率。然后系统再将结果写入到内存中。</p>
<figure data-type="image" tabindex="1"><img src="https://philadelphia.github.io/post-images/1593398204543.png" alt=""></figure>
<p>在图中，从下往上分别是内存，L3 缓存、L2 缓存、L1 缓存，寄存器，然后最上层是 CPU 的 4个核心。从内存，到 L3 缓存，再到 L2 和 L1 缓存，它们距离 CPU 的核心越来越近了，越靠近核心，其容量就越小，但是速度也越快。正是架由于缓存层的存在，才让我们的 CPU 能发挥出更好的性能。</p>
<p>其实，线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 L3 缓存、L2 缓存、L1 缓存，也就是多级缓存引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。</p>
<h3 id="jmm的抽象主内存和工作内存">JMM的抽象：主内存和工作内存</h3>
<p>什么是主内存和工作内存<br>
Java 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。为了更方便你去理解，可参考下图：<br>
<img src="https://philadelphia.github.io/post-images/1593398249432.png" alt=""></p>
<p>每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的</p>
<h3 id="主内存和工作内存的关系">主内存和工作内存的关系</h3>
<p>JMM 有以下规定：</p>
<p>（1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝；</p>
<p>（2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；</p>
<p>（3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。</p>
<p>听到这里，你对上图的理解可能会更深刻一些，从图中可以看出，每个工作内存中的变量都是对主内存变量的一个拷贝，相当于是一个副本。而且图中没有一条线是可以直接连接各个工作内存的，因为工作内存之间的通信，都需要通过主内存来中转。</p>
<p>所以一个线程对自己工作内存中变量的写入操作是不会即使告知其他线程的。这时如果其他线程也访问了改变量，就有可能引起并发问题。造成数据失真，为了解决这个问题java提出了volatile关键字。使用volatile关键字修饰的变量。在多个线程访问该类型的变量时，当有一个线程修改了该变量的值时，CPU会立刻将该变量的值写入到主内存中，并告知各CPU这个变量的缓存已经失效。其他线程需要使用改变量时就需要从主内存中重新读取。</p>
<h3 id="原子性">原子性</h3>
<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，数据库的事务就是原子性，要么全部成功，要不全部失败，不会一部分成功，一部分失败。</p>
<p>在java中自增自减运算都不是原子操作，所以在并发编程中需要采取额外措施来保证操作的原子性。java的关键字volatile无法保证原子性，它只能保证一致性和可见性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java线程池]]></title>
        <id>https://philadelphia.github.io/post/java-xian-cheng-chi</id>
        <link href="https://philadelphia.github.io/post/java-xian-cheng-chi">
        </link>
        <updated>2020-06-28T06:58:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程池">线程池</h2>
<p>Java最初是没有提供线程池的。<br>
而是只有有线程，从JDK1.5开始java推出了线程池的概念。让我们假设一个场景，如果你需要执行一批任务，你需要创建很多线程来执行这一批任务。可是随着线程数的不断增加，我们发现对线程的管理越来越难，而且很多线程本身执行的时间还没有创建线程，创建线程时会产生系统开销，并且每个线程还会占用一定的内存等资源，更重要的是我们创建如此多的线程也会给稳定性带来危害，因为每个系统中，可创建线程的数量是有一个上限的，不可能无限的创建。线程执行完需要被回收，大量的线程又会给垃圾回收带来压力。但我们的任务确实非常多，如果都在主线程串行执行，那效率也太低了，那应该怎么办呢？于是便诞生了线程池来平衡线程与系统资源之间的关系。</p>
<p>我们来总结下如果每个任务都创建一个线程会带来哪些问题：</p>
<p>第一点，反复创建线程系统开销比较大，每个线程创建和销毁都需要时间，如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。<br>
第二点，过多的线程会占用过多的内存等资源，还会带来过多的上下文切换，同时还会导致系统不稳定</p>
<p>针对上面的两点问题，线程池有两个解决思路。</p>
<p>首先，针对反复创建线程开销大的问题，线程池用一些固定的线程一直保持工作状态并反复执行任务。</p>
<p>其次，针对过多线程占用太多内存资源的问题，解决思路更直接，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。</p>
<p>线程池就好像是一个工厂，工厂里的工人数量是有限可控的，但是工厂的订单时不可控的。加入工厂车间内有5个工人，这个时候有10个订单，那这5个工人每人分配一个订单，做完了在做一个订单就好了。如果此时来了大量的订单，工厂会将这些订单放到一个待生产任务队列中。工人从这些任务队列中取订单任务执行就好了。如果继续来了任务，工厂会临时招聘一些员工来执行这些任务，待这些任务执行完毕后，经过一段时间的观察后，工厂根据自己的订单情况来决定是否要解聘这些临时招聘的工人，如果招聘了工人后还不能满足产能，那工厂就会拒绝接受订单。</p>
<h2 id="线程池的工作原理">线程池的工作原理</h2>
<h3 id="参数">参数</h3>
<figure data-type="image" tabindex="1"><img src="https://philadelphia.github.io/post-images/1593327598801.png" alt=""></figure>
<h3 id="创建流程">创建流程</h3>
<figure data-type="image" tabindex="2"><img src="https://philadelphia.github.io/post-images/1593327619378.png" alt=""></figure>
<p>如上图所示，当向线程池体检任务时，线程池首先会检测核心线程池是否已满，如果核心线程池未满，则创建核心线程执行该任务，如果核心线程池已满，则检测任务队列是否已满，如果没满，则将任务加入到任务队列中，如果任务队列已满，则判断线程池是否已满，如果未满，则创建新的非核心线程执行任务，如果线程池已满。则按照拒绝策略来拒绝新进来的任务。</p>
<p>通过对流程图的创建流程分析，我们总结出线程池的几个特点。</p>
<p>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加线程。</p>
<p>线程池只有在任务队列填满时才创建多于 corePoolSize 的线程，如果使用的是无界队列（例如 LinkedBlockingQueue），那么由于队列不会满，所以线程数不会超过 corePoolSize。</p>
<p>通过设置 corePoolSize 和 maxPoolSize 为相同的值，就可以创建固定大小的线程池。</p>
<p>通过设置 maxPoolSize 为很高的值，例如 Integer.MAX_VALUE，就可以允许线程池创建任意多的线程。</p>
<h3 id="corepoolsize">corePoolSize</h3>
<p>线程中核心线程池的数量，当没有任务执行时，这类线程也不会被移除</p>
<h3 id="maxpoolsize">maxPoolSize</h3>
<p>线程池中线程存在的最大数量==核心线程数量+非核心线程数量</p>
<h3 id="keepalivetime-timeunit">keepAliveTime + TimeUnit</h3>
<p>线程池中没有任务执行时，非核心线程的存活时间。当超过设定的时间 后，线程池会将非核心线程回收以回收系统资源。</p>
<h3 id="threadfactory">ThreadFactory</h3>
<p>线程工厂，线程池用来创建新线程的类，我们可以自定义以给新创建的线程定义我们需要的名称</p>
<h3 id="workqueue">WorkQueue</h3>
<p>任务队列，</p>
<h3 id="handler">Handler</h3>
<p>线程池的拒绝策略。当传入超过线程池的工作能力是会调用</p>
<h2 id="线程池的4中自带的拒绝策略">线程池的4中自带的拒绝策略</h2>
<p>​</p>
<pre><code>public interface RejectedExecutionHandler {

    /**
     * Method that may be invoked by a {@link ThreadPoolExecutor} when
     * {@link ThreadPoolExecutor#execute execute} cannot accept a
     * task.  This may occur when no more threads or queue slots are
     * available because their bounds would be exceeded, or upon
     * shutdown of the Executor.
     *
     * &lt;p&gt;In the absence of other alternatives, the method may throw
     * an unchecked {@link RejectedExecutionException}, which will be
     * propagated to the caller of {@code execute}.
     *
     * @param r the runnable task requested to be executed
     * @param executor the executor attempting to execute this task
     * @throws RejectedExecutionException if there is no remedy
     */
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
</code></pre>
<p>改接口有4个实现类<br>
<img src="https://philadelphia.github.io/post-images/1593327679747.png" alt=""></p>
<p>其中第一个AbortPolicy 是线程池默认的拒绝策略。</p>
<h3 id="abortpolicy">AbortPolicy</h3>
<p>改策略会在线程池工作饱和后直接丢掉新添加的工作任务，直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p>
<h3 id="discardpolicy">DiscardPolicy</h3>
<p>正如名字一样，这种策略会直接丢弃新添加的任务。不会改调用者任何提示。会造成数据丢失的风险</p>
<h3 id="discardoldestpolicy">DiscardOldestPolicy</h3>
<p>和DiscardPolicy 一样，区别是DiscardPolicy 会丢弃新添加的工作任务。而DiscardOldestPolicy会丢弃工作队列对头的任务。同理也存在数据丢失的风险</p>
<h3 id="callerrunspolicy">CallerRunsPolicy</h3>
<p>当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p>
<ul>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ul>
<p>当然我们也可以实现RejectedExecutionHandler 接口实现我们自定义的拒绝策略。</p>
<h2 id="几种常见的线程池">几种常见的线程池</h2>
<ol>
<li>FixedThreadPool</li>
<li>CachedThreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
<li>SingleThreadScheduledExecutor</li>
<li>ForkJoinPool（Java8 添加）</li>
</ol>
<h3 id="fixedthreadpool">FixedThreadPool</h3>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<p>从名字可以看出这类线程池的线程数量是固定的。这种线程池中核心线程数量==最大线程数量</p>
<p>它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p>
<h3 id="cachedthreadpool">CachedThreadPool</h3>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<p>这种线程池的线程最大数量是Integer.MAX_VALUE 也就是2^31-1，(这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p>
<h3 id="scheduledthreadpool">ScheduledThreadPool</h3>
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
</code></pre>
<p>第三个线程池是 ScheduledThreadPool，它支持定时或周期性执行任务。比如每隔 10 秒钟执行一次任务，而实现这种功能的方法主要有 3 种，如代码所示</p>
<pre><code>ScheduledExecutorService service = Executors.newScheduledThreadPool(10);

service.schedule(new Task(), 10, TimeUnit.SECONDS);

service.scheduleAtFixedRate(new Task(), 10, 10, TimeUnit.SECONDS);

service.scheduleWithFixedDelay(new Task(), 10, 10, TimeUnit.SECONDS);
</code></pre>
<p>那么这 3 种方法有什么区别呢？</p>
<ul>
<li>第一种方法 schedule 比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。</li>
<li>第二种方法 scheduleAtFixedRate 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。</li>
<li>第三种方法 scheduleWithFixedDelay 与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。</li>
</ul>
<p>举个例子，假设某个同学正在熬夜写代码，需要喝咖啡来提神，假设每次喝咖啡都需要花10分钟的时间，如果此时采用第2种方法 scheduleAtFixedRate，时间间隔设置为 1 小时，那么他将会在每个整点喝一杯咖啡，以下是时间表：</p>
<p>00:00: 开始喝咖啡</p>
<p>00:10: 喝完了</p>
<p>01:00: 开始喝咖啡</p>
<p>01:10: 喝完了</p>
<p>02:00: 开始喝咖啡</p>
<p>02:10: 喝完了</p>
<p>但是假设他采用第3种方法 scheduleWithFixedDelay，时间间隔同样设置为 1 小时，那么由于每次喝咖啡需要10分钟，而 scheduleWithFixedDelay 是以任务完成的时间为时间起点开始计时的，所以第2次喝咖啡的时间将会在1:10，而不是1:00整，以下是时间表：</p>
<p>00:00: 开始喝咖啡</p>
<p>00:10: 喝完了</p>
<p>01:10: 开始喝咖啡</p>
<p>01:20: 喝完了</p>
<p>02:20: 开始喝咖啡</p>
<p>02:30: 喝完了</p>
<p>可见下次任务开始的时间是以第一次任务结束的时间+延迟时间。</p>
<p>注意：ScheduledThreadPool执行周期任务时，如果某次任务执行失败了，后续的任务就不会执行了。所以 ScheduledThreadPoolExecutor的最优实践：将所有执行代码用try-catch包裹。在catch块里再次提交任务。</p>
<h3 id="singlethreadexecutor">SingleThreadExecutor</h3>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<p>第四种线程池是 SingleThreadExecutor，它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p>
<h3 id="singlethreadscheduledexecutor">SingleThreadScheduledExecutor</h3>
<p>第五个线程池是 SingleThreadScheduledExecutor，它实际和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程，如源码所示：</p>
<pre><code>public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new DelegatedScheduledExecutorService
        (new ScheduledThreadPoolExecutor(1));
}
</code></pre>
<h3 id="forkjoinpool">ForkJoinPool</h3>
<p>没怎么用过呢。</p>
<h2 id="为什么不应该自动创建线程池">为什么不应该自动创建线程池</h2>
<p>自动创建线程池就是直接调用 Executors 的各种方法来生成前面学过的常见的线程池，例如 Executors.newCachedThreadPool()。但这样做是有一定风险的，接下来我们就来逐一分析自动创建线程池可能带来哪些问题。</p>
<h3 id="fixedthreadpool-2">FixedThreadPool</h3>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<p>可以看出创建FixedThreadPool，系统使用了一个LinkedBlockingQueue队列，这种队列是没有长度现在，这就会导致一个问题，我们可以无限制的向线程池提交任务。如果我们对任务的处理速度比较慢，那么随着请求的增多，队列中堆积的任务也会越来越多，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。</p>
<h3 id="singlethreadexecutor-2">SingleThreadExecutor</h3>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<p>newSingleThreadExecutor 和 newFixedThreadPool 的原理是一样的，只不过把核心线程数和最大线程数都直接设置成了 1，但是任务队列仍是无界的 LinkedBlockingQueue，所以也会导致同样的问题，也就是当任务堆积时，可能会占用大量的内存并导致 OOM。</p>
<h3 id="cachedthreadpool-2">CachedThreadPool</h3>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<p>CachedThreadPool 和前两种线程池不一样的地方在于任务队列使用的是 SynchronousQueue，SynchronousQueue 本身并不存储任务，而是对任务直接进行转发，这本身是没有问题的，但你会发现构造函数的第二个参数被设置成了 Integer.MAX_VALUE，这个参数的含义是最大线程数，所以由于 CachedThreadPool 并不限制线程的数量，当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足</p>
<h3 id="scheduledthreadpool-和-singlethreadscheduledexecutor">ScheduledThreadPool 和 SingleThreadScheduledExecutor</h3>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue(), threadFactory);
}
</code></pre>
<p>通过源码可以看出，它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过的任务，就可能导致 OOM。</p>
<p>可以看到，这几种自动创建的线程池都存在风险，相比较而言，我们自己手动创建会更好，因为我们可以更加明确线程池的运行规则，不仅可以选择适合自己的线程数量，更可以在必要的时候拒绝新任务的提交，避免资源耗尽的风险。</p>
<h2 id="合适的线程数量是多少cpu-核心数和线程数的关系">合适的线程数量是多少？CPU 核心数和线程数的关系</h2>
<p>从上面的分析可知，我们不应该自动创建线程池，即不应该调用Executors的自带方法创建常用的线程池，而应该手动的创建线程池。即调用ThreadPoolExecutor的构造方法手动创建线程池，这就需要我们手动指定各个参数。</p>
<p>那么我们到底需要创建多少个核心线程，线程池的最大线程数量又该如何设定呢。</p>
<p>我们需要根据我们的任务性质设置不同的线程数量</p>
<h3 id="cpu-密集型任务">CPU 密集型任务</h3>
<p>首先，我们来看 CPU 密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。对于这样的任务最佳的线程数为 CPU 核心数的 1~2 倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍以上，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p>
<h3 id="耗时-io-型任务">耗时 IO 型任务</h3>
<p>第二种任务是耗时 IO 型，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源</p>
<p>《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：</p>
<pre><code>线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）
</code></pre>
<p>通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。</p>
<p>太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</p>
<p>结论<br>
综上所述我们就可以得出一个结论：</p>
<ul>
<li>线程的平均工作时间所占比例越高，就需要越少的线程；</li>
<li>线程的平均等待时间所占比例越高，就需要越多的线程；</li>
</ul>
<p>针对不同的程序，进行对应的实际测试就可以得到最合适的选择。</p>
<h2 id="如何正确的关闭线程池">如何正确的关闭线程池</h2>
<p>ThreadPoolExecutor提供了5个有关关闭线程池的方法</p>
<ul>
<li>void shutdown();</li>
<li>boolean isShutdown();</li>
<li>boolean isTerminated();</li>
<li>boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</li>
<li>List<Runnable> shutdownNow();</li>
</ul>
<h3 id="shutdown">shutdown</h3>
<p>该方法用于安全地关闭一个线程池，调用该方法后线程池并不会立即关闭。因为这个时候线程池可能还有任务在执行。或者任务队列中有任务待执行，调用该方法后线程池会将所有的任务执行完毕后才关闭，但是调用改方法后线程池将不再接受新的工作任务，线程池则会根据拒绝策略直接拒绝后续新提交的任务</p>
<h3 id="isshutdown">isShutdown</h3>
<p>它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown() 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</p>
<p>也就是说该方法返回true，只是表示该线程池开启了关闭操作，但是可能还没有彻底关闭，只是一个标志位</p>
<h3 id="isterminated">isTerminated</h3>
<p>不同于isShutDown方法，isShutdown方法返回true，线程池也可能没有真正关闭，线程池会将任务队列中的任务执行完毕后才真正关闭。这个时候isTerminated回放回false，但是当线程池真正关闭后，isTerminated 返回true。</p>
<h3 id="awaittermination">awaitTermination</h3>
<p>该方法不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p>
<ul>
<li>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；</li>
<li>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；</li>
<li>等待期间线程被中断，方法会抛出 InterruptedException 异常。<br>
也就是说，调用 awaitTermination 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</li>
</ul>
<p>我们则可以根据 awaitTermination() 返回的布尔值来判断下一步应该执行的操作。</p>
<h3 id="shutdownnow">shutdownNow</h3>
<p>它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。shutdownNow() 的源码如下所示。</p>
<pre><code>public List&lt;Runnable&gt; shutdownNow() { 
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try { 
          checkShutdownAccess();
          advanceRunState(STOP);
          interruptWorkers();
          tasks = drainQueue();
      } finally { 
          mainLock.unlock();
      } 

      tryTerminate();
      return tasks;
}
</code></pre>
<p>你可以看到源码中有一行 interruptWorkers() 代码，这行代码会让每一个已经启动的线程都中断，这样线程就可以在执行任务期间检测到中断信号并进行相应的处理，提前结束任务。这里需要注意的是，由于 Java 中不推荐强行停止线程的机制的限制，即便我们调用了 shutdownNow 方法，如果被中断的线程对于中断信号不理不睬，那么依然有可能导致任务不会停止。可见我们在开发中落地最佳实践是很重要的，我们自己编写的线程应当具有响应中断信号的能力，应当利用中断信号来协同工作。</p>
<h2 id="线程复用原理">线程复用原理</h2>
<p>我们知道线程池会使用固定数量或可变数量的线程来执行任务，但无论是固定数量或可变数量的线程，其线程数量都远远小于任务数量，面对这种情况线程池可以通过线程复用让同一个线程去执行不同的任务，那么线程复用背后的原理是什么呢？</p>
<p>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
<p>再看一下线程池的工作原理：</p>
<figure data-type="image" tabindex="3"><img src="https://philadelphia.github.io/post-images/1593327619378.png" alt=""></figure>
<p>我们看一下execute方法</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 step
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<pre><code> if (command == null)
        throw new NullPointerException();
</code></pre>
<p>首先进行入参判断，如果提交的任务为null，则抛出一个NPE。</p>
<p>接下来判断线程数量是否小于核心线程数量。如果线程池中线程数量小于核心线程数，则调用addWorker()方法新增一个worker，worker可以理解为一个线程。</p>
<pre><code>int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
</code></pre>
<p>addWorker 方法的主要作用是在线程池中创建一个线程并执行第一个参数传入的任务，它的第二个参数是个布尔值，如果布尔值传入 true 代表增加线程时判断当前线程是否少于 corePoolSize，小于则增加新线程，大于等于则不增加；同理，如果传入 false 代表增加线程时判断当前线程是否少于 maxPoolSize，小于则增加新线程，大于等于则不增加，所以这里的布尔值的含义是以核心线程数为界限还是以最大线程数为界限进行是否新增线程的判断。addWorker() 方法如果返回 true 代表添加成功，如果返回 false 代表添加失败。</p>
<p>接下来</p>
<pre><code>if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
</code></pre>
<p>如果代码执行到这里说明当前线程池中的线程数量大于或者等于核心线程数量，或者addWorker失败了。</p>
<p>此时就需要使用if (isRunning(c) &amp;&amp; workQueue.offer(command)) 来检查线程池是否在运行中，如果线程池状态是 Running 就把任务放入任务队列中，也就是 workQueue.offer(command)。</p>
<p>如果线程池已经不再运行状态了。需要将刚添加到任务队列的任务移出队列并执行拒绝策略。</p>
<p>代码如下</p>
<pre><code>if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
</code></pre>
<p>接下来</p>
<pre><code>else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
</code></pre>
<p>如果执行到这里说明线程池依旧在运行中。那么当任务被添加进来之后就需要防止没有可执行线程的情况发生（比如之前的线程被回收了或意外终止了），所以此时如果检查当前线程数为 0，也就是 workerCountOf**(recheck) == 0，那就执行 addWorker() 方法新建线程</p>
<p>再看一下最后一个else</p>
<pre><code> else if (!addWorker(command, false))
        reject(command);
</code></pre>
<p>执行到这里说明线程池已经不是running状态了或者任务队列已满。根据规则，此时线程池会创建新的非核心线程来执行任务。直到达到最大线程数。所以此时调用addWorker(command，false)来创建一个非核心线程。如果没有创建成功，说明线程数已满。此时执行拒绝策略 reject(command);</p>
<pre><code> final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }
</code></pre>
<p>在 execute 方法中，多次调用 addWorker 方法把任务传入，addWorker 方法会添加并启动一个 Worker，这里的 Worker 可以理解为是对 Thread 的包装，Worker 内部有一个 Thread 对象，它正是最终真正执行任务的线程，所以一个 Worker 就对应线程池中的一个线程，addWorker 就代表增加线程。线程复用的逻辑实现主要在 Worker 类中的 run 方法里执行的 runWorker 方法中，简化后的 runWorker 方法代码如下所示。</p>
<p>addWorker方法的源码</p>
<pre><code> private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
</code></pre>
<pre><code> w = new Worker(firstTask);
            final Thread t = w.thread;
</code></pre>
<p>使用传递进来的runnable构建一个Worker对象，然后取出该对象的Thread对象。</p>
<pre><code> private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
      /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        
         Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

			 /** Delegates main run loop to outer runWorker. */
        public void run() {
            runWorker(this);
        }
    }
</code></pre>
<p>从源码可以看出Worker就是一个线程实现了runnable接口，内不持有一个Thread对象。</p>
<p>在Worker的run方法中我们可以看出调用了runWorker方法。</p>
<pre><code>runWorker(Worker w) {
    Runnable task = w.firstTask;
    while (task != null || (task = getTask()) != null) {
        try {
            task.run();
        } finally {
            task = null;
        }
    }
}
</code></pre>
<p>可以看出，实现线程复用的逻辑主要在一个不停循环的 while 循环体中。</p>
<ol>
<li>通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务。</li>
<li>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）。</li>
</ol>
<p>在这里，我们找到了最终的实现，通过取 Worker 的 firstTask 或者 getTask方法从 workQueue 中取出了新任务，并直接调用 Runnable 的 run 方法来执行任务，也就是如之前所说的，每个线程都始终在一个大循环中，反复获取任务，然后执行任务，从而实现了线程的复用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列]]></title>
        <id>https://philadelphia.github.io/post/zu-sai-dui-lie</id>
        <link href="https://philadelphia.github.io/post/zu-sai-dui-lie">
        </link>
        <updated>2020-06-26T16:32:53.000Z</updated>
        <content type="html"><![CDATA[<p>阻塞队列，也就是 BlockingQueue，它是一个接口，如代码所示：</p>
<pre><code>public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;{...}
</code></pre>
<p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java 5 中加入的。</p>
<p>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了<br>
既然队列本身是线程安全的，队列可以安全地从一个线程向另外一个线程传递数据，所以我们的生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开发的难度和工作量。<br>
Java 提供的线程安全的队列（也称为并发队列）分为阻塞队列和非阻塞队列两大类。<br>
<img src="https://philadelphia.github.io/post-images/1593189553251.png" alt=""><br>
可以看出Queue接口提供了以上方法。<br>
而BlockingQueue又新增了get()和put()方法。<br>
把 BlockingQueue 中最常用的和添加、删除相关的 8 个方法列出来，并且把它们分为三组，每组方法都和添加、移除元素相关。</p>
<p>1：添加元素</p>
<pre><code>boolean add(E e) ;
boolean offer(E e);
void put(E e);
</code></pre>
<p>2:删除元素</p>
<pre><code>E remove() ;
E get();
</code></pre>
<p>3.获取队列头部元素</p>
<pre><code>E element();
E peek();
</code></pre>
<p>这三组方法由于功能很类似，所以比较容易混淆。它们的区别仅在于特殊情况：当队列满了无法添加元素，或者是队列空了无法移除元素时，不同组的方法对于这种特殊情况会有不同的处理方式：</p>
<p>1：抛出异常：add、remove、element<br>
2：返回结果但不抛出异常：offer、poll、peek<br>
3：阻塞：put、take</p>
<h2 id="第一组add-remove-element">第一组：add、remove、element</h2>
<h3 id="add">add()</h3>
<p>方法向队列中添加一个元素，如果队列没有满，这个时候添加成功，返回true<br>
如果此时队列已经满了，则会这届抛出一个异常</p>
<h3 id="remove">remove</h3>
<p>remove方法从队列中删除头部元素，<br>
如果队列不为空，则将队列头部元素从队列中移出并返回队改元素<br>
如果队列为0，则直接抛出一个NoSuchElementException 异常</p>
<h3 id="element方法">element方法</h3>
<p>该方法返回队列头部元素<br>
如果队列不为空，则直接返回队列头部元素。如果队列为空，则直接抛出NoSuchElementException<br>
改方法和remove方法的区别就是该方法只会去队列的头部元素而不会删除头部元素</p>
<h2 id="第二组offer-poll-peek">第二组：offer、poll、peek</h2>
<p>第二组方法相比于第一组而言要友好一些，当发现队列满了无法添加，或者队列为空无法删除的时候，第二组方法会给一个提示，而不是抛出一个异常。</p>
<h3 id="offer-方法">offer 方法</h3>
<p>offer 方法用来插入一个元素，并用返回值来提示插入是否成功。如果添加成功会返回 true，而如果队列已经满了，此时继续调用 offer 方法的话，它不会抛出异常，只会返回一个错误提示：false</p>
<h3 id="poll-方法">poll 方法</h3>
<p>poll 方法和第一组的 remove 方法是对应的，作用也是移除并返回队列的头节点。但是如果当队列里面是空的，没有任何东西可以移除的时候，便会返回 null 作为提示。正因如此，我们是不允许往队列中插入 null 的，否则我们没有办法区分返回的 null 是一个提示还是一个真正的元素</p>
<h3 id="peek-方法">peek 方法</h3>
<p>peek 方法和第一组的 element 方法是对应的，意思是返回队列的头元素但并不删除。如果队列里面是空的，它便会返回 null 作为提示</p>
<p>带超时时间的 offer 和 poll</p>
<p>offer 和 poll 都有带超时时间的重载方法。<br>
offer(E e, long timeout, TimeUnit unit)</p>
<p>它有三个参数，分别是元素、超时时长和时间单位。通常情况下，这个方法会插入成功并返回 true；如果队列满了导致插入不成功，在调用带超时时间重载方法的 offer 的时候，则会等待指定的超时时间，如果时间到了依然没有插入成功，就会返回 false</p>
<pre><code>poll(long timeout, TimeUnit unit)
</code></pre>
<p>带时间参数的 poll 方法和 offer 类似：如果能够移除，便会立刻返回这个节点的内容；如果队列是空的就会进行等待，等待时间正是我们指定的时间，直到超时时间到了，如果队列里依然没有元素可供移除，便会返回 null 作为提示</p>
<h2 id="第三组put-take">第三组：put、take</h2>
<p>这两个方法是阻塞队列特有的，Queue接口并不存在这个方法的声明。<br>
这两个方法的特定是在无法完成操作是会阻塞线程、</p>
<h3 id="put-方法">put 方法</h3>
<p>put 方法的作用是插入元素。通常在队列没满的时候是正常的插入，但是如果队列已满就无法继续插入，这时它既不会立刻返回 false 也不会抛出异常，而是让插入的线程陷入阻塞状态，直到队列里有了空闲空间，此时队列就会让之前的线程解除阻塞状态，并把刚才那个元素添加进去</p>
<h3 id="take-方法">take 方法</h3>
<p>take 方法的作用是获取并移除队列的头结点。通常在队列里有数据的时候会正常取出数据并删除；但是如果执行 take 的时候队列里无数据，则阻塞，直到队列里有数据；一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据</p>
<p>总和以上的分析，可以将以上分方法的区别用一个表格表示<br>
<img src="https://philadelphia.github.io/post-images/1593191082633.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译-Java字符串池是什么？ ]]></title>
        <id>https://philadelphia.github.io/post/fan-yi-what-is-java-string-pool</id>
        <link href="https://philadelphia.github.io/post/fan-yi-what-is-java-string-pool">
        </link>
        <updated>2019-11-26T06:07:58.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.journaldev.com/797/what-is-java-string-pool">原文地址</a></p>
<p>正如名字所示：Java中字符串池存储在堆内存中。我们知道java中String是一个特殊的类，我们可以通过new 操作符或者使用双引号“”创建一个String对象。</p>
<ol>
<li>Java里的字符串池</li>
<li>字符串池中创建了多少字符串对象？</li>
</ol>
<h2 id="java里的字符串池">Java里的字符串池</h2>
<p>下面是一个图，清晰的解释了java堆内存怎么管理字符串池的。以及当我们使用不同的方式创建字符串时发生了什么。</p>
<figure data-type="image" tabindex="1"><img src="https://philadelphia.github.io/post-images/1574751374767.png" alt=""></figure>
<p>字符串池是可行的，只是因为在Java中String是不可变类型的。而且它实现了字符串的interning 概念。<br>
字符串池是享元设计模式的一个实例。</p>
<p>字符串池有助于为Java运行时节省了很多的内存空间，即使它使用了更多的时间。</p>
<p>当我们使用双引号创建字符串时，它首先在字符串池中寻找同样值的字符串，如果找到了就返回该引用。如果没找到，就在池中创建一个新的字符串并返回它的引用。</p>
<p>然而使用new操作符创建字符串时，我们强制String类在堆内存上创建一个新的String对象。我们可以使用intern() 方法将它放到String池中。或者指向字符串池中有相同值字符串对象的引用。</p>
<p>下面是java程序：</p>
<pre><code>package com.journaldev.util;

public class StringPool {

    /**
    * Java String Pool example
    * @param args
    */
    public static void main(String[] args) {
        String s1 = &quot;Cat&quot;;
        String s2 = &quot;Cat&quot;;
        String s3 = new String(&quot;Cat&quot;);
        
        System.out.println(&quot;s1 == s2 :&quot;+(s1==s2));
        System.out.println(&quot;s1 == s3 :&quot;+(s1==s3));
    }

}
</code></pre>
<p>上面程序输入如下：</p>
<pre><code>s1 == s2 :true
s1 == s3 :false
</code></pre>
<p>推荐阅读: <a href="https://www.journaldev.com/16928/java-string">Java String Class</a></p>
<h2 id="字符串池中创建了几个string对象呢">字符串池中创建了几个String对象呢？</h2>
<p>有时候在Java面试中，你可能被问到关于字符串池的问题，比如，下面的语句创建了几个string.</p>
<p>String str = new String(&quot;Cat&quot;);</p>
<p>在上面的语句中，1个或者2个string被创建了，如果字符串池中已经有’cat‘字符串了，就只创建一个String.如果字符串池中没有’cat‘字符串，首先在字符串池中创建一个字符串，然后在堆内存中创建一个字符串，所有总共有2个string对象被创建了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译-Java数组转换成List（Java Array to List Examples）]]></title>
        <id>https://philadelphia.github.io/post/fan-yi-java-shu-zu-zhuan-huan-cheng-listjava-array-to-list-examples</id>
        <link href="https://philadelphia.github.io/post/fan-yi-java-shu-zu-zhuan-huan-cheng-listjava-array-to-list-examples">
        </link>
        <updated>2019-11-25T02:39:32.000Z</updated>
        <content type="html"><![CDATA[<p>原文链接：http<a href=""></a>s://javadevnotes.com/java-array-to-list-examples</p>
<p>译文：</p>
<p>有时候我们需要将数组类型转换成为集合类型，因为后者是一个更为强大的数据结构，java.util.List 有许多普通数组不支持的功能。比如：我们可以通过List的内置方法轻易地检测list是否包含某一个特定的值。下面是一些怎么将数组转换为list的例子。</p>
<h2 id="通过-javautilarraysaslist将-array-转换成-list"><strong>通过 java.util.Arrays.asList()将 Array 转换成 List</strong></h2>
<p>Arrays 类有一个方便的方法asList,可以帮助转换任务，下面是语法：<br>
<code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code><br>
注意：参数不一定必须是数组，可变参数也可以。它可以创建一个list</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;);
   }
}
</code></pre>
<p>以上代码将穿件一个包含一个元素&quot;Apple&quot;的集合。我们也可以这样做：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;);
   }
}
</code></pre>
<p>这将生成一个包含两个元素&quot;Apple&quot;,&quot;Orange&quot;的集合</p>
<p>因为这是一个可变参数。我们可以传递一个数组，数组元素被认定为参数，例子：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = Arrays.asList(myArray);
      for (String str : myList) {
         System.out.println(str);
      }
   }
}
</code></pre>
<p>这样,一个String集合被创建出来了。数组myArray被添加进去了。myList 集合有三个元素，一下是输出：</p>
<p>Apple<br>
Banana<br>
Orange</p>
<h2 id="陷阱">陷阱</h2>
<p>这个方法有一些问题，传递进去的数组必须是一个对象数组，而不能是一个基本类型数组。比如：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      int[] myArray = { 1, 2, 3 };
      List myList = Arrays.asList(myArray);
      System.out.println(myList.size());
   }
}
</code></pre>
<p>代码输出是1。为什么呢？因为asList方法期望一个对象的可变参数，但是传递进去的参数是一个基本类型数组，它创建了一个数组集合。所以该集合的为唯一元素是myArray。因此<code>myList.get(0)</code> 将返回与myArray同样的对象。</p>
<h2 id="aslist创建的对象是固定大小的"><strong>asList()创建的对象是固定大小的</strong></h2>
<p>asList()方法返回的list对象是固定大小的，不能容纳更多的元素，比如：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = Arrays.asList(myArray);
      myList.add(&quot;Guava&quot;);
   }
}
</code></pre>
<p>输出如下：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:148)
	at java.util.AbstractList.add(AbstractList.java:108)
	at Test.main(Test.java:8)
</code></pre>
<p>因为myList是固定长度的，不能添加更多元素。</p>
<p>因为该方法返回的List对象不是java.util包下面的ArrayList，而是Arrays内部的ArrayList类型。改类没有实现add,revmove,clear方法，所以任何对改集合结构修改的调用都将失败。</p>
<h2 id="将基本数组类型转换成list"><strong>将基本数组类型转换成List</strong></h2>
<p>正如上面提到的。传递一个基本类型数组到asList方法不生效，一个不引入第三方库的解决办法是通过Java8 的流，例子如下：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      int[] intArray = { 5, 10, 21 };
      List myList = Arrays.stream(intArray).boxed()
            .collect(Collectors.toList());
   }
}
</code></pre>
<p>数组的每一个元素都被从int转换成了Integer类型(装箱)，数组就被转成了List类型。</p>
<h2 id="将数组转换成允许添加元素的list"><strong>将数组转换成允许添加元素的List</strong></h2>
<p>正如上面陷阱部分提到的，Arrays.asList()方法不支持添加或者移除元素。如果你不想这样，下面是可选方案：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(myArray));
      myList.add(&quot;Guava&quot;);
   }
}
</code></pre>
<p>这段代码显式地创建了一个新的ArrayList对象，然后将Arrays.asList的结果添加进去了。因为我们创建了一个ArrayList。所以没有添加移除限制，上面的代码执行结束前有四个元素。不要指望代码执行时抛出异常。</p>
<h2 id="自己实现array组转换成list"><strong>自己实现Array组转换成List</strong></h2>
<p>有时候解决问题，使用我们自己的实现方案是更好的。下面是一个将java数组转换成List的简单例子:</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
      for (String str : myArray) {
         myList.add(str);
      }
      System.out.println(myList.size());
   }
}
</code></pre>
<p>代码的预期输出是3.因为逻辑执行完集合了有3个元素。</p>
<p>我们代码的负面是代码更长了，而且我们在重复造轮子。好处就是当我们的需求改变时，我们可以顺应自定义。比如：下面的代码，每一个元素都被添加到list中两次</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
      for (String str : myArray) {
         myList.add(str);
         myList.add(str);
      }
      System.out.println(myList.size());
   }
}
</code></pre>
<p>输出是6，因为数组中的元素都被添加两次。下面是另外一个将String数组转换成List<Integer> 的例子：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio 在APP启动时debug app]]></title>
        <id>https://philadelphia.github.io/post/android-studio-zai-app-qi-dong-shi-debug-app</id>
        <link href="https://philadelphia.github.io/post/android-studio-zai-app-qi-dong-shi-debug-app">
        </link>
        <updated>2019-11-20T10:30:56.000Z</updated>
        <content type="html"><![CDATA[<p>有时候APP一启动就崩溃了，对应Android 就是在Application 的onCreate()方法执行时就崩溃，这个时候我们根本来不及点击debug 按钮，所以我们就无法select a process to attach to debugger.<br>
我们只能以Debug模式运行APP，麻烦</p>
<p>我们可以在<strong>设置</strong>-<strong>开发者选项</strong>(前提是已经打开开发者选项了)-<strong>选择调试应用</strong>(选择我们想要调试的应用)-勾选 <strong>等待调试器</strong> 就好了。<br>
<img src="https://philadelphia.github.io/post-images/1574247141968.jpg" alt=""></p>
<p>这个时候APP启动后不会继续执行，等我们点击debug 按钮后APP才会继续往下执行，这个时候我们就可以调试了。debug 完毕后关闭就行了。<br>
<img src="https://philadelphia.github.io/post-images/1574247152856.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity launchMode在开发中的一些使用]]></title>
        <id>https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong</id>
        <link href="https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong">
        </link>
        <updated>2019-11-19T10:54:50.000Z</updated>
        <content type="html"><![CDATA[<p>最近在做APP的通知模块时，产品要求点击通知后</p>
<ol>
<li>在用户登录的情况下直接进入到通知消息的详情页，</li>
<li>没有登录的情况下先进行登录，然后在跳转到消息的详情页</li>
</ol>
<p>但是登录页面可能包含了N多个步骤，所以最好的方式是当用户没有登录的情况下使用startActivityForResult进行登录请求，把登录功能当做一个模块，<br>
因为登录支持很多方式登录，用户在登录页面可能使用账密登录或者点击其他登录选项使用其他方式登录，<br>
我们只需要关注LogInActivity就行了，<br>
如果使用其他登录方式进行登录，当登录成功后跳转到LogInActivity<br>
我们可以给跳转intent设置flag<br>
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP);</p>
<p>只有这两种启动标志组合使用，才会调用LogInActivity的onNewIntent方法。<br>
而如果单独使用<br>
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>
的话，会将LoginActivity提到栈顶并销毁其他Activity，但是并不会回调onNewIntent方法。</p>
<p>这样的话我们就相当于使用singleTask的方式启动了LogInActivity<br>
这样中间登录步骤的页面就可以全部销毁了。<br>
然后在LogInActivity的onNewIntent()方法中setResult(Activity.Result_OK）来告诉强求页登录成功了，</p>
<pre><code>@Override
protected void onNewIntent(Intent intent) {
      super.onNewIntent(intent);
      setResult(RESULT_OK);
      finish();   
}
</code></pre>
<p>没有登录的情况下复写onBackPressed()方法就行了，因为不论使用何种登录方式，只要进行到一半返回，最终没有完成登录返回的话一定会调用onBackPressed方法。因为只用成功才会自动finish LoginActivity</p>
<pre><code>@Override
public void onBackPressed() {
    super.onBackPressed();
    setResult(RESULT_CANCELED);
}
</code></pre>
<p>其他功能也类似，比如认证相关的功能。</p>
]]></content>
    </entry>
</feed>