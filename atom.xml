<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philadelphia.github.io</id>
    <title>philadelphia</title>
    <updated>2020-06-26T17:28:44.629Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philadelphia.github.io"/>
    <link rel="self" href="https://philadelphia.github.io/atom.xml"/>
    <subtitle>德不孤，必有邻</subtitle>
    <logo>https://philadelphia.github.io/images/avatar.png</logo>
    <icon>https://philadelphia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, philadelphia</rights>
    <entry>
        <title type="html"><![CDATA[阻塞队列]]></title>
        <id>https://philadelphia.github.io/post/zu-sai-dui-lie</id>
        <link href="https://philadelphia.github.io/post/zu-sai-dui-lie">
        </link>
        <updated>2020-06-26T16:32:53.000Z</updated>
        <content type="html"><![CDATA[<p>阻塞队列，也就是 BlockingQueue，它是一个接口，如代码所示：</p>
<pre><code>public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;{...}
</code></pre>
<p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java 5 中加入的。</p>
<p>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了<br>
既然队列本身是线程安全的，队列可以安全地从一个线程向另外一个线程传递数据，所以我们的生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开发的难度和工作量。<br>
Java 提供的线程安全的队列（也称为并发队列）分为阻塞队列和非阻塞队列两大类。<br>
<img src="https://philadelphia.github.io/post-images/1593189553251.png" alt=""><br>
可以看出Queue接口提供了以上方法。<br>
而BlockingQueue又新增了get()和put()方法。<br>
把 BlockingQueue 中最常用的和添加、删除相关的 8 个方法列出来，并且把它们分为三组，每组方法都和添加、移除元素相关。</p>
<p>1：添加元素</p>
<pre><code>boolean add(E e) ;
boolean offer(E e);
void put(E e);
</code></pre>
<p>2:删除元素</p>
<pre><code>E remove() ;
E get();
</code></pre>
<p>3.获取队列头部元素</p>
<pre><code>E element();
E peek();
</code></pre>
<p>这三组方法由于功能很类似，所以比较容易混淆。它们的区别仅在于特殊情况：当队列满了无法添加元素，或者是队列空了无法移除元素时，不同组的方法对于这种特殊情况会有不同的处理方式：</p>
<p>1：抛出异常：add、remove、element<br>
2：返回结果但不抛出异常：offer、poll、peek<br>
3：阻塞：put、take</p>
<h2 id="第一组add-remove-element">第一组：add、remove、element</h2>
<h3 id="add">add()</h3>
<p>方法向队列中添加一个元素，如果队列没有满，这个时候添加成功，返回true<br>
如果此时队列已经满了，则会这届抛出一个异常</p>
<h3 id="remove">remove</h3>
<p>remove方法从队列中删除头部元素，<br>
如果队列不为空，则将队列头部元素从队列中移出并返回队改元素<br>
如果队列为0，则直接抛出一个NoSuchElementException 异常</p>
<h3 id="element方法">element方法</h3>
<p>该方法返回队列头部元素<br>
如果队列不为空，则直接返回队列头部元素。如果队列为空，则直接抛出NoSuchElementException<br>
改方法和remove方法的区别就是该方法只会去队列的头部元素而不会删除头部元素</p>
<h2 id="第二组offer-poll-peek">第二组：offer、poll、peek</h2>
<p>第二组方法相比于第一组而言要友好一些，当发现队列满了无法添加，或者队列为空无法删除的时候，第二组方法会给一个提示，而不是抛出一个异常。</p>
<h3 id="offer-方法">offer 方法</h3>
<p>offer 方法用来插入一个元素，并用返回值来提示插入是否成功。如果添加成功会返回 true，而如果队列已经满了，此时继续调用 offer 方法的话，它不会抛出异常，只会返回一个错误提示：false</p>
<h3 id="poll-方法">poll 方法</h3>
<p>poll 方法和第一组的 remove 方法是对应的，作用也是移除并返回队列的头节点。但是如果当队列里面是空的，没有任何东西可以移除的时候，便会返回 null 作为提示。正因如此，我们是不允许往队列中插入 null 的，否则我们没有办法区分返回的 null 是一个提示还是一个真正的元素</p>
<h3 id="peek-方法">peek 方法</h3>
<p>peek 方法和第一组的 element 方法是对应的，意思是返回队列的头元素但并不删除。如果队列里面是空的，它便会返回 null 作为提示</p>
<p>带超时时间的 offer 和 poll</p>
<p>offer 和 poll 都有带超时时间的重载方法。<br>
offer(E e, long timeout, TimeUnit unit)</p>
<p>它有三个参数，分别是元素、超时时长和时间单位。通常情况下，这个方法会插入成功并返回 true；如果队列满了导致插入不成功，在调用带超时时间重载方法的 offer 的时候，则会等待指定的超时时间，如果时间到了依然没有插入成功，就会返回 false</p>
<pre><code>poll(long timeout, TimeUnit unit)
</code></pre>
<p>带时间参数的 poll 方法和 offer 类似：如果能够移除，便会立刻返回这个节点的内容；如果队列是空的就会进行等待，等待时间正是我们指定的时间，直到超时时间到了，如果队列里依然没有元素可供移除，便会返回 null 作为提示</p>
<h2 id="第三组put-take">第三组：put、take</h2>
<p>这两个方法是阻塞队列特有的，Queue接口并不存在这个方法的声明。<br>
这两个方法的特定是在无法完成操作是会阻塞线程、</p>
<h3 id="put-方法">put 方法</h3>
<p>put 方法的作用是插入元素。通常在队列没满的时候是正常的插入，但是如果队列已满就无法继续插入，这时它既不会立刻返回 false 也不会抛出异常，而是让插入的线程陷入阻塞状态，直到队列里有了空闲空间，此时队列就会让之前的线程解除阻塞状态，并把刚才那个元素添加进去</p>
<h3 id="take-方法">take 方法</h3>
<p>take 方法的作用是获取并移除队列的头结点。通常在队列里有数据的时候会正常取出数据并删除；但是如果执行 take 的时候队列里无数据，则阻塞，直到队列里有数据；一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据</p>
<p>总和以上的分析，可以将以上分方法的区别用一个表格表示<br>
<img src="https://philadelphia.github.io/post-images/1593191082633.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译-Java字符串池是什么？ ]]></title>
        <id>https://philadelphia.github.io/post/fan-yi-what-is-java-string-pool</id>
        <link href="https://philadelphia.github.io/post/fan-yi-what-is-java-string-pool">
        </link>
        <updated>2019-11-26T06:07:58.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.journaldev.com/797/what-is-java-string-pool">原文地址</a></p>
<p>正如名字所示：Java中字符串池存储在堆内存中。我们知道java中String是一个特殊的类，我们可以通过new 操作符或者使用双引号“”创建一个String对象。</p>
<ol>
<li>Java里的字符串池</li>
<li>字符串池中创建了多少字符串对象？</li>
</ol>
<h2 id="java里的字符串池">Java里的字符串池</h2>
<p>下面是一个图，清晰的解释了java堆内存怎么管理字符串池的。以及当我们使用不同的方式创建字符串时发生了什么。</p>
<figure data-type="image" tabindex="1"><img src="https://philadelphia.github.io/post-images/1574751374767.png" alt=""></figure>
<p>字符串池是可行的，只是因为在Java中String是不可变类型的。而且它实现了字符串的interning 概念。<br>
字符串池是享元设计模式的一个实例。</p>
<p>字符串池有助于为Java运行时节省了很多的内存空间，即使它使用了更多的时间。</p>
<p>当我们使用双引号创建字符串时，它首先在字符串池中寻找同样值的字符串，如果找到了就返回该引用。如果没找到，就在池中创建一个新的字符串并返回它的引用。</p>
<p>然而使用new操作符创建字符串时，我们强制String类在堆内存上创建一个新的String对象。我们可以使用intern() 方法将它放到String池中。或者指向字符串池中有相同值字符串对象的引用。</p>
<p>下面是java程序：</p>
<pre><code>package com.journaldev.util;

public class StringPool {

    /**
    * Java String Pool example
    * @param args
    */
    public static void main(String[] args) {
        String s1 = &quot;Cat&quot;;
        String s2 = &quot;Cat&quot;;
        String s3 = new String(&quot;Cat&quot;);
        
        System.out.println(&quot;s1 == s2 :&quot;+(s1==s2));
        System.out.println(&quot;s1 == s3 :&quot;+(s1==s3));
    }

}
</code></pre>
<p>上面程序输入如下：</p>
<pre><code>s1 == s2 :true
s1 == s3 :false
</code></pre>
<p>推荐阅读: <a href="https://www.journaldev.com/16928/java-string">Java String Class</a></p>
<h2 id="字符串池中创建了几个string对象呢">字符串池中创建了几个String对象呢？</h2>
<p>有时候在Java面试中，你可能被问到关于字符串池的问题，比如，下面的语句创建了几个string.</p>
<p>String str = new String(&quot;Cat&quot;);</p>
<p>在上面的语句中，1个或者2个string被创建了，如果字符串池中已经有’cat‘字符串了，就只创建一个String.如果字符串池中没有’cat‘字符串，首先在字符串池中创建一个字符串，然后在堆内存中创建一个字符串，所有总共有2个string对象被创建了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译-Java数组转换成List（Java Array to List Examples）]]></title>
        <id>https://philadelphia.github.io/post/fan-yi-java-shu-zu-zhuan-huan-cheng-listjava-array-to-list-examples</id>
        <link href="https://philadelphia.github.io/post/fan-yi-java-shu-zu-zhuan-huan-cheng-listjava-array-to-list-examples">
        </link>
        <updated>2019-11-25T02:39:32.000Z</updated>
        <content type="html"><![CDATA[<p>原文链接：http<a href=""></a>s://javadevnotes.com/java-array-to-list-examples</p>
<p>译文：</p>
<p>有时候我们需要将数组类型转换成为集合类型，因为后者是一个更为强大的数据结构，java.util.List 有许多普通数组不支持的功能。比如：我们可以通过List的内置方法轻易地检测list是否包含某一个特定的值。下面是一些怎么将数组转换为list的例子。</p>
<h2 id="通过-javautilarraysaslist将-array-转换成-list"><strong>通过 java.util.Arrays.asList()将 Array 转换成 List</strong></h2>
<p>Arrays 类有一个方便的方法asList,可以帮助转换任务，下面是语法：<br>
<code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code><br>
注意：参数不一定必须是数组，可变参数也可以。它可以创建一个list</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;);
   }
}
</code></pre>
<p>以上代码将穿件一个包含一个元素&quot;Apple&quot;的集合。我们也可以这样做：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;);
   }
}
</code></pre>
<p>这将生成一个包含两个元素&quot;Apple&quot;,&quot;Orange&quot;的集合</p>
<p>因为这是一个可变参数。我们可以传递一个数组，数组元素被认定为参数，例子：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = Arrays.asList(myArray);
      for (String str : myList) {
         System.out.println(str);
      }
   }
}
</code></pre>
<p>这样,一个String集合被创建出来了。数组myArray被添加进去了。myList 集合有三个元素，一下是输出：</p>
<p>Apple<br>
Banana<br>
Orange</p>
<h2 id="陷阱">陷阱</h2>
<p>这个方法有一些问题，传递进去的数组必须是一个对象数组，而不能是一个基本类型数组。比如：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      int[] myArray = { 1, 2, 3 };
      List myList = Arrays.asList(myArray);
      System.out.println(myList.size());
   }
}
</code></pre>
<p>代码输出是1。为什么呢？因为asList方法期望一个对象的可变参数，但是传递进去的参数是一个基本类型数组，它创建了一个数组集合。所以该集合的为唯一元素是myArray。因此<code>myList.get(0)</code> 将返回与myArray同样的对象。</p>
<h2 id="aslist创建的对象是固定大小的"><strong>asList()创建的对象是固定大小的</strong></h2>
<p>asList()方法返回的list对象是固定大小的，不能容纳更多的元素，比如：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = Arrays.asList(myArray);
      myList.add(&quot;Guava&quot;);
   }
}
</code></pre>
<p>输出如下：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:148)
	at java.util.AbstractList.add(AbstractList.java:108)
	at Test.main(Test.java:8)
</code></pre>
<p>因为myList是固定长度的，不能添加更多元素。</p>
<p>因为该方法返回的List对象不是java.util包下面的ArrayList，而是Arrays内部的ArrayList类型。改类没有实现add,revmove,clear方法，所以任何对改集合结构修改的调用都将失败。</p>
<h2 id="将基本数组类型转换成list"><strong>将基本数组类型转换成List</strong></h2>
<p>正如上面提到的。传递一个基本类型数组到asList方法不生效，一个不引入第三方库的解决办法是通过Java8 的流，例子如下：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      int[] intArray = { 5, 10, 21 };
      List myList = Arrays.stream(intArray).boxed()
            .collect(Collectors.toList());
   }
}
</code></pre>
<p>数组的每一个元素都被从int转换成了Integer类型(装箱)，数组就被转成了List类型。</p>
<h2 id="将数组转换成允许添加元素的list"><strong>将数组转换成允许添加元素的List</strong></h2>
<p>正如上面陷阱部分提到的，Arrays.asList()方法不支持添加或者移除元素。如果你不想这样，下面是可选方案：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(myArray));
      myList.add(&quot;Guava&quot;);
   }
}
</code></pre>
<p>这段代码显式地创建了一个新的ArrayList对象，然后将Arrays.asList的结果添加进去了。因为我们创建了一个ArrayList。所以没有添加移除限制，上面的代码执行结束前有四个元素。不要指望代码执行时抛出异常。</p>
<h2 id="自己实现array组转换成list"><strong>自己实现Array组转换成List</strong></h2>
<p>有时候解决问题，使用我们自己的实现方案是更好的。下面是一个将java数组转换成List的简单例子:</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
      for (String str : myArray) {
         myList.add(str);
      }
      System.out.println(myList.size());
   }
}
</code></pre>
<p>代码的预期输出是3.因为逻辑执行完集合了有3个元素。</p>
<p>我们代码的负面是代码更长了，而且我们在重复造轮子。好处就是当我们的需求改变时，我们可以顺应自定义。比如：下面的代码，每一个元素都被添加到list中两次</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
      for (String str : myArray) {
         myList.add(str);
         myList.add(str);
      }
      System.out.println(myList.size());
   }
}
</code></pre>
<p>输出是6，因为数组中的元素都被添加两次。下面是另外一个将String数组转换成List<Integer> 的例子：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio 在APP启动时debug app]]></title>
        <id>https://philadelphia.github.io/post/android-studio-zai-app-qi-dong-shi-debug-app</id>
        <link href="https://philadelphia.github.io/post/android-studio-zai-app-qi-dong-shi-debug-app">
        </link>
        <updated>2019-11-20T10:30:56.000Z</updated>
        <content type="html"><![CDATA[<p>有时候APP一启动就崩溃了，对应Android 就是在Application 的onCreate()方法执行时就崩溃，这个时候我们根本来不及点击debug 按钮，所以我们就无法select a process to attach to debugger.<br>
我们只能以Debug模式运行APP，麻烦</p>
<p>我们可以在<strong>设置</strong>-<strong>开发者选项</strong>(前提是已经打开开发者选项了)-<strong>选择调试应用</strong>(选择我们想要调试的应用)-勾选 <strong>等待调试器</strong> 就好了。<br>
<img src="https://philadelphia.github.io/post-images/1574247141968.jpg" alt=""></p>
<p>这个时候APP启动后不会继续执行，等我们点击debug 按钮后APP才会继续往下执行，这个时候我们就可以调试了。debug 完毕后关闭就行了。<br>
<img src="https://philadelphia.github.io/post-images/1574247152856.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity launchMode在开发中的一些使用]]></title>
        <id>https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong</id>
        <link href="https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong">
        </link>
        <updated>2019-11-19T10:54:50.000Z</updated>
        <content type="html"><![CDATA[<p>最近在做APP的通知模块时，产品要求点击通知后</p>
<ol>
<li>在用户登录的情况下直接进入到通知消息的详情页，</li>
<li>没有登录的情况下先进行登录，然后在跳转到消息的详情页</li>
</ol>
<p>但是登录页面可能包含了N多个步骤，所以最好的方式是当用户没有登录的情况下使用startActivityForResult进行登录请求，把登录功能当做一个模块，<br>
因为登录支持很多方式登录，用户在登录页面可能使用账密登录或者点击其他登录选项使用其他方式登录，<br>
我们只需要关注LogInActivity就行了，<br>
如果使用其他登录方式进行登录，当登录成功后跳转到LogInActivity<br>
我们可以给跳转intent设置flag<br>
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP);</p>
<p>只有这两种启动标志组合使用，才会调用LogInActivity的onNewIntent方法。<br>
而如果单独使用<br>
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>
的话，会将LoginActivity提到栈顶并销毁其他Activity，但是并不会回调onNewIntent方法。</p>
<p>这样的话我们就相当于使用singleTask的方式启动了LogInActivity<br>
这样中间登录步骤的页面就可以全部销毁了。<br>
然后在LogInActivity的onNewIntent()方法中setResult(Activity.Result_OK）来告诉强求页登录成功了，</p>
<pre><code>@Override
protected void onNewIntent(Intent intent) {
      super.onNewIntent(intent);
      setResult(RESULT_OK);
      finish();   
}
</code></pre>
<p>没有登录的情况下复写onBackPressed()方法就行了，因为不论使用何种登录方式，只要进行到一半返回，最终没有完成登录返回的话一定会调用onBackPressed方法。因为只用成功才会自动finish LoginActivity</p>
<pre><code>@Override
public void onBackPressed() {
    super.onBackPressed();
    setResult(RESULT_CANCELED);
}
</code></pre>
<p>其他功能也类似，比如认证相关的功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode之位运算]]></title>
        <id>https://philadelphia.github.io/post/leetcode-zhi-wei-yun-suan</id>
        <link href="https://philadelphia.github.io/post/leetcode-zhi-wei-yun-suan">
        </link>
        <updated>2019-11-15T14:13:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">//判断一个整数是不是2的N次方
private boolean is2N(int num) {
    return (num &amp; (num - 1)) == 0;
}

//判断一个正整数是奇数还是偶数,即可不是被2整除
private boolean isEvenNumber(int num) {
    return (num &amp; 1) == 0;
}

</code></pre>
<p>338：https://leetcode-cn.com/problems/counting-bits/</p>
<p>给定一个非负整数 <strong>num</strong>。计算其二进制数中的 1 的数目。</p>
<pre><code class="language-java">private int getBit1Count(int number) {
    int mask = 1;
    int count = 0;
    for (int i = 0; i &lt; 32; i++) {
        if ((number &amp; mask) != 0) {
            count += 1;
        }
        mask &lt;&lt;= 1;
    }

    return count;
}
</code></pre>
<p>136：https://leetcode-cn.com/problems/single-number/</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>1：</p>
<pre><code class="language-java">   public int selectSinlgeNumber(int[] array) {
        // a^a = 0, 0^x = x
        // a^b^a = a^a^b =b
        int a = 0;
        for (int i = 0; i &lt; array.length; i++) {
            a ^= array[i];
            Log.i(TAG, &quot;selectSinlgeNumber: &quot; + a);
        }
        return a;
    }
</code></pre>
<p>2：</p>
<pre><code class="language-java">public int selectSinlgeNumber1(int[] array) {
    HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
    for (int i = 0; i &lt; array.length; i++) {
        if (!hashSet.add(array[i])) {
            hashSet.remove(array[i]);
        }
    }
    Integer[] array1 = (Integer[]) hashSet.toArray();
    return array1[0];
}
</code></pre>
<p>260:https://leetcode-cn.com/problems/single-number-iii/</p>
<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<pre><code>public int[] selectTheSinlgeNumbers(int[] array) {
    int a = 0;
    for (int i = 0; i &lt; array.length; i++) {
        a ^= array[i];
    }
    int mask = a &amp; -a;
  
    int[] b = new int[2];

    for (int j = 0; j &lt; array.length; j++) {
        if ((mask &amp; array[j]) == 0) {
            b[0] ^= array[j];
        } else {
            b[1] ^= array[j];
        }
    }
    return b;
}
</code></pre>
<p>137:https://leetcode-cn.com/problems/single-number-ii/</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[推送]]></title>
        <id>https://philadelphia.github.io/post/tui-song</id>
        <link href="https://philadelphia.github.io/post/tui-song">
        </link>
        <updated>2019-08-30T06:26:20.000Z</updated>
        <content type="html"><![CDATA[<p>随着移动互联网和移动操作系统的发展，移动设备的功能也越来越丰富，客户端和服务端的交互越来越方便。我们可以及时收到服务的发送的信息，及时作出回应，这背后就设计到推送技术。</p>
<h1 id="传统的推送方案">传统的推送方案：</h1>
<ol>
<li>轮询：客户端定期发送Http请求（短连接）。优点：获取更新及时，缺点是浪费带宽，设备电量。(因为HTTP1.0是短连接类型，每次通话结束后就断开连接)</li>
<li>SMS服务，当服务端有推送的需求时，会向所有的客户端发送短信，缺点是  贵，小公司玩不起</li>
<li>长连接，就是连接接后，通信结束后，不断来连接，后续的通信依旧使用该连接，<br>
短连接和长连接的区别见下图：<br>
<img src="https://philadelphia.github.io/post-images/1567148424079.png" alt=""></li>
</ol>
<p>但是长连接也有断开的可能,三种原因会导致长连接的断开</p>
<ol>
<li>NAT超时：因为IP地址的数量有限，很多时候的我们的通信都是使用NAT来完成，但是NAT会定期刷新NAT映射表，会将没有数据通信的连接断开。</li>
<li>DHCP租约过期：一般而言，PC端或手机终端获取IP地址的方式大多是动态获取，即通过DHCP协议从DHCP服务器(一般由路由器同时兼任)获取。目前测试发现安卓系统对DHCP的处理有Bug， DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。</li>
<li>网络状态改变：手机网络和WIFI网络切换， 网络断开和连上等情况， 也会使长连接断开。 这里原因可能比较多， 但结果无非就是IP变了， 或者被系统通知连接断了。</li>
</ol>
<p>针对2，3照成的长连接断开，我们在连接断开后重新发起连接来解决。<br>
针对NAT照成的长连接断开，我们需要定期的发送心跳包来避免NAT失效。</p>
<p>心跳包不是长连接所必需的的，因为TCP连接默认就是长连接的。<br>
在长连接里使用心跳包有两个作用：1：避免NAT失效；2：检测长连接是否有效<br>
因为2，3造成的连接断开是不会通知客户端的，客户端只有发起连接，遇到写超时时才知道连接断开了。</p>
<h1 id="心跳包的发送频率问题">心跳包的发送频率问题：</h1>
<p>心跳包一定要小于NAT的刷新频率，这样才能避免连接被当做失效连接而关闭<br>
如果心跳包发送太频繁，除了浪费流量和电量之外，没有其他意义<br>
如果频率太慢了，可能导致NAT失效<br>
为了维持长连接，需要CPU定时发送心跳包。<br>
如果使用Timer定时器就会导致阻碍CPU进入休眠状态，很宽就会耗尽设备的电量<br>
在Android系统上推荐使用AlarmManager，AlarmManager 是系统封装的一个RTC的管理工具，RTC(Real Time Clock)是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。</p>
<h1 id="心跳包和轮询的区别">心跳包和轮询的区别</h1>
<p>心跳包和轮询看起来类似， 都是客户端主动联系服务器， 但是区别很大。</p>
<p>轮询是为了获取数据， 而心跳是为了保活TCP连接；<br>
轮询得越频繁， 获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系；<br>
轮询比心跳能耗更高， 因为一次轮询需要经过TCP三次握手， 四次挥手， 单次心跳不需要建立和拆除TCP连接。</p>
<h1 id="长连接是如何唤醒设备的">长连接是如何唤醒设备的：</h1>
<p>在设备休眠的时候是依然可以接受到推送的。如果服务器想客户端推送了信息，那么休眠状态下的设备是如何响应的呢，设备已经休眠了啊，要回答这个问题就需要对手机的硬件架构有一定的了解了。<br>
现在的移动设备的处理器一般包括两部分，一部分是AP(Application Processor)<br>
一部分是BP(BaseBand Processor)<br>
AP是用来运行操作系统和应用程序的<br>
BP是用来运行实时操作系统(RTOS)，通讯协议栈运行于BP的RTOS之上<br>
非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP，LCD，WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。</p>
<p>当设备收到数据包时，BP会唤醒AP，这样CPU接下来就会收到服务器发来的推送，然后就可以进行处理了。<br>
1:<a href="https://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/">https://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/</a><br>
2:<a href="http://www.52im.net/thread-341-1-1.html">http://www.52im.net/thread-341-1-1.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RxJava 1.0]]></title>
        <id>https://philadelphia.github.io/post/rxjava-10</id>
        <link href="https://philadelphia.github.io/post/rxjava-10">
        </link>
        <updated>2019-08-16T10:07:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="function">Function</h2>
<p>Function 是Action和Func的父接口。</p>
<pre><code>/**
 * All Func and Action interfaces extend from this.
 * &lt;p&gt;
 * Marker interface to allow instanceof checks.
 */
public interface Function {

}
</code></pre>
<h2 id="action">Action</h2>
<pre><code>/**
 * All Action interfaces extend from this.
 * &lt;p&gt;
 * Marker interface to allow instanceof checks.
 */
public interface Action extends Function {

}
</code></pre>
<p>Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；</p>
<p>Action 接口有以下子接口，<br>
Action1,Action2------Action9,ActionN</p>
<pre><code>public interface Action1&lt;T&gt; extends Action {
	void call(T t);
}

public interface Action2&lt;T1, T2&gt; extends Action {
	void call(T1 t1, T2 t2);
}

public interface ActionN extends Action {
	void call(Object... args);
}
</code></pre>
<h2 id="func">Func</h2>
<pre><code>Func接口几次Function接口和Callable接口，并复写Callable接口的call方法。
Func0接口没有参数，只有返回值，
Func1有一个参数，
Func2有两个参数。
.
.
.
Func9有9个参数，
以此类推，FuncN有N个参数


/**
 * Represents a function with zero arguments.
 */
public interface Func0&lt;R&gt; extends Function, Callable&lt;R&gt; {
	@Override
	R call();
}

/**
 * Represents a function with one argument.
 */
public interface Func1&lt;T, R&gt; extends Function {
	R call(T t);
}

/**
 * A vector-argument action.
 */
public interface Func9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; extends Function {
	R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
}
</code></pre>
<p>在创建Observable以后，我们可以通过Observable.subscribe(final Action1&lt;? super T&gt; onNext, final Action1<Throwable> onError, final Action0 onCompleted)</p>
<p>如果我们只传递onNext，onError和onComplete会使用系统默认的。</p>
<pre><code>public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }

    Action1&lt;Throwable&gt; onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;
    Action0 onCompleted = Actions.empty();
    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}

 public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    if (onError == null) {
        throw new IllegalArgumentException(&quot;onError can not be null&quot;);
    }

    Action0 onCompleted = Actions.empty();
    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}

public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    if (onError == null) {
        throw new IllegalArgumentException(&quot;onError can not be null&quot;);
    }
    if (onCompleted == null) {
        throw new IllegalArgumentException(&quot;onComplete can not be null&quot;);
    }

    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}
</code></pre>
<p>最终系统会将onNext,onError，onComplete，组合成一个ActionSubscriber，</p>
<pre><code>new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted)
/**
 * A Subscriber that forwards the onXXX method calls to callbacks.
 * @param &lt;T&gt; the value type
 */
	public final class ActionSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {

    final Action1&lt;? super T&gt; onNext;
    final Action1&lt;Throwable&gt; onError;
    final Action0 onCompleted;

    public ActionSubscriber(Action1&lt;? super T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted) {
        this.onNext = onNext;
        this.onError = onError;
        this.onCompleted = onCompleted;
    }

    @Override
    public void onNext(T t) {
        onNext.call(t);
    }

    @Override
    public void onError(Throwable e) {
        onError.call(e);
    }

    @Override
    public void onCompleted() {
        onCompleted.call();
    }
}
</code></pre>
<h2 id="observer">Observer</h2>
<pre><code>public interface Observer&lt;T&gt; {
	void onCompleted();

	void onError(Throwable e);

	void onNext(T t);
</code></pre>
<p>}</p>
<h2 id="subscriber">Subscriber</h2>
<p>Subscriber实现了Subscription接口，复写了其<code>unsubscribe</code>和<code>isUnsubscribed</code>方法。<br>
在<code>Observer</code>的基础上增加了<code>onStart</code>，<code>request</code>，<code>addToRequested</code>，<code>setProducer</code>方法。</p>
<pre><code>public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription{

    // represents requested not set yet
    private static final Long NOT_SET = Long.MIN_VALUE;

    private final SubscriptionList subscriptions;
    private final Subscriber&lt;?&gt; subscriber;
    /* protected by `this` */
    private Producer producer;
    /* protected by `this` */
    private long requested = NOT_SET; // default to not set

    protected Subscriber() {
        this(null, false);
    }


    protected Subscriber(Subscriber&lt;?&gt; subscriber) {
        this(subscriber, true);
    }

   
    protected Subscriber(Subscriber&lt;?&gt; subscriber, boolean shareSubscriptions) {
        this.subscriber = subscriber;
        this.subscriptions = shareSubscriptions &amp;&amp; subscriber != null ? subscriber.subscriptions : new SubscriptionList();
    }


    public final void add(Subscription s) {
        subscriptions.add(s);
    }

    @Override
    public final void unsubscribe() {
        subscriptions.unsubscribe();
    }


    @Override
    public final boolean isUnsubscribed() {
        return subscriptions.isUnsubscribed();
    }

    
    public void onStart() {
        // do nothing by default
    }
    
    
    protected final void request(long n) {
        if (n &lt; 0) {
            throw new IllegalArgumentException(&quot;number requested cannot be negative: &quot; + n);
        } 
        
        // if producer is set then we will request from it
        // otherwise we increase the requested count by n
        Producer producerToRequestFrom = null;
        synchronized (this) {
            if (producer != null) {
                producerToRequestFrom = producer;
            } else {
                addToRequested(n);
                return;
            }
        }
        // after releasing lock (we should not make requests holding a lock)
        producerToRequestFrom.request(n);
    }

    private void addToRequested(long n) {
        if (requested == NOT_SET) {
            requested = n;
        } else { 
            final long total = requested + n;
            // check if overflow occurred
            if (total &lt; 0) {
                requested = Long.MAX_VALUE;
            } else {
                requested = total;
            }
        }
    }
    
  
    public void setProducer(Producer p) {
        long toRequest;
        boolean passToSubscriber = false;
        synchronized (this) {
            toRequest = requested;
            producer = p;
            if (subscriber != null) {
                // middle operator ... we pass through unless a request has been made
                if (toRequest == NOT_SET) {
                    // we pass through to the next producer as nothing has been requested
                    passToSubscriber = true;
                }
            }
        }
        // do after releasing lock
        if (passToSubscriber) {
            subscriber.setProducer(producer);
        } else {
            // we execute the request with whatever has been requested (or Long.MAX_VALUE)
            if (toRequest == NOT_SET) {
                producer.request(Long.MAX_VALUE);
            } else {
                producer.request(toRequest);
            }
        }
    }
}
</code></pre>
<h2 id="observable-与observer建立绑定关系">Observable 与Observer建立绑定关系</h2>
<p>Observable.create().subscribe(new Observer)</p>
<pre><code>  public final Subscription subscribe(final Observer&lt;? super T&gt; observer) {
        if (observer instanceof Subscriber) {
            return subscribe((Subscriber&lt;? super T&gt;)observer);
        }
        return subscribe(new ObserverSubscriber&lt;T&gt;(observer));
    }
</code></pre>
<p>如果传入的直接是一个Subscriber对象的话，直接调用subscribe（Subscriber observer）<br>
否则调用subsribe(new ObserverSubscriber<T>(observer)),将observer构造成一个ObserverSubscriber对象传入。<br>
其实两者都是一样的。因为<code>ObserverSubscriber</code> 也是<code>Subscriber</code>的子类。</p>
<h2 id="observersubscriber">ObserverSubscriber</h2>
<pre><code>	/**
	 * Wraps an Observer and forwards the onXXX method calls to it.
	 * @param &lt;T&gt; the value type
	 */
	public final class ObserverSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {
    final Observer&lt;? super T&gt; observer;

    public ObserverSubscriber(Observer&lt;? super T&gt; observer) {
        this.observer = observer;
    }
    
    @Override
    public void onNext(T t) {
        observer.onNext(t);
    }
    
    @Override
    public void onError(Throwable e) {
        observer.onError(e);
    }
    
    @Override
    public void onCompleted() {
        observer.onCompleted();
    }
}
</code></pre>
<p>该类包裹了一个Observer对象。所有的实现其实是Observer对象来操作的。</p>
<pre><code>	 public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {
	        return Observable.subscribe(subscriber, this);
	    }



    static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
     // validate and proceed
        if (subscriber == null) {
            throw new IllegalArgumentException(&quot;observer can not be null&quot;);
        }
        if (observable.onSubscribe == null) {
            throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);
            /*
             * the subscribe function can also be overridden but generally that's not the appropriate approach
             * so I won't mention that in the exception
             */
        }
        
        // new Subscriber so onStart it
		先调用subscriber的onStart方法。
        subscriber.onStart();
        
        /*
         * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls
         * to user code from within an Observer&quot;
         */
        // if not already wrapped
        if (!(subscriber instanceof SafeSubscriber)) {
            // assign to `observer` so we return the protected version
            subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
        }

        // The code below is exactly the same an unsafeSubscribe but not used because it would 
        // add a significant depth to already huge call stacks.
        try {
            // allow the hook to intercept and/or decorate
            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
            return hook.onSubscribeReturn(subscriber);
        } catch (Throwable e) {
            // special handling for certain Throwable/Error/Exception types
            Exceptions.throwIfFatal(e);
            // in case the subscriber can't listen to exceptions anymore
            if (subscriber.isUnsubscribed()) {
                RxJavaPluginUtils.handleException(hook.onSubscribeError(e));
            } else {
                // if an unhandled error occurs executing the onSubscribe we will propagate it
                try {
                    subscriber.onError(hook.onSubscribeError(e));
                } catch (Throwable e2) {
                    Exceptions.throwIfFatal(e2);
                    // if this happens it means the onError itself failed (perhaps an invalid function implementation)
                    // so we are unable to propagate the error correctly and will just throw
                    RuntimeException r = new OnErrorFailedException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);
                    // TODO could the hook be the cause of the error in the on error handling.
                    hook.onSubscribeError(r);
                    // TODO why aren't we throwing the hook's return value.
                    throw r;
                }
            }
            return Subscriptions.unsubscribed();
        }
    }
</code></pre>
<p>该方法返回一个<code>Subscription</code>对象</p>
<h2 id="subscription">Subscription</h2>
<pre><code>	public interface Subscription {

    /**
     * Stops the receipt of notifications on the {@link Subscriber} that was registered when this Subscription
     * was received.
     * &lt;p&gt;
     * This allows unregistering an {@link Subscriber} before it has finished receiving all events (i.e. before
     * onCompleted is called).
     */
    void unsubscribe();

    /**
     * Indicates whether this {@code Subscription} is currently unsubscribed.
     *
     * @return {@code true} if this {@code Subscription} is currently unsubscribed, {@code false} otherwise
     */
    boolean isUnsubscribed();

}
</code></pre>
<p>该接口有两个方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit2.0简介]]></title>
        <id>https://philadelphia.github.io/post/retrofit20-jian-jie</id>
        <link href="https://philadelphia.github.io/post/retrofit20-jian-jie">
        </link>
        <updated>2019-08-16T10:07:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1定义">1.定义</h2>
<p>官方的Retrofit主页是这样描述它的</p>
<blockquote>
<p>A type-safe HTTP client for Android and Java</p>
</blockquote>
<blockquote>
<p>用于Android和Java的一个类型安全(type-safe)的REST客户端</p>
</blockquote>
<p>你可以使用注解去描述HTTP请求，同时Retrofit默认集成URL参数替换和查询参数.除此之外它还支持 Multipart请求和文件上传。</p>
<h2 id="2使用">2.使用</h2>
<p>注意这个任务是网络任务，不要忘记给程序加入网络权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies { 
 // Retrofit &amp;amp; OkHttp
compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
}
</code></pre>
<p><code>Retrofit</code> 需要最低<code>JDK 1.7</code> 和 <code>Android 2.3</code>.</p>
<p>retfofit 使用注解的方式定义API</p>
<p>方法类型有：</p>
<blockquote>
<p>GET, POST, PUT, DELETE, HEAD</p>
</blockquote>
<p>1	声明API</p>
<pre><code>public interface GitHubService {
  @GET(&quot;users/{user}/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}
</code></pre>
<p>2	初始化Retrofit</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com/&quot;)
.build();

GitHubService service = retrofit.create(GitHubService.class);
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);    
</code></pre>
<p>3	发起请求：</p>
<p>//同步请求</p>
<pre><code>try {
  Response&lt;List&lt;Repo&gt;&gt; bodyResponse = call.execute();
  String body = bodyResponse.body().string();//获取返回体的字符串
  Log.i(&quot;wxl&quot;, &quot;body=&quot; + body);
  } catch (IOException e) {
  e.printStackTrace();
  }
</code></pre>
<p>//异步请求</p>
<pre><code>call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {
            @Override
            public void onResponse(Response&lt;List&lt;Repo&gt;&gt; response) {
                try {
                    Log.i(&quot;wxl&quot;, &quot;response=&quot; + response.body().string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void onFailure(Throwable t) {
                Log.i(&quot;wxl&quot;, &quot;onFailure=&quot; + t.getMessage());
            }
        });
</code></pre>
<p>4 取消请求</p>
<pre><code>call.cancel();
</code></pre>
<p>所有的请求方法都是按照上述类型执行。<br>
在方法声明时注解@GET，@POST,@PUT 分别对应方法的类型。</p>
<p>接口参数</p>
<blockquote>
<p>Path</p>
</blockquote>
<p>ApiStores</p>
<pre><code> /**
 * Call&lt;T&gt; get();必须是这种形式,这是2.0之后的新形式
 * 如果不需要转换成Json数据,可以用了ResponseBody;
 * 你也可以使用Call&lt;GsonBean&gt; get();这样的话,需要添加Gson转换器
 */
public interface ApiStores {
    @GET(&quot;adat/sk/{cityId}.html&quot;)
    Call&lt;ResponseBody&gt; getWeather(@Path(&quot;cityId&quot;) String cityId);
}
</code></pre>
<blockquote>
<p>Query</p>
</blockquote>
<p>如果链接是http://ip.taobao.com/service/getIpInfo.php?ip=202.202.33.33</p>
<p>ApiStores</p>
<pre><code>public interface ApiStores {
	@GET(&quot;http://ip.taobao.com/service/getIpInfo.php&quot;)
	Call&lt;ResponseBody&gt; getWeather(@Query(&quot;ip&quot;) String ip);
</code></pre>
<p>复杂的查询参数也可以使用Map。</p>
<pre><code>@GET(&quot;group/{id}/users&quot;)
Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options);
</code></pre>
<blockquote>
<p>Headers</p>
</blockquote>
<p>你可以通过@Headers参数来设置静态headers</p>
<pre><code>@Headers(&quot;Cache-Control: max-age=640000&quot;)
@GET(&quot;widget/list&quot;)
Call&lt;List&lt;Widget&gt;&gt; widgetList();

@Headers({
    &quot;Accept: application/vnd.github.v3.full+json&quot;,
    &quot;User-Agent: Retrofit-Sample-App&quot;
})
@GET(&quot;users/{username}&quot;)
Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username);
</code></pre>
<p><code>Headers</code>不复写其他的<code>Headers</code>值。所有同名的的<code>Headers</code>参数都将包含在该请求中。<br>
Request的Header可以通过使用<code>@Header</code>注解动态更新。必须给<code>@Header</code>提供一个相应的参数。如果该值为空，该<code>Header</code>就被忽略了。不然就会调用value的<code>toString()</code>方法获得value的值。</p>
<pre><code>@GET(&quot;user&quot;)
Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)
</code></pre>
<p>每一个request都有的header可以通过设置<code>OkHttp interceptor</code>来统一添加。</p>
<blockquote>
<p>Body</p>
</blockquote>
<p>这是针对POST方式，如果参数是json格式，如：</p>
<pre><code>{		
    &quot;apiInfo&quot;: {		
        &quot;apiName&quot;: &quot;WuXiaolong&quot;,		
        &quot;apiKey&quot;: &quot;666&quot;		
    }		
}
</code></pre>
<p>ApiStores</p>
<pre><code>public interface ApiStores {
    @POST(&quot;client/shipper/getCarType&quot;)
    Call&lt;ResponseBody&gt; getCarType(@Body ApiInfo apiInfo);
   }
</code></pre>
<p>这个<code>Object</code>将被<code>Retrofit</code>对象所指定的<code>Converter</code>所转换，如果没有指定转换器，只能使用<code>RequestBody</code>来定义参数。</p>
<p>建立Bean</p>
<pre><code>public class ApiInfo {
       private ApiInfoBean apiInfo;
       public ApiInfoBean getApiInfo() {
           return apiInfo;
       }
       public void setApiInfo(ApiInfoBean apiInfo) {
           this.apiInfo = apiInfo;
       }
       public class ApiInfoBean {
           private String apiName;
           private String apiKey;
           //省略get和set方法
       }
   }
</code></pre>
<p>代码调用</p>
<pre><code>private void getCarType() {
   mRetrofit = new Retrofit.Builder()
           .baseUrl(&quot;http://WuXiaolong.me/&quot;)
           .addConverterFactory(GsonConverterFactory.create())
           .build();
   ApiStores apiStores = mRetrofit.create(ApiStores.class);
   ApiInfo apiInfo = new ApiInfo();
   ApiInfo.ApiInfoBean apiInfoBean = apiInfo.new ApiInfoBean();
   apiInfoBean.setApiKey(&quot;666&quot;);
   apiInfoBean.setApiName(&quot;WuXiaolong&quot;);
   apiInfo.setApiInfo(apiInfoBean);
   Call&lt;ResponseBody&gt; call = apiStores.getCarType(apiInfo);
   call.enqueue(new Callback&lt;ResponseBody&gt;() {
       @Override
       public void onResponse(Response&lt;ResponseBody&gt; response) {
           String body = null;//获取返回体的字符串
           try {
               body = response.body().string();
           } catch (IOException e) {
               e.printStackTrace();
           }
           Log.i(&quot;wxl&quot;, &quot;get=&quot; + body);
       }
       @Override
       public void onFailure( Throwable t) {
       }
   });
   }
</code></pre>
<blockquote>
<p>Url encode</p>
</blockquote>
<p>POST or PUT Url encode 過的表單資料，用@FormUrlEncoded，使用@Field個別指定</p>
<pre><code>@POST(&quot;/articles/{article_id}/comments&quot;)
@FormUrlEncoded
Comment create(
@Path(&quot;article_id&quot;) int articleId,
@Field(&quot;rating&quot;) int rating,
@Field(&quot;content&quot;) String content
);
</code></pre>
<p>POST or PUT Url encode 過的表單資料，用@FormUrlEncoded，參數也可用@Body傳</p>
<pre><code>@POST(&quot;/articles/{article_id}/comments&quot;)
@FormUrlEncoded
Comment create(
    @Path(&quot;article_id&quot;) int articleId,
    @Body Comment comment
);
</code></pre>
<blockquote>
<p>POST or PUT 用@Multipart來上傳檔案</p>
</blockquote>
<pre><code>@PUT(&quot;/me&quot;)
@Multipart
Me update(
    @Part(&quot;display_name&quot;) String displayName,
    @Part(&quot;avatar&quot;) TypedFile avatar
);
</code></pre>
<p>更详细的信息，请点击：<a href="http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/">http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/</a></p>
<p>更多更有效的 Converters</p>
<blockquote>
<p>默认情况下，<code>Retrofit</code> 只能反序列化<code>HTTP</code> body到<code>OKHTTP</code>的<code>ResponseBody</code>类型。并且<code>OKHTTP</code>只接受<code>Retrifit</code> <code>@Body</code>类型的<code>RequestBody</code><br>
可以添加<code>Converter</code>转换器来支持其他的类型，6个相似的兼容流行的序列化库模块可以供使用。</p>
</blockquote>
<pre><code>Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson	
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml	
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
</code></pre>
<p>例子:</p>
<pre><code>interface which uses Gson for its deserialization.

Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com&quot;)
    .addConverterFactory(GsonConverterFactory.create())
    .build();

GitHubService service = retrofit.create(GitHubService.class);
</code></pre>
<blockquote>
<p>Retrofit 1 里有一个 converter 的问题。多数人可能没遇到过，是库内部的一个问题。在 Retrofit 2 里，已经解决了这个问题，同时开始支持多种 Converter 并存。</p>
</blockquote>
<blockquote>
<p>在之前，如果你遇到这种情况：一个 API 请求返回的结果需要通过 JSON 反序列化，另一个 API 请求需要通过 proto 反序列化，唯一的解决方&gt;案就是将两个接口分离开声明。</p>
</blockquote>
<pre><code>interface SomeProtoService {
  @GET(&quot;/some/proto/endpoint&quot;)
  Call&lt;SomeProtoResponse&gt; someProtoEndpoint();
}

interface SomeJsonService {
  @GET(&quot;/some/json/endpoint&quot;)
  Call&lt;SomeJsonResponse&gt; someJsonEndpoint();
</code></pre>
<blockquote>
<p>之所以搞得这么麻烦是因为一个 REST adapter 只能绑定一个 Converter 对象。我们费工夫去解决这个是因为：接口的声明是要语意化的。API 接口应该通过功能实现分组，比如： account 的接口，user 的接口，或者 Twitter 相关的接口。返回格式的差异不应该成为你分组时候的阻碍。</p>
</blockquote>
<blockquote>
<p>现在，你可以把他们都放在一起了：</p>
</blockquote>
<pre><code>interface SomeService {
  @GET(&quot;/some/proto/endpoint&quot;)
  Call&lt;SomeProtoResponse&gt; someProtoEndpoint();

  @GET(&quot;/some/json/endpoint&quot;)
  Call&lt;SomeJsonResponse&gt; someJsonEndpoint();
}
</code></pre>
<blockquote>
<p>SomeProtoResponse —&gt; Proto? Yes!</p>
</blockquote>
<blockquote>
<p>原理很简单，其实就是对着每一个 converter 询问他们是否能够处理某种类型。我们问 proto 的 converter： “Hi, 你能处理 SomeProtoResponse 吗？”，然后它尽可能的去判断它是否可以处理这种类型。我们都知道：Protobuff 都是从一个名叫 message 或者 message lite 的类继承而来。所以，判断方法通常就是检查这个类是否继承自 message。<br>
在面对 JSON 类型的时候，首先问 proto converter，proto converter 会发现这个不是继承子 Message 的，然后回复 no。紧接着移到下一个 JSON converter 上。JSON Converter 会回复说我可以！</p>
</blockquote>
<blockquote>
<p>SomeJsonResponse —&gt; Proto? No! —&gt; JSON? Yes!</p>
</blockquote>
<blockquote>
<p>因为 JSON 并没有什么继承上的约束。所以我们无法通过什么确切的条件来判断一个对象是否是 JSON 对象。以至于 JSON 的 converters 会对任何数据都回复说：我可以处理！这个一定要记住， JSON converter 一定要放在最后，不然会和你的预期不符。</p>
<p>另一个要注意的是，现在已经不提供默认的 converter 了。如果不显性的声明一个可用的 Converter 的话，Retrofit 是会报错的：提醒你没有可用的 Converter。因为核心代码已经不依赖序列化相关的第三方库了，我们依然提供对 Converter 的支持，不过你需要自己引入这些依赖，同时显性的声明 Retrofit 需要用的 Converter 有哪些。<br>
添加 converter 的顺序很重要。按照这个顺序，我们将依次询问每一个 converter 能否处理一个类型。我上面写的其实是错的。如果我们试图反序列化一个 proto 格式，它其实会被当做 JSON 来对待。这显然不是我们想要的。我们需要调整下顺序，因为我们先要检查 proto buffer 格式，然后才是 JSON。</p>
</blockquote>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com&quot;)
.addConverterFactory(ProtoConverterFactory.create())
.addConverterFactory(GsonConverterFactory.create())
.build();
</code></pre>
<blockquote>
<p>由于现在Retrofit开始依赖 OkHttp， 并没有 Http Client 层的抽象。现在是可以传递一个配置好的 OkHttp 实例的。比如：配置 interceptors, 或者一个 SSL socket 工厂类， 或者 timeouts 的具体数值。 （OkHttp 有默认的超时机制，如果你不需要自定义，实际上不&gt;必进行任何设置，但是如果你想要去设置它们，下面是一个例子告诉你来怎么操作。）</p>
</blockquote>
<pre><code> OkHttpClient client = new OkHttpClient.Builder()
            .retryOnConnectionFailure(true)			//失败后是否重试
            .connectTimeout(15, TimeUnit.SECONDS)	//设置连接超时时间
            .addInterceptor(getHttpInterceptor())	//设置应用拦截器
            .build();

Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com&quot;)	//设置BaseURL
    .client(client)						//设置client
    .build();
</code></pre>
<h2 id="3-interceptor">3 Interceptor</h2>
<blockquote>
<p>在使用Android retrofit+rxjava时，想获知网络请求的一些参数，方便调试，比如：请求地址、请求响应时间、请求响应消息体等内容，虽然部分可以通过每个接口进行获知，但是这样极其不方便，可以使用拦截器来做统一的操作。</p>
</blockquote>
<p>添加拦截器：<br>
可以针对OkHttpClient.Builder 添加拦截器</p>
<pre><code>HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);	//设置日志级别

OkHttpClient client = new OkHttpClient.Builder()
            .retryOnConnectionFailure(true)			//失败后是否重试
            .connectTimeout(15, TimeUnit.SECONDS)	//设置连接超时时间
            .addInterceptor(interceptor)	//设置应用拦截器
            .build();
</code></pre>
<h2 id="4cache">4.Cache</h2>
<blockquote>
<p>开启OKHttp缓存：</p>
</blockquote>
<p>先获取系统外部存储的路径，”xxx”可以自己命名，缓存文件就存在 Android/data/&lt;包名&gt;/cache/resposes。</p>
<pre><code>File httpCacheDirectory = new File(UIUtils.getContext().getExternalCacheDir(), &quot;xxx&quot;); 
client.setCache(new Cache(httpCacheDirectory,10 * 1024 * 1024));
</code></pre>
<h2 id="5proguard">5.Proguard</h2>
<blockquote>
<p>如果你在你的代码里使用代码混淆机制,请在你的配置里添加下面几行.</p>
</blockquote>
<pre><code># Platform calls Class.forName on types which do not exist on Android to determine platform.
-dontnote retrofit2.Platform
# Platform used when running on RoboVM on iOS. Will not be used at runtime.
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
# Platform used when running on Java 8 VMs. Will not be used at runtime.
-dontwarn retrofit2.Platform$Java8
# Retain generic type information for use by reflection by converters and adapters.
-keepattributes Signature
# Retain declared checked exceptions for use by a Proxy instance.
-keepattributes Exceptions
</code></pre>
<h2 id="6-nitoice">6 Nitoice</h2>
<blockquote>
<p>Retrofit 在请求失败时依然会回调 <code>onResponse()</code>方法。及时response code不是200依然会回调一下方法，需要注意。</p>
</blockquote>
<pre><code> public void onResponse(Call&lt;LoginResult&gt; call, Response&lt;LoginResult&gt; response) {
	 
}
</code></pre>
<h2 id="7references">7:References</h2>
<ol>
<li>
<p>Retrofit github主页：<a href="https://square.github.io/retrofit/" title="retrofit github 主页">https://square.github.io/retrofit/</a></p>
</li>
<li>
<p>Interceptor wiki:	<a href="https://github.com/square/okhttp/wiki/Interceptors" title="retrofit interceptor">https://github.com/square/okhttp/wiki/Interceptors</a></p>
</li>
<li>
<p>用 Retrofit 2 简化 HTTP 请求	<a href="https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/"> https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/</a></p>
</li>
<li>
<p>Http Caching:		<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" title="Http Cache">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p>
</li>
<li>
<p>四种常见的 POST 提交数据方式		<a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" title="四种常见的 POST 提交数据方式">https://imququ.com/post/four-ways-to-post-data-in-http.html</a></p>
</li>
<li>
<p>Blog				 <a href="http://wuxiaolong.me/2016/01/15/retrofit/" title="Blog"> http://wuxiaolong.me/2016/01/15/retrofit/</a></p>
</li>
<li>
<p>URL wikipedia: 		<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" title="URL wikipedia: ">https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6</a></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit: 几种ApiService接口定义的区别]]></title>
        <id>https://philadelphia.github.io/post/retrofit-ji-chong-apiservice-jie-kou-ding-yi-de-qu-bie</id>
        <link href="https://philadelphia.github.io/post/retrofit-ji-chong-apiservice-jie-kou-ding-yi-de-qu-bie">
        </link>
        <updated>2019-08-16T10:06:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="retrofit声明-apiservice接口">Retrofit:声明 ApiService接口</h1>
<p>我们在使用Retrofit的时候只需要把URL通过注解的形式写到APIService文件中就行了。<br>
比如登录功能：</p>
<p>如果后台的成功返回格式为</p>
<pre><code>{	
	code:0;
	Message:&quot;login success&quot;
}
</code></pre>
<p>失败的返回格式为</p>
<pre><code>{	
	code:-1;
	Message:&quot;login failed&quot;
}
</code></pre>
<p>我们定义个一个Bean类LoginResult.</p>
<pre><code>public class LoginResult{
	private int code;
	private String message;
	
	//get/set
}


</code></pre>
<h2 id="不使用rxjava">不使用Rxjava</h2>
<p>在方法的定义中，如果不适用Rxjava的话，</p>
<pre><code>@Post
@FormUrlEncoded
Call&lt;LogInResult&gt; login(@Field(&quot;userName&quot;) String userName, @Field(&quot;password&quot;)String password);
</code></pre>
<p>在使用的时候们只需要使用apiService.login(&quot;dsf&quot;, &quot;dsf&quot;),就好了。该方法会返回一个Call<LoginResult> 对象</p>
<p>我们只需要或者异步执行</p>
<pre><code>//同步执行
Response&lt;LoginResult&gt; response = call.execute();
//异步调用
call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {

            }
        });
</code></pre>
<p>然后我们在返回结果里面操作就行了，如果我们需要Response里面的元数据，比如header里面的信息的话，直接从Response取就好了。</p>
<p>因为Retrofit 使用DefaultCallAdapterFactory默认将OKHttp返回的Call对象(OkHttp对象)转换成了Retrofit的Call<T>对象了</p>
<h2 id="使用rxajva">使用Rxajva</h2>
<h3 id="observablet">Observable<T></h3>
<p>但是我们在使用RxJava后，有时可能会这样声明接口</p>
<pre><code>@Post
@FormUrlEncoded
Observable&lt;LogInResult&gt; login(@Field(&quot;userName&quot;) String userName, @Field(&quot;password&quot;)String password);
</code></pre>
<p>这样定义可以很方便的在返回中直接subScribe一个Action对象了</p>
<pre><code>Observable&lt;LoginResult&gt; observable = model.login(&quot;dfs&quot;, &quot;dfs&quot;);
observable.subscribe(new Action1&lt;LoginResult&gt;() {
            @Override
            public void call(LoginResult loginResult) {
								if (loginResult.getCode() == 0) {
                    //登录成功   
                } else {
                    //登录失败
                }
					
            }
        });
</code></pre>
<p>但是这样有一个问题就是会丢失Response的元数据，因为Response对象我们是没法访问的。因为Retrofit已经帮助我们做了转换，直接把我们接口方法里定义的数据类型转换好后返回给我们了。去掉了Response信息。</p>
<h3 id="observableresponset">Observable&lt;Response<T>&gt;</h3>
<p>我们可以这么定义接口</p>
<pre><code>@Post
@FormUrlEncoded
Observable&lt;Response&lt;LogInResult&gt;&gt; login(@Field(&quot;userName&quot;) String userName, @Field(&quot;password&quot;)String password);
</code></pre>
<p>这样我们就得到这样的返回结果。</p>
<pre><code class="language-java">Observable&lt;Response&lt;LoginResult&gt;&gt; observable = model.login(&quot;dfs&quot;, &quot;dfs&quot;);
observable.subscribe(new Action1&lt;Response&lt;LoginResult&gt;&gt;() {
            @Override
            public void call(Response&lt;LoginResult&gt; loginResultResponse) {
                if (loginResultResponse.code() == 200){
                    LoginResult body = loginResultResponse.body();
                }else {
                    //登录失败
                }
            }
        });
</code></pre>
<p>这样就能拿到Response信息了，然后根据Response code判断是否登录成功了。</p>
<p>但是这样有个问题是我们写接口会特备繁琐，每次都得使用Response&lt;&gt;泛型。一般我们都写作Observable<LoginResult> login();</p>
<p>其实我们一般情况下也不关注Response信息的。但是不排除特殊情况</p>
<p>比如这种情况<br>
https://academy.realm.io/cn/posts/droidcon-jake-wharton-simple-http-retrofit-2/</p>
<p>这篇文章提到的分页加载的情况，其实这种情况也可以将下一个页面的URL放到Response body里返回。</p>
<p>这里只是给出了一种情景。</p>
<p>现实中解决方案很多种，只能折中了，其实我们没必要使用Response的Response code 来判断接口是否调用成功了。因为Retrofit都帮我们做过了。所以我们定义接口的时候只要使用Observable<Response>就好了。</p>
<p>我们在使用Retrofit + Rxjava 的时候一般都这么生成Retrofit client的</p>
<pre><code> Retrofit retrofit = new Retrofit.Builder()
                .client(okHttpClient)
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .baseUrl(baseUrl)
                .build();
</code></pre>
<p>这里RxJavaCallAdapterFactory生成的CallAdapter对象就帮我们做好了结果的转换</p>
<p>我们看一下RxJavaCallAdapterFactory的声明。</p>
<pre><code>	/**
 * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
 * &lt;p&gt;
 * Adding this class to {@link Retrofit} allows you to return {@link Observable} from service
 * methods.
 * &lt;pre&gt;&lt;code&gt;
 * interface MyService {
 *   &amp;#64;GET(&quot;user/me&quot;)
 *   Observable&amp;lt;User&amp;gt; getUser()
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 * There are three configurations supported for the {@code Observable} type parameter:
 有三种配置支持Observable的类型参数
 * &lt;ul&gt;
 * &lt;li&gt;Direct body (e.g., {@code Observable&lt;User&gt;}) calls {@code onNext} with the deserialized body
 * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
 * {@link IOException} for network errors.&lt;/li&gt;
 第一种：直接使用Observable&lt;T&gt;声明接口, 将会针对所有的2** Response code会调用onNext(T t)方法。所有的Response code 不是200的都调用OnError(Throwable t)方法抛出一个HttpException 异常，网络错误调用onError()方法，并抛出一个IO异常。
 
 * &lt;li&gt;Response wrapped body (e.g., {@code Observable&lt;Response&lt;User&gt;&gt;}) calls {@code onNext}
 * with a {@link Response} object for all HTTP responses and calls {@code onError} with
 * {@link IOException} for network errors&lt;/li&gt;
 //第二种:如果使用Observable&lt;Response&lt;T&gt;&gt;声明接口，那么针对所有的Response将会调用onNext(Respones&lt;T&gt; response)方法，针对网络异常将调用OnError()方法，并抛出一个IO异常。
 * &lt;li&gt;Result wrapped body (e.g., {@code Observable&lt;Result&lt;User&gt;&gt;}) calls {@code onNext} with a
 * {@link Result} object for all HTTP responses and errors.&lt;/li&gt;
 //第三种：如果使用Observable&lt;Result&lt;T&gt;声明接口。所有的Response和Error将会调用onNext方法。
 注意：这个Result是Retrofit提供的。
 * &lt;/ul&gt;
 */
 
</code></pre>
<h2 id="结论">结论</h2>
<p>结论就是，如果我们没有对Response有特殊的需求的话，直接在接口声明处直接声明成Observable<T>是最方便最直观的。</p>
<h2 id="另外">另外</h2>
<p>如果已经存在这样的接口定义了，在没有API可用的情况下，我们需要在mock数据的时候，比如我们需要Observer<LoginResult> 的observable。<br>
我们可以这样mock数据</p>
<pre><code>LoginResult loginResult = new LoginResult();
loginResult.setCode(0);
loginResult.setMessage(&quot;登录成功&quot;);
Observable&lt;LoginResult&gt; just1 = Observable.just(loginResult);
</code></pre>
<p>而如果我们定义的是Observable&lt;Response<LoginResult>&gt; login()时我们需要返回这样的Observable</p>
<pre><code>Response&lt;LoginResponse&gt; loginResponseResponse = Response.success(loginResult);
Observable&lt;Response&lt;LoginResponse&gt;&gt; just2 = Observable.just(loginResponseResponse);	
</code></pre>
<p>这样就可以mock对应的数据了</p>
<p>这篇文章本应该和Retofit源码分析一起写的，奈何Retrofit的源码实在是太晦涩难懂了</p>
]]></content>
    </entry>
</feed>