<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philadelphia.github.io</id>
    <title>philadelphia</title>
    <updated>2019-08-16T10:04:48.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philadelphia.github.io"/>
    <link rel="self" href="https://philadelphia.github.io/atom.xml"/>
    <subtitle>德不孤必有邻</subtitle>
    <logo>https://philadelphia.github.io/images/avatar.png</logo>
    <icon>https://philadelphia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, philadelphia</rights>
    <entry>
        <title type="html"><![CDATA[Java:动态绑定]]></title>
        <id>https://philadelphia.github.io/post/javadong-tai-bang-ding</id>
        <link href="https://philadelphia.github.io/post/javadong-tai-bang-ding">
        </link>
        <updated>2019-08-16T10:03:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="动态绑定">动态绑定</h2>
<p>动态绑定作为Java多态特性的一个重要实现</p>
<p>有一下三个类：</p>
<pre><code class="language-java">public class Fruit {
    public static final String TAG = &quot;Fruit&quot;;

    public Fruit() {
    }

    public void say() {
        Log.i(TAG, &quot;say: i am fruit: &quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Apple  extends  Fruit{

    public void say(){
        Log.i(TAG, &quot;say:  i am apple&quot;);
    }
}
</code></pre>
<pre><code class="language-java">
public class Orange extends Fruit {

    public void say(){
        Log.i(TAG, &quot;say:  i am orange&quot;);
    }
}
</code></pre>
<p>其中Apple和Orange类都继承Fruit类。</p>
<p>然后在使用的时候</p>
<pre><code class="language-java">Fruit fruit = new Apple();
fruit.say();
</code></pre>
<p>我们都知道最后打印的结果是</p>
<pre><code class="language-java">debug I/Fruit: say:  i am apple
</code></pre>
<p>很明显这就是Java多态特性的体现。</p>
<p>我们明明调用的是Fruit对象的方法。但是运行时却调用了Apple对象的方法，这是怎么实现的呢，这就涉及到了Java的动态绑定了，</p>
<p>这里确定两个概念：编译时类型与运行时类型</p>
<p>编译时类型就是指改对象在编译后的文件里的类型也就是改对象声明时的类型，而运行时类型是指在程序运行时动态指定的类型也就是该对象定义时的类型。如果编译时类型与运行时类型不一致就会发生运行时动态绑定</p>
<p>比如上面定义的Fruit fruit = new Apple();</p>
<p>fruit的编译时类型是Fruit。</p>
<p>我们可以从编译后的class文件看出</p>
<pre><code class="language-java">#4 = Class              #243          // com/meiliwu/dragon/model/Apple
#5 = Methodref          #4.#241       // com/meiliwu/dragon/model/Apple.&quot;&lt;init&gt;&quot;:()V
#6 = Methodref          #244.#245     // com/meiliwu/dragon/model/Fruit.say:()V
</code></pre>
<p>我们可以从编译后的文件看出。fruit.say方法在编译后指向的是Fruit的say方法。但是运行时类型是Apple。运行时却是调用Apple的say方法。我们从日志可以看出来。</p>
<p>如果我们将代码改成这样</p>
<pre><code class="language-java">Apple fruit = new Apple();
fruit.say();
</code></pre>
<p>打印日志如下：</p>
<pre><code class="language-Java">12-25 11:25:17.803 9709-9709/com.meiliwu.dragon.debug I/Fruit: say:  i am apple
</code></pre>
<p>我们再看看编译后的文件</p>
<pre><code class="language-java">4 = Class              #243          // com/meiliwu/dragon/model/Apple
#5 = Methodref          #4.#241       // com/meiliwu/dragon/model/Apple.&quot;&lt;init&gt;&quot;:()V
#6 = Methodref          #4.#244       // com/meiliwu/dragon/model/Apple.say:()V
</code></pre>
<p>从代码可以看出编译时类型与运行时类型一致，这是不会发生动态绑定的，这时可以从编译后的class文件得出验证。</p>
<h2 id="java的pecs原则">JAVA的PECS原则</h2>
<p>PECS指“Producer Extends，Consumer Super”</p>
<p>比如：</p>
<pre><code class="language-java">List&lt;? extends Fruit&gt; fruitList = new ArrayList&lt;&gt;();
fruitList.add(new Apple());
fruitList.add(new Orange());
</code></pre>
<p>但是编译器却报了编译错误：</p>
<p>按理说fruitList是一个持有类型为Fruit及其子类的泛型列表啊，为什么不能往其中添加Fruit的子类呢？</p>
<p>因为泛型的一大好处就是可以在编译时检查，避免传入不相符的类型可能导致的ClassCastException了。但是声明fruitList的时候没有明确的指定泛型的具体类型，所以编译器无法确认其持有的具体类型，当然也就拒绝了add操作。</p>
<p>fruitList只是规定了泛型的上限，但是并没有确定具体的类型，也无法确定具体的子类型，可以是Apple，Orange还可能是Banana,所以不能把具体的对象添加进去，不然使用的时候可能导致ClassCastException了。但是可以保证从里面取出来的数据都是Fruit及其子类，而且还是Fruit的某一个子类。</p>
<p>我们把代码改成下面这样子就可以添加不同的Fruit对象了。</p>
<p>因为我们规定了fruitList持有的都是Fruit及其父类，可以将Fruit 及其子类都添加进去</p>
<pre><code class="language-java">List&lt;? super Fruit&gt; fruitList = new ArrayList&lt;&gt;();
fruitList.add(new Apple());
fruitList.add(new Orange());
</code></pre>
<p>但是</p>
<pre><code class="language-Java">fruitList.add(new Object());
</code></pre>
<p>却不行，why?因为在编译时无法确认具体的fruitList持有的是Fruit的哪一个父类，要想确定就不能用泛型了。所以就无法往里面写入Fruit的父类型对象。</p>
<p>所以我们可以从Java Collctions copy方法的签名可以看出</p>
<pre><code class="language-Java">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
</code></pre>
<p>dest集合持有？super T ，可以往里面写入所有T及其子类对象，而src集合持有？ extends T泛型。可以确保的是从里面读取的数据都是T及其子类。所以可以写入dest了。</p>
<p>PS:Java 类的final方法和static不能复写</p>
<h2 id="reference">Reference</h2>
<p>1：https://www.cnblogs.com/ygj0930/p/6554103.html</p>
<p>2:  http://www.importnew.com/8966.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android中Activity数据的保存和恢复 ]]></title>
        <id>https://philadelphia.github.io/post/android-zhong-activity-shu-ju-de-bao-cun-he-hui-fu</id>
        <link href="https://philadelphia.github.io/post/android-zhong-activity-shu-ju-de-bao-cun-he-hui-fu">
        </link>
        <updated>2019-08-16T10:03:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android中activity数据的保存和恢复">Android中Activity数据的保存和恢复</h1>
<p>在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。</p>
<p>突发情况都有哪些？</p>
<p>因为本文讨论的是当一些突发情况的出现时，对数据的保存和恢复。所以现在总结一下突发情况应该都有哪些？</p>
<pre><code>1. 点击back键
2. 点击锁屏键
3. 点击home键
4. 其他APP进入前台
5. 启动了另一个Activity
6. 屏幕方向旋转
7. APP被Kill
</code></pre>
<h2 id=""></h2>
<p>现在我们创建一个Activity并复写其中的关键方法：<br>
​	<br>
package com.example.activitytest;</p>
<pre><code>	import android.content.Intent;
	import android.os.Bundle;
	import android.support.v7.app.AppCompatActivity;
	import android.util.Log;
	import android.widget.Button;
	
	import butterknife.BindView;
	import butterknife.ButterKnife;
	import butterknife.OnClick;
	
	public class MainActivity extends AppCompatActivity {
</code></pre>
<p>​	<br>
@BindView(R.id.btn_secondActivity)<br>
Button btnSecondActivity;<br>
private static final String TAG = &quot;MainActivity&quot;;</p>
<pre><code>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.i(TAG, &quot;onCreate: &quot;);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        Log.i(TAG, &quot;onRestart: &quot;);
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.i(TAG, &quot;onStart: &quot;);
    }

    @Override
    protected void onResume() {
        Log.i(TAG, &quot;onResume: &quot;);
        super.onResume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.i(TAG, &quot;onPause: &quot;);
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i(TAG, &quot;onStop: &quot;);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i(TAG, &quot;onDestroy: &quot;);
    }

    @OnClick(R.id.btn_secondActivity)
    public void onViewClicked() {
        startActivity(new Intent(MainActivity.this, SecondActivity.class));
    }
</code></pre>
<p>​	<br>
@Override<br>
protected void onSaveInstanceState(Bundle outState) {<br>
Log.i(TAG, &quot;onSaveInstanceState: &quot;);<br>
super.onSaveInstanceState(outState);<br>
}</p>
<pre><code>    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        Log.i(TAG, &quot;onRestoreInstanceState: &quot;);
    }

}
</code></pre>
<p>来看看各种情况下，Activity会调用哪些方法。</p>
<ol>
<li>
<p>点击back键</p>
<pre><code>09-26 16:00:02.124 21636-21636/com.example.activitytest I/MainActivity: onPause: 

09-26 16:00:02.575 21636-21636/com.example.activitytest I/MainActivity: onStop: 
09-26 16:00:02.575 21636-21636/com.example.activitytest I/MainActivity: onDestroy: 
</code></pre>
</li>
<li>
<p>点击锁屏键<br>
​	<br>
09-26 16:02:14.453 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:02:14.497 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:02:14.498 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>点击home键<br>
​	<br>
09-26 16:02:54.239 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:02:54.306 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
09-26 16:02:54.355 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>其他APP进入前台<br>
​	<br>
09-26 16:04:02.658 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>启动了另一个Activity</p>
<p>09-26 16:04:02.658 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>屏幕方向旋转</p>
<p>​</p>
<pre><code class="language-java">09-26 16:04:51.199 21636-21636/com.example.activitytest I/MainActivity: onPause: 
09-26 16:04:51.199 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState: 
09-26 16:04:51.201 21636-21636/com.example.activitytest I/MainActivity: onStop: 
09-26 16:04:51.201 21636-21636/com.example.activitytest I/MainActivity: onDestroy: 
09-26 16:04:51.220 21636-21636/com.example.activitytest I/MainActivity: onCreate: 
09-26 16:04:51.250 21636-21636/com.example.activitytest I/MainActivity: onStart: 
09-26 16:04:51.250 21636-21636/com.example.activitytest I/MainActivity: 
</code></pre>
<p>onRestoreInstanceState:<br>
​	09-26 16:04:51.252 21636-21636/com.example.activitytest I/MainActivity: onResume:</p>
</li>
<li>
<p>APP被Kill<br>
​	<br>
09-26 16:05:17.544 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:05:17.601 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:05:17.611 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
</ol>
<p>当APP处在前台，能与用户交互的情况下，出现上述的突发事件时，只有点击back键，onSaveInstanceState方法不会调用。其余的情况下， 该方法一律都会调用，并且onPause方法是必然会调用的.<br>
我们可以看一下onSaveInstanceState()方法的注释<br>
​	<br>
/**<br>
* Called to retrieve per-instance state from an activity before being killed<br>
* so that the state can be restored in {@link #onCreate} or<br>
* {@link #onRestoreInstanceState} (the {@link Bundle} populated by this method<br>
* will be passed to both).<br>
*<br>
* <p>This method is called before an activity may be killed so that when it<br>
* comes back some time in the future it can restore its state.  For example,<br>
* if activity B is launched in front of activity A, and at some point activity<br>
* A is killed to reclaim resources, activity A will have a chance to save the<br>
* current state of its user interface via this method so that when the user<br>
* returns to activity A, the state of the user interface can be restored<br>
* via {@link #onCreate} or {@link #onRestoreInstanceState}.<br>
*<br>
* <p>Do not confuse this method with activity lifecycle callbacks such as<br>
* {@link #onPause}, which is always called when an activity is being placed<br>
* in the background or on its way to destruction, or {@link #onStop} which<br>
* is called before destruction.  One example of when {@link #onPause} and<br>
* {@link #onStop} is called and not this method is when a user navigates back<br>
* from activity B to activity A: there is no need to call {@link #onSaveInstanceState}<br>
* on B because that particular instance will never be restored, so the<br>
* system avoids calling it.  An example when {@link #onPause} is called and<br>
* not {@link #onSaveInstanceState} is when activity B is launched in front of activity A:<br>
* the system may avoid calling {@link #onSaveInstanceState} on activity A if it isn't<br>
* killed during the lifetime of B since the state of the user interface of<br>
* A will stay intact.<br>
*<br>
* <p>The default implementation takes care of most of the UI per-instance<br>
* state for you by calling {@link android.view.View#onSaveInstanceState()} on each<br>
* view in the hierarchy that has an id, and by saving the id of the currently<br>
* focused view (all of which is restored by the default implementation of<br>
* {@link #onRestoreInstanceState}).  If you override this method to save additional<br>
* information not captured by each individual view, you will likely want to<br>
* call through to the default implementation, otherwise be prepared to save<br>
* all of the state of each view yourself.<br>
*<br>
* <p>If called, this method will occur before {@link #onStop}.  There are<br>
* no guarantees about whether it will occur before or after {@link #onPause}.<br>
*<br>
* @param outState Bundle in which to place your saved state.<br>
* 这个方法在Activity被Killed之前调用去保存Activity的每个实体的状态，所以状态可以在<code>onCreat 	 * 或者</code>onRestoreInstanceState<code>被恢复。通过这个方法传递过去的</code>Bundle<code>* 这个方法在一个Activity被killed之前调用，所以当它将来恢复时可以恢复它的状态。比如：如果Activity B 	 * 在Acitivity A之前入站。如果在某一时刻A被销毁去释放资源，那么A将有机会调用该方法去保存它的用户UI的状态。 	 * 因此，当用户返回A时。用户状态可以被恢复。 	 * 不要将这个方法和Activity的生命周期回掉比如</code>onPause<code>，</code>onPause<code>在Activity被取代或者销毁时调用。</code>onStop<code>在被销毁之前 	 * 调用。一个</code>onPause<code>和</code>onStop<code>被调用但是</code>onSaveInstanceState<code>没被调用的情况是当用户从B回退到A时。不需要调用B的 	 *</code>onSaveInstanceState<code>* 一个</code>onPause<code>被调用但是</code>onSaveInstanceState<code>没被Blaunch 在A的上面时。系统避免调用A的</code>onSaveInstanceState<code>* 如果A在B的生命周期内没有被销毁。所以A的用户状态将保持不变。 	 * 可以通过给View设置ID。可以自动保存每个View的状态。 	 * 如果这个方法被调用了。这个方法将在</code>onStop<code>之前调用。但是不保证和</code>onPause`的调用顺序。<br>
*</p>
<p>google工程师们对onSaveInstanceState如此设计就是让其完成对一些临时的、非永久数据存储并进行恢复。但是一些永久性质的数据，比如插入数据库的操作，我们应该在什么方法中对其进行保存呢？</p>
<pre><code>onPause
onPuase的解释是：onPause(), onStop(), onDestroy() are &quot;killable after&quot; lifecycle methods. This indicates whether or not the system can kill the process hosting the activity at any time after the method returns, without executing another line of the activity's code. Because onPause() is the first of the three, once the activity is created, onPause() is the last method that's guaranteed to be called before the process can be killed—if the system must recover memory in an emergency, then onStop() and onDestroy() might not be called. Therefore, you should use onPause() to write crucial persistent data (such as user edits) to storage. However, you should be selective about what information must be retained during onPause(), because any blocking procedures in this method block the transition to the next activity and slow the user experience.
</code></pre>
<p>翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得onPause是持久化相关数据的最后的可靠时机。当然onPause方法不能做大量的操作，这会影响下一个Activity入栈</p>
<p>最后	我们来一句话总结一下：</p>
<h2 id="临时数据使用onsaveinstancestate保存恢复永久性数据使用onpause方法保存">临时数据使用onSaveInstanceState保存恢复，永久性数据使用onPause方法保存。</h2>
<p>参考：</p>
<p>1.<a href="http://www.jianshu.com/p/6622434511f7" title="http://www.jianshu.com/p/6622434511f7">http://www.jianshu.com/p/6622434511f7</a></p>
<p>2.<a href="http://blog.csdn.net/lonelyroamer/article/details/8927940" title="http://blog.csdn.net/lonelyroamer/article/details/8927940">http://blog.csdn.net/lonelyroamer/article/details/8927940</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Android 系统的事件分发机制分析 ]]></title>
        <id>https://philadelphia.github.io/post/android-xi-tong-de-shi-jian-fen-fa-ji-zhi-fen-xi</id>
        <link href="https://philadelphia.github.io/post/android-xi-tong-de-shi-jian-fen-fa-ji-zhi-fen-xi">
        </link>
        <updated>2019-08-16T10:02:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-系统的事件分发机制分析">Android 系统的事件分发机制分析</h1>
<p>Android中可以相应事件的控件有View和ViewGroup。其实ViewGroup也是一种View。只不过大部分情况下ViewGroup作为一种View容器来使用了。<br>
View中有三个关键的方法</p>
<pre><code>1. public boolean dispatchTouchEvent(MotionEvent event)		//事件分发的方法
2. public boolean onTouchEvent(MotionEvent event)			//事件处理的方法
</code></pre>
<p>ViewGroup中多了以下方法</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev)		//事件拦截的方法
</code></pre>
<p>Android中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的</p>
<p>当你点击了某个控件(touch事件发生)，首先会去调用该控件所在布局(ViewGroup)的dispatchTouchEvent方法，然后在布局的</p>
<p>dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {  
final int action = ev.getAction();  
final float xf = ev.getX();  
final float yf = ev.getY();  
final float scrolledXFloat = xf + mScrollX;  
final float scrolledYFloat = yf + mScrollY;  
final Rect frame = mTempRect;  
boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  
if (action == MotionEvent.ACTION_DOWN) {  
    if (mMotionTarget != null) {  
        mMotionTarget = null;  
    }  
    if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
        ev.setAction(MotionEvent.ACTION_DOWN);  
        final int scrolledXInt = (int) scrolledXFloat;  
        final int scrolledYInt = (int) scrolledYFloat;  
        final View[] children = mChildren;  
        final int count = mChildrenCount;  
        for (int i = count - 1; i &gt;= 0; i--) {  
            final View child = children[i];  
            if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  
                    || child.getAnimation() != null) {  
                child.getHitRect(frame);  
                if (frame.contains(scrolledXInt, scrolledYInt)) {  
                    final float xc = scrolledXFloat - child.mLeft;  
                    final float yc = scrolledYFloat - child.mTop;  
                    ev.setLocation(xc, yc);  
                    child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
                    if (child.dispatchTouchEvent(ev))  {  
                        mMotionTarget = child;  
                        return true;  
                    }  
                }  
            }  
        }  
    }  
}  
boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
        (action == MotionEvent.ACTION_CANCEL);  
if (isUpOrCancel) {  
    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  
}  
final View target = mMotionTarget;  
if (target == null) {  
    ev.setLocation(xf, yf);  
    if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
        ev.setAction(MotionEvent.ACTION_CANCEL);  
        mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
    }  
    return super.dispatchTouchEvent(ev);  
}  
if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {  
    final float xc = scrolledXFloat - (float) target.mLeft;  
    final float yc = scrolledYFloat - (float) target.mTop;  
    mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
    ev.setAction(MotionEvent.ACTION_CANCEL);  
    ev.setLocation(xc, yc);  
    if (!target.dispatchTouchEvent(ev)) {  
    }  
    mMotionTarget = null;  
    return true;  
}  
if (isUpOrCancel) {  
    mMotionTarget = null;  
}  
final float xc = scrolledXFloat - (float) target.mLeft;  
final float yc = scrolledYFloat - (float) target.mTop;  
ev.setLocation(xc, yc);  
if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
    ev.setAction(MotionEvent.ACTION_CANCEL);  
    target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
    mMotionTarget = null;  
}  
return target.dispatchTouchEvent(ev);  
}  
</code></pre>
<p>从上面的代码可以看出。如果viewgroup的disallowIntercept属性为false(默认是false，也可以通过requestDisallowInterceptTouchEvent方法对这个值进行修改)，或者onInterceptTouchEvent(ev)返回了true，那ViewGroup的<br>
dispatchTouchEvent()方法也会返回false，事件就不会往下分发了，如果ViewGroup禁用了拦截机制(disallowIntercept=true)或者没有拦截事件(返回false)，事件就会分发给ViewGroup中的 子view了。然后子view开始处理事件了。</p>
<p><img src="http://img.blog.csdn.net/20130629200236578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>从图中可以看出当ViewGroup分发事件的时候先调用自己的拦截方法，如果拦截方法返回了true，那么事件就不在向下传递给view了。然后ViewGroup就开始自己处理事件了。如果ViewGroup拦截方法返回了false，那么事件就会向下传递给view，然后view开始调用自己的分发方法，然后调用自己的事件处理方法。</p>
<h2 id="总结">总结</h2>
<p>如果View设置了<code>setOnTouchListener()</code>方法和<code>setOnLongClick()</code>和 <code>setOnClickListener()</code>方法，那默认情况下onTouch方法会先于<br>
<code>onClick()</code>, <code>onLongClick()</code>方法调用。</p>
<pre><code>  button.setOnTouchListener(new View.OnTouchListener() {
        @Override
        public boolean onTouch(View v, MotionEvent event) {
            Log.i(TAG, &quot;button------onTouch: &quot; + event.getAction());
            return false;
        }
    });


button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.i(TAG, &quot;button --- onClick: &quot;);
        }
    });


09-15 14:08:15.184 27948-27948/com.example.drawerlayoutdemo I/MainActivity: button------onTouch: 0(Down)
09-15 14:08:15.254 27948-27948/com.example.drawerlayoutdemo I/MainActivity: button------onTouch: 1(Up)
09-15 14:08:15.273 27948-27948/com.example.drawerlayoutdemo I/MainActivity: button --- onClick:(onClick)
</code></pre>
<hr>
<p>view的<code>dispatchTouchEvent</code>方法（精简后代码）。</p>
<pre><code>	public boolean dispatchTouchEvent(MotionEvent event) {
    ...
    boolean result = false;	// result 为返回值，主要作用是告诉调用者事件是否已经被消费。
    if (onFilterTouchEventForSecurity(event)) {
        ListenerInfo li = mListenerInfo;
        /** 
         * 如果设置了OnTouchListener，并且当前 View 可点击，就调用监听器的 onTouch 方法，
         * 如果 onTouch 方法返回值为 true，就设置 result 为 true。
         */
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
      
        /** 
         * 如果 result 为 false，则调用自身的 onTouchEvent。
         * 如果 onTouchEvent 返回值为 true，则设置 result 为 true。
         */
        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }
    ...
    return result;
}	
</code></pre>
<p>可以看出如果设置了<code>onTouchListener</code>的话。优先调用<code>onTouchListener</code>的<code>onTouch()</code>方法。<br>
但是如果在OnTouch方法里面返回true的话，就代表消费了事件，该事件不在往下分发，所以View的 <code>onClick</code>，<code>onLongClick</code> 方法就不会被调用了。因为<code>onClick()</code>and <code>onLongClick（）</code>是在view的<code>onTouchevent()</code>方法中调用的。<br>
如果<code>onTouchListener</code>的<code>onTouch()</code>返回false的话。才会调用view的<code>onTouchEvent(event)</code>方法。</p>
<pre><code>	public boolean onTouchEvent(MotionEvent event) {
    ...
    final int action = event.getAction();
  	// 检查各种 clickable
    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                ...
                removeLongPressCallback();  // 移除长按
                ...
                performClick();             // 检查单击
                ...
                break;
            case MotionEvent.ACTION_DOWN:
                ...
                checkForLongClick(0);       // 检测长按
                ...
                break;
            ...
        }
        return true;                        // ◀︎表示事件被消费
    }
    return false;
}
</code></pre>
<p>从View的<code>onTouchevent（）</code>方法中可以看出。<br>
如果view设置了<code>clickable</code>,<code>longClickable</code>，<code>contextClickable</code>属性中的任何一个。<br>
或者设置了 <code>onClickListener</code>，<code>onLongClickListener</code>，<code>onContextClickListener</code>中的任何一个<br>
那个该view就会消费事件。不然不消费事件。，</p>
<p>从<code>dispatchTouchEvent</code> 和<code>onTouchEvent()</code>方法可以看出。</p>
<p>1	事件的调度顺序为：<br>
onTouchListener &gt; onTouchEvent &gt; onLongClickListener &gt; onClickListener</p>
<p>2: 如果View为Disabled。则：<code>OntouchListener</code>里面的方法不会执行。但是会执行<code>OnTouchEvent(event)</code>方法，也就是说即使view是disabled的，依然可以相应onClick事件。</p>
<p>3： onTouchEvent方法中的ACTION_UP分支中触发onClick方法。并在这里移除长按监听。因为长按不需要处理ACTION_UP事件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# Android 中内部存储和外部存储分析 #]]></title>
        <id>https://philadelphia.github.io/post/android-zhong-nei-bu-cun-chu-he-wai-bu-cun-chu-fen-xi</id>
        <link href="https://philadelphia.github.io/post/android-zhong-nei-bu-cun-chu-he-wai-bu-cun-chu-fen-xi">
        </link>
        <updated>2019-08-16T10:02:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-中内部存储和外部存储分析">Android 中内部存储和外部存储分析</h1>
<p>Android系统存储相关有这样几个概念，内存，内部存储，外部存储</p>
<p>内存，RAM ，在移动设备中做系统运行用</p>
<pre><code>随机存储器，Read Access Memory
</code></pre>
<p>存储器， ROM，在移动设备中做数据存储用</p>
<pre><code>只读存储器，Read Only Memory
</code></pre>
<blockquote>
<p>内部存储 <code>InternalStorage</code></p>
<p>外部存储<br>
<code>ExternalStorage</code></p>
</blockquote>
<p>Android 系统自身自带有存储，另外也可以通过 SD 卡来扩充存储空间。 前者空间较小，后者空间大，但后者不一定可用。 开发应用，处理本地数据存取时，可能会遇到这些问题：</p>
<blockquote>
<ol>
<li>需要判断 SD 卡是否可用: 占用过多机身内部存储，容易招致用户反感，优先将数据存放于 SD 卡;</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>应用数据存放路径，同其他应用应该保持一致，应用卸载时，清除数据:</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>标新立异在 SD 卡根目录建一个目录，招致用户反感</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>用户卸载应用后，残留目录或者数据在用户机器上，招致用户反感</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>需要判断两者的可用空间: SD 卡存在时，可用空间反而小于机身内部存储，这时应该选用机身存储;</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li>数据安全性，本应用数据不愿意被其他应用读写;</li>
</ol>
</blockquote>
<blockquote>
<ol start="7">
<li>图片缓存等，不应该被扫描加入到用户相册等媒体库中去。</li>
</ol>
</blockquote>
<p>那么究竟什么是内部存储什么是外部存储呢？<br>
首先我们打开DDMS，有一个File Explorer，如下：<br>
<img src="http://img.blog.csdn.net/20151211224232123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>
这里有三个文件夹需要我们重视，一个是data，一个是mnt，一个是storage，我们下面就详细说说这三个文件夹。</p>
<h2 id="1内部存储">1.内部存储</h2>
<p>data文件夹就是我们常说的内部存储，当我们打开data文件夹之后（没有root的手机不能打开该文件夹），里边有两个文件夹值得我们关注，如下：<br>
<img src="http://img.blog.csdn.net/20151211224609474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>一个文件夹是app文件夹，还有一个文件夹就是data文件夹，app文件夹里存放着我们所有安装的app的apk文件，其实，当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading .....就是上传我们的apk到这个文件夹，上传成功之后才开始安装。另一个重要的文件夹就是data文件夹了，这个文件夹里边都是一些包名，打开这些包名之后我们会看到这样的一些文件：</p>
<pre><code>1.data/data/包名/shared_prefs
2.data/data/包名/databases
3.data/data/包名/files
4.data/data/包名/cache
</code></pre>
<p>如果打开过data文件，应该都知道这些文件夹是干什么用的，我们在使用sharedPreferenced的时候，将数据持久化存储于本地，其实就是存在这个文件中的xml文件里，我们App里边的数据库文件就存储于databases文件夹中，还有我们的普通数据存储在files中，缓存文件存储在cache文件夹中，存储在这里的文件我们都称之为内部存储。</p>
<h2 id="2外部存储">2.外部存储</h2>
<p>外部存储才是我们平时操作最多的，外部存储一般就是我们上面看到的storage文件夹，当然也有可能是mnt文件夹，这个不同厂家有可能不一样。<br>
一般来说，在storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，还有一类是私有目录，其中的公有目录有九大类，比如<code>DCIM</code>、<code>MUSIC</code>、<code>Ringtons</code>、<code>Pictures</code>、<code>Alarms</code>,<code>Movies</code>、<code>Documents</code>、<code>Notifications</code>等这种系统为我们创建的文件夹，私有目录就是<code>Android</code>这个文件夹，这个文件夹打开之后里边有两个文件夹：<code>data</code>，<code>media</code>，打开这个data文件夹，里边有许多包名组成的文件夹。每个包文件夹下又包含两个文件夹：<code>cache</code> 和<code>files</code></p>
<pre><code>	DIRECTORY_MUSIC,
    DIRECTORY_PODCASTS,
    DIRECTORY_RINGTONES,
    DIRECTORY_ALARMS,
    DIRECTORY_NOTIFICATIONS,
    DIRECTORY_PICTURES,
    DIRECTORY_MOVIES,
    DIRECTORY_DOWNLOADS,
    DIRECTORY_DCIM,
    DIRECTORY_DOCUMENTS
</code></pre>
<p>以上全都是Environment类中定义的静态变量</p>
<h2 id="3操作存储空间">3.操作存储空间</h2>
<p>首先，经过上面的分析，大家已经明白了，什么是内部存储，什么是外部存储，以及这两种存储方式分别存储在什么位置，一般来说，我们不会自己去操作内部存储空间，没有root权限的话，我们也没法操作内部存储空间，事实上内部存储主要是由系统来维护的。不过在代码中我们是可以访问到这个文件夹的。由于内部存储空间有限，在开发中我们一般都是操作外部存储空间，Google官方建议我们App的数据应该存储在外部存储的私有目录中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除，如果你直接在/storage/sdcard目录下创建了一个应用的文件夹，那么当你删除应用的时候，这个文件夹就不会被删除。<br>
经过以上的介绍，我们可以总结出下面一个表格：<br>
<img src="http://img.blog.csdn.net/20151212091841385?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>一目了然，什么是内部存储，什么是外部存储。<br>
如果按照路径的特征，我们又可以将文件存储的路径分为两大类，一类是路径中含有包名的，一类是路径中不含有包名的，含有包名的路径，因为和某个App有关，所以对这些文件夹的访问都是调用Context里边的方法，而不含有包名的路径，和某一个App无关，我们可以通过Environment中的方法来访问。如下图：<br>
<img src="http://img.blog.csdn.net/20151212094211922?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>大家看到，有包名的路径我们都是调用Context中的方法来获得，没有包名的路径，我们直接调用Environment中的方法获得，那么其中有两个方法需要传入一个String类型的参数，这个参数我们使用了Environment中的常量，参数的意思是我们要访问这个路径下的哪个文件夹，比如getExternalFilesDir方法，我们看看它的源码：</p>
<pre><code>/** 
 * 
 * @param type The type of files directory to return.  May be null for 
 * the root of the files directory or one of 
 * the following Environment constants for a subdirectory: 
 * {@link android.os.Environment#DIRECTORY_MUSIC}, 
 * {@link android.os.Environment#DIRECTORY_PODCASTS}, 
 * {@link android.os.Environment#DIRECTORY_RINGTONES}, 
 * {@link android.os.Environment#DIRECTORY_ALARMS}, 
 * {@link android.os.Environment#DIRECTORY_NOTIFICATIONS}, 
 * {@link android.os.Environment#DIRECTORY_PICTURES}, or 
 * {@link android.os.Environment#DIRECTORY_MOVIES}. 
 * 
 * @return The path of the directory holding application files 
 * on external storage.  Returns null if external storage is not currently 
 * mounted so it could not ensure the path exists; you will need to call 
 * this method again when it is available. 
 * 
 * @see #getFilesDir 
 * @see android.os.Environment#getExternalStoragePublicDirectory 
 */  
@Nullable  
public abstract File getExternalFilesDir(@Nullable String type);  
</code></pre>
<p>它的注释非常多，我这里只列出其中一部分，我们看到，我们可以访问files文件夹下的Music文件夹、Movies文件夹等等好几种。<br>
说到这里，我想大家对内部存储、外部存储该有了一个清晰的认识了吧。我们在开发中，<strong>不建议往内部存储中写太多的数据，毕竟空间有限。外部存储在使用的时候最好能够将文件存放在私有目录下，这样有利于系统维护，也避免用户的反感</strong>。<br>
现在我们再来看看我们一开始提出的问题，当我们点击清除数据的时候清除的是哪里的数据呢？毫无疑问，当然是内部存储目录中相应的files和cache文件夹中的文件和外部存储中相应的files和cache文件夹中的文件，至于这些文件夹的路径我想你应该已经明白了。<br>
好了，最后再送给大家一个文件操作工具类：</p>
<pre><code>public class SDCardHelper {  

    // 判断SD卡是否被挂载  
    public static boolean isSDCardMounted() {  
        // return Environment.getExternalStorageState().equals(&quot;mounted&quot;);  
        return Environment.getExternalStorageState().equals(  
                Environment.MEDIA_MOUNTED);  
}  

    // 获取SD卡的根目录  
    public static String getSDCardBaseDir() {  
        if (isSDCardMounted()) {  
            return Environment.getExternalStorageDirectory().getAbsolutePath();  
        }  
        return null;  
    }  
  
    // 获取SD卡的完整空间大小，返回MB  
    public static long getSDCardSize() {  
        if (isSDCardMounted()) {  
            StatFs fs = new StatFs(getSDCardBaseDir());  
            long count = fs.getBlockCountLong();  
            long size = fs.getBlockSizeLong();  
            return count * size / 1024 / 1024;  
        }  
        return 0;  
    }  
  
    // 获取SD卡的剩余空间大小  
    public static long getSDCardFreeSize() {  
        if (isSDCardMounted()) {  
            StatFs fs = new StatFs(getSDCardBaseDir());  
            long count = fs.getFreeBlocksLong();  
            long size = fs.getBlockSizeLong();  
            return count * size / 1024 / 1024;  
        }  
        return 0;  
    }  
  
    // 获取SD卡的可用空间大小  
    public static long getSDCardAvailableSize() {  
        if (isSDCardMounted()) {  
            StatFs fs = new StatFs(getSDCardBaseDir());  
            long count = fs.getAvailableBlocksLong();  
            long size = fs.getBlockSizeLong();  
            return count * size / 1024 / 1024;  
        }  
        return 0;  
    }  
  
    // 往SD卡的公有目录下保存文件  
    public static boolean saveFileToSDCardPublicDir(byte[] data, String type,  
            String fileName) {  
        BufferedOutputStream bos = null;  
        if (isSDCardMounted()) {  
            File file = Environment.getExternalStoragePublicDirectory(type);  
            try {  
                bos = new BufferedOutputStream(new FileOutputStream(new File(  
                        file, fileName)));  
                bos.write(data);  
                bos.flush();  
                return true;  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                try {  
                    bos.close();  
                } catch (IOException e) {  
                    // TODO Auto-generated catch block  
                    e.printStackTrace();  
                }  
            }  
        }  
        return false;  
    }  
  
    // 往SD卡的自定义目录下保存文件  
    public static boolean saveFileToSDCardCustomDir(byte[] data, String dir,  
            String fileName) {  
        BufferedOutputStream bos = null;  
        if (isSDCardMounted()) {  
            File file = new File(getSDCardBaseDir() + File.separator + dir);  
            if (!file.exists()) {  
                file.mkdirs();// 递归创建自定义目录  
            }  
            try {  
                bos = new BufferedOutputStream(new FileOutputStream(new File(  
                        file, fileName)));  
                bos.write(data);  
                bos.flush();  
                return true;  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                try {  
                    bos.close();  
                } catch (IOException e) {  
                    // TODO Auto-generated catch block  
                    e.printStackTrace();  
                }  
            }  
        }  
        return false;  
    }  
  
    // 往SD卡的私有Files目录下保存文件  
    public static boolean saveFileToSDCardPrivateFilesDir(byte[] data,  
            String type, String fileName, Context context) {  
        BufferedOutputStream bos = null;  
        if (isSDCardMounted()) {  
            File file = context.getExternalFilesDir(type);  
            try {  
                bos = new BufferedOutputStream(new FileOutputStream(new File(  
                        file, fileName)));  
                bos.write(data);  
                bos.flush();  
                return true;  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                try {  
                    bos.close();  
                } catch (IOException e) {  
                    // TODO Auto-generated catch block  
                    e.printStackTrace();  
                }  
            }  
        }  
    return false;  
    }  
  
    // 往SD卡的私有Cache目录下保存文件  
    public static boolean saveFileToSDCardPrivateCacheDir(byte[] data,  
            String fileName, Context context) {  
        BufferedOutputStream bos = null;  
        if (isSDCardMounted()) {  
            File file = context.getExternalCacheDir();  
            try {  
                bos = new BufferedOutputStream(new FileOutputStream(new File(  
                        file, fileName)));  
                bos.write(data);  
                bos.flush();  
                return true;  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                try {  
                    bos.close();  
                } catch (IOException e) {  
                    // TODO Auto-generated catch block  
                    e.printStackTrace();  
                }  
            }  
        }  
        return false;  
    }  
  
    // 保存bitmap图片到SDCard的私有Cache目录  
    public static boolean saveBitmapToSDCardPrivateCacheDir(Bitmap bitmap,  
            String fileName, Context context) {  
        if (isSDCardMounted()) {  
            BufferedOutputStream bos = null;  
            // 获取私有的Cache缓存目录  
            File file = context.getExternalCacheDir();  
  
            try {  
                bos = new BufferedOutputStream(new FileOutputStream(new File(  
                        file, fileName)));  
                if (fileName != null  
                        &amp;&amp; (fileName.contains(&quot;.png&quot;) || fileName  
                                .contains(&quot;.PNG&quot;))) {  
                    bitmap.compress(Bitmap.CompressFormat.PNG, 100, bos);  
                } else {  
                    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos);  
                }  
                bos.flush();  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                if (bos != null) {  
                    try {  
                        bos.close();  
                    } catch (IOException e) {  
                        e.printStackTrace();  
                    }  
                }  
            }  
            return true;  
        } else {  
            return false;  
        }  
    }  
  
    // 从SD卡获取文件  
    public static byte[] loadFileFromSDCard(String fileDir) {  
        BufferedInputStream bis = null;  
        ByteArrayOutputStream baos = new ByteArrayOutputStream();  
  
        try {  
            bis = new BufferedInputStream(  
                    new FileInputStream(new File(fileDir)));  
            byte[] buffer = new byte[8 * 1024];  
            int c = 0;  
            while ((c = bis.read(buffer)) != -1) {  
                baos.write(buffer, 0, c);  
                baos.flush();  
            }  
            return baos.toByteArray();  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            try {  
                baos.close();  
                bis.close();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
        return null;  
    }  
  
    // 从SDCard中寻找指定目录下的文件，返回Bitmap  
    public Bitmap loadBitmapFromSDCard(String filePath) {  
        byte[] data = loadFileFromSDCard(filePath);  
        if (data != null) {  
            Bitmap bm = BitmapFactory.decodeByteArray(data, 0, data.length);  
            if (bm != null) {  
                return bm;  
            }  
        }  
        return null;  
    }  
  
    // 获取SD卡公有目录的路径  
    public static String getSDCardPublicDir(String type) {  
        return Environment.getExternalStoragePublicDirectory(type).toString();  
    }  
  
    // 获取SD卡私有Cache目录的路径  
    public static String getSDCardPrivateCacheDir(Context context) {  
        return context.getExternalCacheDir().getAbsolutePath();  
    }  
  
    // 获取SD卡私有Files目录的路径  
    public static String getSDCardPrivateFilesDir(Context context, String type) {  
        return context.getExternalFilesDir(type).getAbsolutePath();  
    }  
  
    public static boolean isFileExist(String filePath) {  
        File file = new File(filePath);  
        return file.isFile();  
    }  
  
    // 从sdcard中删除文件  
    public static boolean removeFileFromSDCard(String filePath) {  
        File file = new File(filePath);  
        if (file.exists()) {  
            try {  
                file.delete();  
                return true;  
            } catch (Exception e) {  
                return false;  
            }  
        } else {  
            return false;  
        }  
    }  
}  
</code></pre>
<p>copy自：</p>
<p><a href="http://blog.csdn.net/u012702547/article/details/50269639">http://blog.csdn.net/u012702547/article/details/50269639</a></p>
<p><a href="https://www.liaohuqiu.net/cn/posts/storage-in-android/">https://www.liaohuqiu.net/cn/posts/storage-in-android/</a></p>
<p>Ths</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android:View Inflation 分析]]></title>
        <id>https://philadelphia.github.io/post/androidview-inflation-fen-xi</id>
        <link href="https://philadelphia.github.io/post/androidview-inflation-fen-xi">
        </link>
        <updated>2019-08-16T09:41:45.000Z</updated>
        <content type="html"><![CDATA[<p>LayoutInflater 使用说明</p>
<p>LayoutInflater主要是用于加载布局。<br>
加载布局的任务通常都是在Activity中调用setContentView()方法来完成的。其实setContentView()方法的内部也是使用LayoutInflater来加载布局的，只不过这部分源码是internal的，不太容易查看到。</p>
<p>先来看一下LayoutInflater的基本用法吧，它的用法非常简单，首先需要获取到LayoutInflater的实例，有两种方法可以获取到，第一种写法如下：</p>
<pre><code>LayoutInflater layoutInflater = LayoutInflater.from(context);  
</code></pre>
<p>当然，还有另外一种写法也可以完成同样的效果：</p>
<pre><code>LayoutInflater layoutInflater = (LayoutInflater) context  
    .getSystemService(Context.LAYOUT_INFLATER_SERVICE);  
</code></pre>
<p>其实第一种就是第二种的简单写法，只是Android给我们做了一下封装而已。代码如下：</p>
<pre><code> public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre>
<p>得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了，如下所示：</p>
<pre><code>layoutInflater.inflate(resourceId, root);  
</code></pre>
<p>inflate()方法一般接收两个参数，第一个参数就是要加载的布局资源文件id，第二个参数是指给该布局的外部再嵌套一层父布局，如果不需要就直接传null。这样就成功成功创建了一个布局的实例，之后再将它添加到指定的位置就可以显示出来了。</p>
<p>其实它是调用一个三个参数的重载方法来实现的。<br>
代码实现：</p>
<pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
    return inflate(resource, root, root != null);
}
</code></pre>
<p>该三个参数的方法的实现为：</p>
<p>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {<br>
return inflate(resource, root, root != null);<br>
}</p>
<p>也就是说不管你是使用的哪个inflate()方法的重载，最终都会辗转调用到LayoutInflater的如下代码中</p>
<p>三个参数的方法的实现为：</p>
<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                    type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }

            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription()
                        + &quot;: No start tag found!&quot;);
            }

            final String name = parser.getName();

            if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot;
                        + name);
                System.out.println(&quot;**************************&quot;);
            }

		//如果开始IDE标签名是Merge，则会将布局文件中的view依次加入到root视图中。
            if (TAG_MERGE.equals(name)) {
				//如果开始IDE标签名是Merge,如果attachToRoot 为false，会报错
                if (root == null || !attachToRoot) {
                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;
                            + &quot;ViewGroup root and attachToRoot=true&quot;);
                }

			//遍历parser。将view依次加入到root中、
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
				//如果开始标签不是merge。则temp就是该布局的根视图。
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;

                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; +
                                root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // We are supposed to attach all the views we found (int temp)
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }

        } catch (XmlPullParserException e) {
            final InflateException ie = new InflateException(e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } catch (Exception e) {
            final InflateException ie = new InflateException(parser.getPositionDescription()
                    + &quot;: &quot; + e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;

            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }

        return result;
    }
}
</code></pre>
<pre><code>
	 第二个参数和第三个参数有四种组合情况
        if(root == null &amp;&amp; ！attachToRoot){
            返回id里的view本身
        }

        if(root != null &amp;&amp; attachToRoot){
            返回root本身，此时root已经将id里的控件添加了。
        此时如果在使用root.addview(view) 就会报错。view此时已经有parent、因为view本身就是root自己。root自己addview自身会报错
        }else if (root != null &amp;&amp; !attachToRoot){
            返回返回id里的view本身，此时id里的控件已经设置了布局参数
        }

	1. 如果root为null，attachToRoot将失去作用，设置任何值都没有意义。
	2. 如果root不为null，attachToRoot设为true，则会给加载的布局文件的指定一个父布局，即root。
	3. 如果root不为null，attachToRoot设为false，则会将布局文件最外层的所有layout属性进行设置，当该view被添加到父view当中时，这些layout属性会自动生效。
	4. 在不设置attachToRoot参数的情况下，如果root不为null，attachToRoot参数默认为true。

</code></pre>
<p>Reference:	<a href="http://blog.csdn.net/guolin_blog/article/details/12921889">http://blog.csdn.net/guolin_blog/article/details/12921889</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity: configuration changes]]></title>
        <id>https://philadelphia.github.io/post/activity-configuration-changes</id>
        <link href="https://philadelphia.github.io/post/activity-configuration-changes">
        </link>
        <updated>2019-08-16T09:40:59.000Z</updated>
        <content type="html"><![CDATA[<p>Android 系统规定当系统的Configuration 改变时将会重启Activity。这是一种不太友好的体验，我们可以通过编辑Manifest文件来避免Activity的重启</p>
<blockquote>
<p>要声明由 Activity 处理配置变更，请在清单文件中编辑相应的 <activity> 元素，以包含 android:configChanges 属性以及代表要处理的配置的值。android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 &quot;orientation&quot; 和 &quot;keyboardHidden&quot;，分别用于避免因屏幕方向和可用键盘改变而导致重启）。您可以在该属性中声明多个配置值，方法是用管道 | 字符分隔这些配置值。</p>
</blockquote>
<p>例如，以下清单文件代码声明的 Activity 可同时处理屏幕方向变更和键盘可用性变更：</p>
<pre><code>&lt;activity android:name=&quot;.MyActivity&quot;
 android:configChanges=&quot;orientation|keyboardHidden&quot;	
 android:label=&quot;@string/app_name&quot;&gt;
</code></pre>
<p>现在，当其中一个配置发生变化时，MyActivity 不会重启。相反，MyActivity 会收到对 onConfigurationChanged() 的调用。向此方法传递 Configuration 对象指定新设备配置。您可以通过读取 Configuration 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 Resources 对象会相应地进行更新，以根据新配置返回资源，这样，您就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p>
<blockquote>
<p>注意：从 <code>Android 3.2（API 级别 13）</code>开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 &quot;orientation&quot; 值以外，您还必须添加 &quot;screenSize&quot; 值。 也就是说，您必须声明 android:configChanges=&quot;orientation|screenSize&quot;。但是，如果您的应用面向 API 级别 12 或更低版本，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重启 Activity）。</p>
</blockquote>
<p>例如，以下 onConfigurationChanged() 实现检查当前设备方向：</p>
<pre><code>@Override
public void onConfigurationChanged(Configuration newConfig) {
	  super.onConfigurationChanged(newConfig);

	// Checks the orientation of the screen
	if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
	    Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show();
	} else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){
	    Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show();
	}
}
</code></pre>
<p>Configuration 对象代表所有当前配置，而不仅仅是已经变更的配置。大多数时候，您并不在意配置具体发生了哪些变更，而且您可以轻松地重新分配所有资源，为您正在处理的配置提供备用资源。 例如，由于 Resources 对象现已更新，因此您可以通过 setImageResource() 重置任何 ImageView，并且使用适合于新配置的资源（如提供资源中所述）。</p>
<p>请注意，Configuration 字段中的值是与 Configuration 类中的特定常量匹配的整型数。有关要对每个字段使用哪些常量的文档，请参阅 <a href="https://developer.android.com/guide/topics/manifest/activity-element.html#config">Configuration</a> 参考文档中的相应字段。</p>
<p>请谨记：在声明由 Activity 处理配置变更时，您有责任重置要为其提供备用资源的所有元素。 如果您声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 onConfigurationChanged() 期间将每个资源重新分配给每个元素。</p>
<p>如果无需基于这些配置变更更新应用，则可不用实现 onConfigurationChanged()。在这种情况下，仍将使用在配置变更之前用到的所有资源，只是您无需重启 Activity。 但是，应用应该始终能够在保持之前状态完好的情况下关闭和重启，因此您不得试图通过此方法来逃避在正常 Activity 生命周期期间保持您的应用状态。 这不仅仅是因为还存在其他一些无法禁止重启应用的配置变更，还因为有些事件必须由您处理，例如用户离开应用，而在用户返回应用之前该应用已被销毁。</p>
<p>如需了解有关您可以在 Activity 中处理哪些配置变更的详细信息，请参阅 <code>android:configChanges</code> 文档和 <code>Configuration</code> 类。</p>
<p>如果想要Activity不在系统语言发生改变时重试，需要给Activity设置<code>locale</code>属性<br>
但是这在<code>Android 4.2</code> 之前的版本有效，<code>4.2</code>之后的版本就不行了。因为<code>Android 4.2</code>增加了一个layoutDirection属性，当改变语言设置后，该属性也会成newConfig中的一个mask位。所以ActivityManagerService(实际在ActivityStack)在决定是否重启Activity的时候总是判断为重启。<br>
需要在android:configChanges 中同时添加locale和layoutDirection。</p>
<pre><code>android:configChanges=&quot;locale|layoutDirection&quot;
</code></pre>
<p>所以一下设置应该会满足大部分情况下的Activity重启问题</p>
<pre><code>`android:configChanges=&quot;orientation|screenSize|locale|layoutDirection&quot;`
</code></pre>
<blockquote>
<p><code>orientation|screenSize</code>---方向改变</p>
<p><code>locale|layoutDirection</code>---系统语言改变</p>
</blockquote>
<p>在AndroidManifest.xml中通过配置android:configuration的方法来防止Activity被销毁并重建为什么不被推荐,具体原因参见：</p>
<p><a href="http://blog.csdn.net/aliaooooo/article/details/23606179?spm=5176.100239.blogcont32546.102.ySmWMr&amp;utm_source=tuicool">http://blog.csdn.net/aliaooooo/article/details/23606179?spm=5176.100239.blogcont32546.102.ySmWMr&amp;utm_source=tuicool</a></p>
<p>参考</p>
<ol>
<li>
<p>Android Configuration changes:<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" title="Android Configuration changes">https://developer.android.com/guide/topics/resources/runtime-changes.html</a></p>
</li>
<li>
<p><a href="http://blog.csdn.net/aliaooooo/article/details/23606179?spm=5176.100239.blogcont32546.102.ySmWMr&amp;utm_source=tuicool"> http://blog.csdn.net/aliaooooo/article/details/23606179?spm=5176.100239.blogcont32546.102.ySmWMr&amp;utm_source=tuicool </a></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Handler 引起的内存泄露分析以及解决方法]]></title>
        <id>https://philadelphia.github.io/post/handler-yin-qi-de-nei-cun-xie-lu-fen-xi-yi-ji-jie-jue-fang-fa</id>
        <link href="https://philadelphia.github.io/post/handler-yin-qi-de-nei-cun-xie-lu-fen-xi-yi-ji-jie-jue-fang-fa">
        </link>
        <updated>2019-08-16T09:36:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="handler-引起的内存泄露分析以及解决方法">Handler 引起的内存泄露分析以及解决方法</h1>
<p>Handler是Android系统提供的一种在子线程更新UI的机制，但是使用不当会导致memory leak。严重的话可能导致OOM</p>
<p>Java语言的垃圾回收机制采用了可达性分析来判断一个对象是否还有存在的必要性，如无必要就回收该对象引用的内存区域，</p>
<pre><code class="language-java">Handler handler ；
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };

}


</code></pre>
<p>然后在其他地方来发送一个延迟消息</p>
<pre><code>handler.postDelayed(new Runnable() {
    @Override
    public void run() {
        
    }
}, 500);
</code></pre>
<p>我们一般使用Handler就是扎样，但是这样会当Activity销毁后会导致memory leak.</p>
<p>原因就是activity销毁了，但是以为我们的Handler对象是一个内部类，因为内部类会持有外部类的一个引用。所以当activity销毁了，但是因为Handler还持有改Activity的引用，导致GC启动后，可达性分析发现该Activity对象还有其他引用。所以无法销毁改Activity，</p>
<p>但是handler仅仅是Activity的一个内存对象。及时他引用了Activity,他们之间也只是循环引用而已。而循环引用则不影响GC回收内存。</p>
<p>其实真正的原因是Handler调用postDelayed发送一个延迟消息时：</p>
<pre><code class="language-java">public final boolean postDelayed(Runnable r, long delayMillis)
{
    return sendMessageDelayed(getPostMessage(r), delayMillis);
}
</code></pre>
<p>而sendMessageDelayed的实现是</p>
<pre><code class="language-java">public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis &lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
</code></pre>
<p>再往下看</p>
<pre><code class="language-java">public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre>
<p>最终是将该消息加入到消息队列中。</p>
<pre><code class="language-java">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<p>可以看到，在enqueueMessage的实现中。将msg.target = this;</p>
<p>就是讲改Handler对象赋值给了message的target对象。所以message对象就引用了Handler对象''</p>
<p>进而messageQueue对象就引用了Handler对象。此次逐渐明朗。就是messagequeue———message———</p>
<p>Handler——Activity。</p>
<p>所以我们可以在任一环节做文章即可避免Handler持有Activity对象导致的内存泄露问题。</p>
<p>我们可以在Activity销毁时将任务队列清空，或者 在Activity 销毁时将Handler对象销毁。</p>
<p>总之，就是在任一环节将该引用链条切换就好了，这样GC就可以销毁Activity对象了。</p>
<p>此时还是没有触及到问题的核心，就是为什么messageQueue为什么会持有message对象进而持有Handler对象，导致Activity销毁时还有其他引用。为什么Activity销毁时MessageQueue不销毁呢，这才是问题的核心，如果messageQueue销毁了啥问题也没有了。当然我们也可以在Activity销毁时手动销毁messageQueue对象。这样也可以避免内存泄露。</p>
<p>从这我们可以看出messagequeue的生命周期比Activity长了。所以才导致这些问题。</p>
<p>其实熟悉Handler机制的话就会明白背后的原因了</p>
<pre><code class="language-java"> final Looper mLooper;
 final MessageQueue mQueue;

public Handler() {
    this(null, false);
}

public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class&lt;? extends Handler&gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
</code></pre>
<p>从构造方法我们可以看出，无参的构造方法最终调用了两参的构造方法。</p>
<pre><code>mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
</code></pre>
<p>这几行代码才是重中之重。</p>
<p>首先调用Looper.myLooper()方法。如果looper为null，说明没有调用looper.prepare()方法。从抛出的运行时异常可以看出来。(ps:所以在子线程使用handler时，第一就是要调用Looper.prepare方法)</p>
<p>looper不为空话话，将looper复制个Handler的looper对象，然后将looper的queue对象赋值给handler的queue对象。</p>
<p>可以说Handler的looper字段和queue字段都是来着looper对象的。</p>
<p>可以看出我们在Handler里发送的消息最终发送到了handler的queue对象所执行的内存区域，而这片内存区域也是Looper对象的queue对象所指向的。所以说该queue对象里所有的message对象都收到Looper对象的queue对象的管理。</p>
<p>真正的大boss来了，都是Looper搞鬼。</p>
<p>因为我们是在主线程中初始化的Handler。所以Handler引用的looper对象是在主线程中创建的。</p>
<p>在代码ActivityThread.main()中：</p>
<pre><code class="language-java">public static void main(String[] args) {
        ....

        //创建Looper和MessageQueue对象，用于处理主线程的消息
        Looper.prepareMainLooper();

        //创建ActivityThread对象
        ActivityThread thread = new ActivityThread(); 

        //建立Binder通道 (创建新线程)
        thread.attach(false);

        Looper.loop(); //消息循环运行
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    }
</code></pre>
<pre><code> Looper.prepareMainLooper();
 
  public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }
</code></pre>
<p>在prepareMainLooper方法中首先调用了prepare方法，这就是为什么我们在主线程使用Handler时不需要自己手动调动looper的prepare方法的原因。</p>
<pre><code class="language-java">private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre>
<p>在prepare方法中首先从sThreadLocal对象中取出looper对象。如果不为null.说明已经初始化过了，直接抛出异常。</p>
<p>没有初始化的话直接初始化然后放到sThreadLocal中。sThreadLocal是一个ThreadLocal类型。持有线程的私有数据。</p>
<p>此时，真相大白了。主线程的ThreadLocal——&gt;looper——&gt;messagequue——&gt;message——&gt;handler——&gt;Acitivity</p>
<p>因为APP在活动中，所以主线程一直存在。looper一直存在，messageQueue一直存在。所以当我们发送了延迟消息时，而此时Activity销毁的话。自然会引起内存泄露的。</p>
<p>解决方法也很明了了。既然我们不能再looper层面做文章，就只能在handler和message层面做文章了。在Activity销毁时 将Handler手动置为null,或者将messagequeue 清空，或者将Handler设置为静态内部类。然后内部通过若引用持有Activity对象。总之就是要让Handler和message改放手时就放手</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://philadelphia.github.io/post/hello-gridea</id>
        <link href="https://philadelphia.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>