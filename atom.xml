<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philadelphia.github.io</id>
    <title>philadelphia</title>
    <updated>2020-06-28T07:38:36.415Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philadelphia.github.io"/>
    <link rel="self" href="https://philadelphia.github.io/atom.xml"/>
    <subtitle>德不孤，必有邻</subtitle>
    <logo>https://philadelphia.github.io/images/avatar.png</logo>
    <icon>https://philadelphia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, philadelphia</rights>
    <entry>
        <title type="html"><![CDATA[Java线程池]]></title>
        <id>https://philadelphia.github.io/post/java-xian-cheng-chi</id>
        <link href="https://philadelphia.github.io/post/java-xian-cheng-chi">
        </link>
        <updated>2020-06-28T06:58:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程池">线程池</h2>
<p>Java最初是没有提供线程池的。<br>
而是只有有线程，从JDK1.5开始java推出了线程池的概念。让我们假设一个场景，如果你需要执行一批任务，你需要创建很多线程来执行这一批任务。可是随着线程数的不断增加，我们发现对线程的管理越来越难，而且很多线程本身执行的时间还没有创建线程，创建线程时会产生系统开销，并且每个线程还会占用一定的内存等资源，更重要的是我们创建如此多的线程也会给稳定性带来危害，因为每个系统中，可创建线程的数量是有一个上限的，不可能无限的创建。线程执行完需要被回收，大量的线程又会给垃圾回收带来压力。但我们的任务确实非常多，如果都在主线程串行执行，那效率也太低了，那应该怎么办呢？于是便诞生了线程池来平衡线程与系统资源之间的关系。</p>
<p>我们来总结下如果每个任务都创建一个线程会带来哪些问题：</p>
<p>第一点，反复创建线程系统开销比较大，每个线程创建和销毁都需要时间，如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。<br>
第二点，过多的线程会占用过多的内存等资源，还会带来过多的上下文切换，同时还会导致系统不稳定</p>
<p>针对上面的两点问题，线程池有两个解决思路。</p>
<p>首先，针对反复创建线程开销大的问题，线程池用一些固定的线程一直保持工作状态并反复执行任务。</p>
<p>其次，针对过多线程占用太多内存资源的问题，解决思路更直接，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。</p>
<p>线程池就好像是一个工厂，工厂里的工人数量是有限可控的，但是工厂的订单时不可控的。加入工厂车间内有5个工人，这个时候有10个订单，那这5个工人每人分配一个订单，做完了在做一个订单就好了。如果此时来了大量的订单，工厂会将这些订单放到一个待生产任务队列中。工人从这些任务队列中取订单任务执行就好了。如果继续来了任务，工厂会临时招聘一些员工来执行这些任务，待这些任务执行完毕后，经过一段时间的观察后，工厂根据自己的订单情况来决定是否要解聘这些临时招聘的工人，如果招聘了工人后还不能满足产能，那工厂就会拒绝接受订单。</p>
<h2 id="线程池的工作原理">线程池的工作原理</h2>
<h3 id="参数">参数</h3>
<figure data-type="image" tabindex="1"><img src="https://philadelphia.github.io/post-images/1593327598801.png" alt=""></figure>
<h3 id="创建流程">创建流程</h3>
<figure data-type="image" tabindex="2"><img src="https://philadelphia.github.io/post-images/1593327619378.png" alt=""></figure>
<p>如上图所示，当向线程池体检任务时，线程池首先会检测核心线程池是否已满，如果核心线程池未满，则创建核心线程执行该任务，如果核心线程池已满，则检测任务队列是否已满，如果没满，则将任务加入到任务队列中，如果任务队列已满，则判断线程池是否已满，如果未满，则创建新的非核心线程执行任务，如果线程池已满。则按照拒绝策略来拒绝新进来的任务。</p>
<p>通过对流程图的创建流程分析，我们总结出线程池的几个特点。</p>
<p>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加线程。</p>
<p>线程池只有在任务队列填满时才创建多于 corePoolSize 的线程，如果使用的是无界队列（例如 LinkedBlockingQueue），那么由于队列不会满，所以线程数不会超过 corePoolSize。</p>
<p>通过设置 corePoolSize 和 maxPoolSize 为相同的值，就可以创建固定大小的线程池。</p>
<p>通过设置 maxPoolSize 为很高的值，例如 Integer.MAX_VALUE，就可以允许线程池创建任意多的线程。</p>
<h3 id="corepoolsize">corePoolSize</h3>
<p>线程中核心线程池的数量，当没有任务执行时，这类线程也不会被移除</p>
<h3 id="maxpoolsize">maxPoolSize</h3>
<p>线程池中线程存在的最大数量==核心线程数量+非核心线程数量</p>
<h3 id="keepalivetime-timeunit">keepAliveTime + TimeUnit</h3>
<p>线程池中没有任务执行时，非核心线程的存活时间。当超过设定的时间 后，线程池会将非核心线程回收以回收系统资源。</p>
<h3 id="threadfactory">ThreadFactory</h3>
<p>线程工厂，线程池用来创建新线程的类，我们可以自定义以给新创建的线程定义我们需要的名称</p>
<h3 id="workqueue">WorkQueue</h3>
<p>任务队列，</p>
<h3 id="handler">Handler</h3>
<p>线程池的拒绝策略。当传入超过线程池的工作能力是会调用</p>
<h2 id="线程池的4中自带的拒绝策略">线程池的4中自带的拒绝策略</h2>
<p>​</p>
<pre><code>public interface RejectedExecutionHandler {

    /**
     * Method that may be invoked by a {@link ThreadPoolExecutor} when
     * {@link ThreadPoolExecutor#execute execute} cannot accept a
     * task.  This may occur when no more threads or queue slots are
     * available because their bounds would be exceeded, or upon
     * shutdown of the Executor.
     *
     * &lt;p&gt;In the absence of other alternatives, the method may throw
     * an unchecked {@link RejectedExecutionException}, which will be
     * propagated to the caller of {@code execute}.
     *
     * @param r the runnable task requested to be executed
     * @param executor the executor attempting to execute this task
     * @throws RejectedExecutionException if there is no remedy
     */
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
</code></pre>
<p>改接口有4个实现类<br>
<img src="https://philadelphia.github.io/post-images/1593327679747.png" alt=""></p>
<p>其中第一个AbortPolicy 是线程池默认的拒绝策略。</p>
<h3 id="abortpolicy">AbortPolicy</h3>
<p>改策略会在线程池工作饱和后直接丢掉新添加的工作任务，直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p>
<h3 id="discardpolicy">DiscardPolicy</h3>
<p>正如名字一样，这种策略会直接丢弃新添加的任务。不会改调用者任何提示。会造成数据丢失的风险</p>
<h3 id="discardoldestpolicy">DiscardOldestPolicy</h3>
<p>和DiscardPolicy 一样，区别是DiscardPolicy 会丢弃新添加的工作任务。而DiscardOldestPolicy会丢弃工作队列对头的任务。同理也存在数据丢失的风险</p>
<h3 id="callerrunspolicy">CallerRunsPolicy</h3>
<p>当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p>
<ul>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ul>
<p>当然我们也可以实现RejectedExecutionHandler 接口实现我们自定义的拒绝策略。</p>
<h2 id="几种常见的线程池">几种常见的线程池</h2>
<ol>
<li>FixedThreadPool</li>
<li>CachedThreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
<li>SingleThreadScheduledExecutor</li>
<li>ForkJoinPool（Java8 添加）</li>
</ol>
<h3 id="fixedthreadpool">FixedThreadPool</h3>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<p>从名字可以看出这类线程池的线程数量是固定的。这种线程池中核心线程数量==最大线程数量</p>
<p>它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p>
<h3 id="cachedthreadpool">CachedThreadPool</h3>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<p>这种线程池的线程最大数量是Integer.MAX_VALUE 也就是2^31-1，(这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p>
<h3 id="scheduledthreadpool">ScheduledThreadPool</h3>
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
</code></pre>
<p>第三个线程池是 ScheduledThreadPool，它支持定时或周期性执行任务。比如每隔 10 秒钟执行一次任务，而实现这种功能的方法主要有 3 种，如代码所示</p>
<pre><code>ScheduledExecutorService service = Executors.newScheduledThreadPool(10);

service.schedule(new Task(), 10, TimeUnit.SECONDS);

service.scheduleAtFixedRate(new Task(), 10, 10, TimeUnit.SECONDS);

service.scheduleWithFixedDelay(new Task(), 10, 10, TimeUnit.SECONDS);
</code></pre>
<p>那么这 3 种方法有什么区别呢？</p>
<ul>
<li>第一种方法 schedule 比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。</li>
<li>第二种方法 scheduleAtFixedRate 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。</li>
<li>第三种方法 scheduleWithFixedDelay 与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。</li>
</ul>
<p>举个例子，假设某个同学正在熬夜写代码，需要喝咖啡来提神，假设每次喝咖啡都需要花10分钟的时间，如果此时采用第2种方法 scheduleAtFixedRate，时间间隔设置为 1 小时，那么他将会在每个整点喝一杯咖啡，以下是时间表：</p>
<p>00:00: 开始喝咖啡</p>
<p>00:10: 喝完了</p>
<p>01:00: 开始喝咖啡</p>
<p>01:10: 喝完了</p>
<p>02:00: 开始喝咖啡</p>
<p>02:10: 喝完了</p>
<p>但是假设他采用第3种方法 scheduleWithFixedDelay，时间间隔同样设置为 1 小时，那么由于每次喝咖啡需要10分钟，而 scheduleWithFixedDelay 是以任务完成的时间为时间起点开始计时的，所以第2次喝咖啡的时间将会在1:10，而不是1:00整，以下是时间表：</p>
<p>00:00: 开始喝咖啡</p>
<p>00:10: 喝完了</p>
<p>01:10: 开始喝咖啡</p>
<p>01:20: 喝完了</p>
<p>02:20: 开始喝咖啡</p>
<p>02:30: 喝完了</p>
<p>可见下次任务开始的时间是以第一次任务结束的时间+延迟时间。</p>
<p>注意：ScheduledThreadPool执行周期任务时，如果某次任务执行失败了，后续的任务就不会执行了。所以 ScheduledThreadPoolExecutor的最优实践：将所有执行代码用try-catch包裹。在catch块里再次提交任务。</p>
<h3 id="singlethreadexecutor">SingleThreadExecutor</h3>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<p>第四种线程池是 SingleThreadExecutor，它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p>
<h3 id="singlethreadscheduledexecutor">SingleThreadScheduledExecutor</h3>
<p>第五个线程池是 SingleThreadScheduledExecutor，它实际和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程，如源码所示：</p>
<pre><code>public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new DelegatedScheduledExecutorService
        (new ScheduledThreadPoolExecutor(1));
}
</code></pre>
<h3 id="forkjoinpool">ForkJoinPool</h3>
<p>没怎么用过呢。</p>
<h2 id="为什么不应该自动创建线程池">为什么不应该自动创建线程池</h2>
<p>自动创建线程池就是直接调用 Executors 的各种方法来生成前面学过的常见的线程池，例如 Executors.newCachedThreadPool()。但这样做是有一定风险的，接下来我们就来逐一分析自动创建线程池可能带来哪些问题。</p>
<h3 id="fixedthreadpool-2">FixedThreadPool</h3>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<p>可以看出创建FixedThreadPool，系统使用了一个LinkedBlockingQueue队列，这种队列是没有长度现在，这就会导致一个问题，我们可以无限制的向线程池提交任务。如果我们对任务的处理速度比较慢，那么随着请求的增多，队列中堆积的任务也会越来越多，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。</p>
<h3 id="singlethreadexecutor-2">SingleThreadExecutor</h3>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<p>newSingleThreadExecutor 和 newFixedThreadPool 的原理是一样的，只不过把核心线程数和最大线程数都直接设置成了 1，但是任务队列仍是无界的 LinkedBlockingQueue，所以也会导致同样的问题，也就是当任务堆积时，可能会占用大量的内存并导致 OOM。</p>
<h3 id="cachedthreadpool-2">CachedThreadPool</h3>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<p>CachedThreadPool 和前两种线程池不一样的地方在于任务队列使用的是 SynchronousQueue，SynchronousQueue 本身并不存储任务，而是对任务直接进行转发，这本身是没有问题的，但你会发现构造函数的第二个参数被设置成了 Integer.MAX_VALUE，这个参数的含义是最大线程数，所以由于 CachedThreadPool 并不限制线程的数量，当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足</p>
<h3 id="scheduledthreadpool-和-singlethreadscheduledexecutor">ScheduledThreadPool 和 SingleThreadScheduledExecutor</h3>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue(), threadFactory);
}
</code></pre>
<p>通过源码可以看出，它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过的任务，就可能导致 OOM。</p>
<p>可以看到，这几种自动创建的线程池都存在风险，相比较而言，我们自己手动创建会更好，因为我们可以更加明确线程池的运行规则，不仅可以选择适合自己的线程数量，更可以在必要的时候拒绝新任务的提交，避免资源耗尽的风险。</p>
<h2 id="合适的线程数量是多少cpu-核心数和线程数的关系">合适的线程数量是多少？CPU 核心数和线程数的关系</h2>
<p>从上面的分析可知，我们不应该自动创建线程池，即不应该调用Executors的自带方法创建常用的线程池，而应该手动的创建线程池。即调用ThreadPoolExecutor的构造方法手动创建线程池，这就需要我们手动指定各个参数。</p>
<p>那么我们到底需要创建多少个核心线程，线程池的最大线程数量又该如何设定呢。</p>
<p>我们需要根据我们的任务性质设置不同的线程数量</p>
<h3 id="cpu-密集型任务">CPU 密集型任务</h3>
<p>首先，我们来看 CPU 密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。对于这样的任务最佳的线程数为 CPU 核心数的 1~2 倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍以上，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p>
<h3 id="耗时-io-型任务">耗时 IO 型任务</h3>
<p>第二种任务是耗时 IO 型，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源</p>
<p>《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：</p>
<pre><code>线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）
</code></pre>
<p>通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。</p>
<p>太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</p>
<p>结论<br>
综上所述我们就可以得出一个结论：</p>
<ul>
<li>线程的平均工作时间所占比例越高，就需要越少的线程；</li>
<li>线程的平均等待时间所占比例越高，就需要越多的线程；</li>
</ul>
<p>针对不同的程序，进行对应的实际测试就可以得到最合适的选择。</p>
<h2 id="如何正确的关闭线程池">如何正确的关闭线程池</h2>
<p>ThreadPoolExecutor提供了5个有关关闭线程池的方法</p>
<ul>
<li>void shutdown();</li>
<li>boolean isShutdown();</li>
<li>boolean isTerminated();</li>
<li>boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</li>
<li>List<Runnable> shutdownNow();</li>
</ul>
<h3 id="shutdown">shutdown</h3>
<p>该方法用于安全地关闭一个线程池，调用该方法后线程池并不会立即关闭。因为这个时候线程池可能还有任务在执行。或者任务队列中有任务待执行，调用该方法后线程池会将所有的任务执行完毕后才关闭，但是调用改方法后线程池将不再接受新的工作任务，线程池则会根据拒绝策略直接拒绝后续新提交的任务</p>
<h3 id="isshutdown">isShutdown</h3>
<p>它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown() 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</p>
<p>也就是说该方法返回true，只是表示该线程池开启了关闭操作，但是可能还没有彻底关闭，只是一个标志位</p>
<h3 id="isterminated">isTerminated</h3>
<p>不同于isShutDown方法，isShutdown方法返回true，线程池也可能没有真正关闭，线程池会将任务队列中的任务执行完毕后才真正关闭。这个时候isTerminated回放回false，但是当线程池真正关闭后，isTerminated 返回true。</p>
<h3 id="awaittermination">awaitTermination</h3>
<p>该方法不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p>
<ul>
<li>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；</li>
<li>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；</li>
<li>等待期间线程被中断，方法会抛出 InterruptedException 异常。<br>
也就是说，调用 awaitTermination 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</li>
</ul>
<p>我们则可以根据 awaitTermination() 返回的布尔值来判断下一步应该执行的操作。</p>
<h3 id="shutdownnow">shutdownNow</h3>
<p>它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。shutdownNow() 的源码如下所示。</p>
<pre><code>public List&lt;Runnable&gt; shutdownNow() { 
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try { 
          checkShutdownAccess();
          advanceRunState(STOP);
          interruptWorkers();
          tasks = drainQueue();
      } finally { 
          mainLock.unlock();
      } 

      tryTerminate();
      return tasks;
}
</code></pre>
<p>你可以看到源码中有一行 interruptWorkers() 代码，这行代码会让每一个已经启动的线程都中断，这样线程就可以在执行任务期间检测到中断信号并进行相应的处理，提前结束任务。这里需要注意的是，由于 Java 中不推荐强行停止线程的机制的限制，即便我们调用了 shutdownNow 方法，如果被中断的线程对于中断信号不理不睬，那么依然有可能导致任务不会停止。可见我们在开发中落地最佳实践是很重要的，我们自己编写的线程应当具有响应中断信号的能力，应当利用中断信号来协同工作。</p>
<h2 id="线程复用原理">线程复用原理</h2>
<p>我们知道线程池会使用固定数量或可变数量的线程来执行任务，但无论是固定数量或可变数量的线程，其线程数量都远远小于任务数量，面对这种情况线程池可以通过线程复用让同一个线程去执行不同的任务，那么线程复用背后的原理是什么呢？</p>
<p>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
<p>再看一下线程池的工作原理：</p>
<figure data-type="image" tabindex="3"><img src="https://philadelphia.github.io/post-images/1593327619378.png" alt=""></figure>
<p>我们看一下execute方法</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 step
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<pre><code> if (command == null)
        throw new NullPointerException();
</code></pre>
<p>首先进行入参判断，如果提交的任务为null，则抛出一个NPE。</p>
<p>接下来判断线程数量是否小于核心线程数量。如果线程池中线程数量小于核心线程数，则调用addWorker()方法新增一个worker，worker可以理解为一个线程。</p>
<pre><code>int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
</code></pre>
<p>addWorker 方法的主要作用是在线程池中创建一个线程并执行第一个参数传入的任务，它的第二个参数是个布尔值，如果布尔值传入 true 代表增加线程时判断当前线程是否少于 corePoolSize，小于则增加新线程，大于等于则不增加；同理，如果传入 false 代表增加线程时判断当前线程是否少于 maxPoolSize，小于则增加新线程，大于等于则不增加，所以这里的布尔值的含义是以核心线程数为界限还是以最大线程数为界限进行是否新增线程的判断。addWorker() 方法如果返回 true 代表添加成功，如果返回 false 代表添加失败。</p>
<p>接下来</p>
<pre><code>if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
</code></pre>
<p>如果代码执行到这里说明当前线程池中的线程数量大于或者等于核心线程数量，或者addWorker失败了。</p>
<p>此时就需要使用if (isRunning(c) &amp;&amp; workQueue.offer(command)) 来检查线程池是否在运行中，如果线程池状态是 Running 就把任务放入任务队列中，也就是 workQueue.offer(command)。</p>
<p>如果线程池已经不再运行状态了。需要将刚添加到任务队列的任务移出队列并执行拒绝策略。</p>
<p>代码如下</p>
<pre><code>if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
</code></pre>
<p>接下来</p>
<pre><code>else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
</code></pre>
<p>如果执行到这里说明线程池依旧在运行中。那么当任务被添加进来之后就需要防止没有可执行线程的情况发生（比如之前的线程被回收了或意外终止了），所以此时如果检查当前线程数为 0，也就是 workerCountOf**(recheck) == 0，那就执行 addWorker() 方法新建线程</p>
<p>再看一下最后一个else</p>
<pre><code> else if (!addWorker(command, false))
        reject(command);
</code></pre>
<p>执行到这里说明线程池已经不是running状态了或者任务队列已满。根据规则，此时线程池会创建新的非核心线程来执行任务。直到达到最大线程数。所以此时调用addWorker(command，false)来创建一个非核心线程。如果没有创建成功，说明线程数已满。此时执行拒绝策略 reject(command);</p>
<pre><code> final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }
</code></pre>
<p>在 execute 方法中，多次调用 addWorker 方法把任务传入，addWorker 方法会添加并启动一个 Worker，这里的 Worker 可以理解为是对 Thread 的包装，Worker 内部有一个 Thread 对象，它正是最终真正执行任务的线程，所以一个 Worker 就对应线程池中的一个线程，addWorker 就代表增加线程。线程复用的逻辑实现主要在 Worker 类中的 run 方法里执行的 runWorker 方法中，简化后的 runWorker 方法代码如下所示。</p>
<p>addWorker方法的源码</p>
<pre><code> private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
</code></pre>
<pre><code> w = new Worker(firstTask);
            final Thread t = w.thread;
</code></pre>
<p>使用传递进来的runnable构建一个Worker对象，然后取出该对象的Thread对象。</p>
<pre><code> private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
      /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        
         Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

			 /** Delegates main run loop to outer runWorker. */
        public void run() {
            runWorker(this);
        }
    }
</code></pre>
<p>从源码可以看出Worker就是一个线程实现了runnable接口，内不持有一个Thread对象。</p>
<p>在Worker的run方法中我们可以看出调用了runWorker方法。</p>
<pre><code>runWorker(Worker w) {
    Runnable task = w.firstTask;
    while (task != null || (task = getTask()) != null) {
        try {
            task.run();
        } finally {
            task = null;
        }
    }
}
</code></pre>
<p>可以看出，实现线程复用的逻辑主要在一个不停循环的 while 循环体中。</p>
<ol>
<li>通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务。</li>
<li>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）。</li>
</ol>
<p>在这里，我们找到了最终的实现，通过取 Worker 的 firstTask 或者 getTask方法从 workQueue 中取出了新任务，并直接调用 Runnable 的 run 方法来执行任务，也就是如之前所说的，每个线程都始终在一个大循环中，反复获取任务，然后执行任务，从而实现了线程的复用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列]]></title>
        <id>https://philadelphia.github.io/post/zu-sai-dui-lie</id>
        <link href="https://philadelphia.github.io/post/zu-sai-dui-lie">
        </link>
        <updated>2020-06-26T16:32:53.000Z</updated>
        <content type="html"><![CDATA[<p>阻塞队列，也就是 BlockingQueue，它是一个接口，如代码所示：</p>
<pre><code>public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;{...}
</code></pre>
<p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java 5 中加入的。</p>
<p>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了<br>
既然队列本身是线程安全的，队列可以安全地从一个线程向另外一个线程传递数据，所以我们的生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开发的难度和工作量。<br>
Java 提供的线程安全的队列（也称为并发队列）分为阻塞队列和非阻塞队列两大类。<br>
<img src="https://philadelphia.github.io/post-images/1593189553251.png" alt=""><br>
可以看出Queue接口提供了以上方法。<br>
而BlockingQueue又新增了get()和put()方法。<br>
把 BlockingQueue 中最常用的和添加、删除相关的 8 个方法列出来，并且把它们分为三组，每组方法都和添加、移除元素相关。</p>
<p>1：添加元素</p>
<pre><code>boolean add(E e) ;
boolean offer(E e);
void put(E e);
</code></pre>
<p>2:删除元素</p>
<pre><code>E remove() ;
E get();
</code></pre>
<p>3.获取队列头部元素</p>
<pre><code>E element();
E peek();
</code></pre>
<p>这三组方法由于功能很类似，所以比较容易混淆。它们的区别仅在于特殊情况：当队列满了无法添加元素，或者是队列空了无法移除元素时，不同组的方法对于这种特殊情况会有不同的处理方式：</p>
<p>1：抛出异常：add、remove、element<br>
2：返回结果但不抛出异常：offer、poll、peek<br>
3：阻塞：put、take</p>
<h2 id="第一组add-remove-element">第一组：add、remove、element</h2>
<h3 id="add">add()</h3>
<p>方法向队列中添加一个元素，如果队列没有满，这个时候添加成功，返回true<br>
如果此时队列已经满了，则会这届抛出一个异常</p>
<h3 id="remove">remove</h3>
<p>remove方法从队列中删除头部元素，<br>
如果队列不为空，则将队列头部元素从队列中移出并返回队改元素<br>
如果队列为0，则直接抛出一个NoSuchElementException 异常</p>
<h3 id="element方法">element方法</h3>
<p>该方法返回队列头部元素<br>
如果队列不为空，则直接返回队列头部元素。如果队列为空，则直接抛出NoSuchElementException<br>
改方法和remove方法的区别就是该方法只会去队列的头部元素而不会删除头部元素</p>
<h2 id="第二组offer-poll-peek">第二组：offer、poll、peek</h2>
<p>第二组方法相比于第一组而言要友好一些，当发现队列满了无法添加，或者队列为空无法删除的时候，第二组方法会给一个提示，而不是抛出一个异常。</p>
<h3 id="offer-方法">offer 方法</h3>
<p>offer 方法用来插入一个元素，并用返回值来提示插入是否成功。如果添加成功会返回 true，而如果队列已经满了，此时继续调用 offer 方法的话，它不会抛出异常，只会返回一个错误提示：false</p>
<h3 id="poll-方法">poll 方法</h3>
<p>poll 方法和第一组的 remove 方法是对应的，作用也是移除并返回队列的头节点。但是如果当队列里面是空的，没有任何东西可以移除的时候，便会返回 null 作为提示。正因如此，我们是不允许往队列中插入 null 的，否则我们没有办法区分返回的 null 是一个提示还是一个真正的元素</p>
<h3 id="peek-方法">peek 方法</h3>
<p>peek 方法和第一组的 element 方法是对应的，意思是返回队列的头元素但并不删除。如果队列里面是空的，它便会返回 null 作为提示</p>
<p>带超时时间的 offer 和 poll</p>
<p>offer 和 poll 都有带超时时间的重载方法。<br>
offer(E e, long timeout, TimeUnit unit)</p>
<p>它有三个参数，分别是元素、超时时长和时间单位。通常情况下，这个方法会插入成功并返回 true；如果队列满了导致插入不成功，在调用带超时时间重载方法的 offer 的时候，则会等待指定的超时时间，如果时间到了依然没有插入成功，就会返回 false</p>
<pre><code>poll(long timeout, TimeUnit unit)
</code></pre>
<p>带时间参数的 poll 方法和 offer 类似：如果能够移除，便会立刻返回这个节点的内容；如果队列是空的就会进行等待，等待时间正是我们指定的时间，直到超时时间到了，如果队列里依然没有元素可供移除，便会返回 null 作为提示</p>
<h2 id="第三组put-take">第三组：put、take</h2>
<p>这两个方法是阻塞队列特有的，Queue接口并不存在这个方法的声明。<br>
这两个方法的特定是在无法完成操作是会阻塞线程、</p>
<h3 id="put-方法">put 方法</h3>
<p>put 方法的作用是插入元素。通常在队列没满的时候是正常的插入，但是如果队列已满就无法继续插入，这时它既不会立刻返回 false 也不会抛出异常，而是让插入的线程陷入阻塞状态，直到队列里有了空闲空间，此时队列就会让之前的线程解除阻塞状态，并把刚才那个元素添加进去</p>
<h3 id="take-方法">take 方法</h3>
<p>take 方法的作用是获取并移除队列的头结点。通常在队列里有数据的时候会正常取出数据并删除；但是如果执行 take 的时候队列里无数据，则阻塞，直到队列里有数据；一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据</p>
<p>总和以上的分析，可以将以上分方法的区别用一个表格表示<br>
<img src="https://philadelphia.github.io/post-images/1593191082633.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译-Java字符串池是什么？ ]]></title>
        <id>https://philadelphia.github.io/post/fan-yi-what-is-java-string-pool</id>
        <link href="https://philadelphia.github.io/post/fan-yi-what-is-java-string-pool">
        </link>
        <updated>2019-11-26T06:07:58.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.journaldev.com/797/what-is-java-string-pool">原文地址</a></p>
<p>正如名字所示：Java中字符串池存储在堆内存中。我们知道java中String是一个特殊的类，我们可以通过new 操作符或者使用双引号“”创建一个String对象。</p>
<ol>
<li>Java里的字符串池</li>
<li>字符串池中创建了多少字符串对象？</li>
</ol>
<h2 id="java里的字符串池">Java里的字符串池</h2>
<p>下面是一个图，清晰的解释了java堆内存怎么管理字符串池的。以及当我们使用不同的方式创建字符串时发生了什么。</p>
<figure data-type="image" tabindex="1"><img src="https://philadelphia.github.io/post-images/1574751374767.png" alt=""></figure>
<p>字符串池是可行的，只是因为在Java中String是不可变类型的。而且它实现了字符串的interning 概念。<br>
字符串池是享元设计模式的一个实例。</p>
<p>字符串池有助于为Java运行时节省了很多的内存空间，即使它使用了更多的时间。</p>
<p>当我们使用双引号创建字符串时，它首先在字符串池中寻找同样值的字符串，如果找到了就返回该引用。如果没找到，就在池中创建一个新的字符串并返回它的引用。</p>
<p>然而使用new操作符创建字符串时，我们强制String类在堆内存上创建一个新的String对象。我们可以使用intern() 方法将它放到String池中。或者指向字符串池中有相同值字符串对象的引用。</p>
<p>下面是java程序：</p>
<pre><code>package com.journaldev.util;

public class StringPool {

    /**
    * Java String Pool example
    * @param args
    */
    public static void main(String[] args) {
        String s1 = &quot;Cat&quot;;
        String s2 = &quot;Cat&quot;;
        String s3 = new String(&quot;Cat&quot;);
        
        System.out.println(&quot;s1 == s2 :&quot;+(s1==s2));
        System.out.println(&quot;s1 == s3 :&quot;+(s1==s3));
    }

}
</code></pre>
<p>上面程序输入如下：</p>
<pre><code>s1 == s2 :true
s1 == s3 :false
</code></pre>
<p>推荐阅读: <a href="https://www.journaldev.com/16928/java-string">Java String Class</a></p>
<h2 id="字符串池中创建了几个string对象呢">字符串池中创建了几个String对象呢？</h2>
<p>有时候在Java面试中，你可能被问到关于字符串池的问题，比如，下面的语句创建了几个string.</p>
<p>String str = new String(&quot;Cat&quot;);</p>
<p>在上面的语句中，1个或者2个string被创建了，如果字符串池中已经有’cat‘字符串了，就只创建一个String.如果字符串池中没有’cat‘字符串，首先在字符串池中创建一个字符串，然后在堆内存中创建一个字符串，所有总共有2个string对象被创建了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻译-Java数组转换成List（Java Array to List Examples）]]></title>
        <id>https://philadelphia.github.io/post/fan-yi-java-shu-zu-zhuan-huan-cheng-listjava-array-to-list-examples</id>
        <link href="https://philadelphia.github.io/post/fan-yi-java-shu-zu-zhuan-huan-cheng-listjava-array-to-list-examples">
        </link>
        <updated>2019-11-25T02:39:32.000Z</updated>
        <content type="html"><![CDATA[<p>原文链接：http<a href=""></a>s://javadevnotes.com/java-array-to-list-examples</p>
<p>译文：</p>
<p>有时候我们需要将数组类型转换成为集合类型，因为后者是一个更为强大的数据结构，java.util.List 有许多普通数组不支持的功能。比如：我们可以通过List的内置方法轻易地检测list是否包含某一个特定的值。下面是一些怎么将数组转换为list的例子。</p>
<h2 id="通过-javautilarraysaslist将-array-转换成-list"><strong>通过 java.util.Arrays.asList()将 Array 转换成 List</strong></h2>
<p>Arrays 类有一个方便的方法asList,可以帮助转换任务，下面是语法：<br>
<code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code><br>
注意：参数不一定必须是数组，可变参数也可以。它可以创建一个list</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;);
   }
}
</code></pre>
<p>以上代码将穿件一个包含一个元素&quot;Apple&quot;的集合。我们也可以这样做：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;);
   }
}
</code></pre>
<p>这将生成一个包含两个元素&quot;Apple&quot;,&quot;Orange&quot;的集合</p>
<p>因为这是一个可变参数。我们可以传递一个数组，数组元素被认定为参数，例子：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = Arrays.asList(myArray);
      for (String str : myList) {
         System.out.println(str);
      }
   }
}
</code></pre>
<p>这样,一个String集合被创建出来了。数组myArray被添加进去了。myList 集合有三个元素，一下是输出：</p>
<p>Apple<br>
Banana<br>
Orange</p>
<h2 id="陷阱">陷阱</h2>
<p>这个方法有一些问题，传递进去的数组必须是一个对象数组，而不能是一个基本类型数组。比如：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      int[] myArray = { 1, 2, 3 };
      List myList = Arrays.asList(myArray);
      System.out.println(myList.size());
   }
}
</code></pre>
<p>代码输出是1。为什么呢？因为asList方法期望一个对象的可变参数，但是传递进去的参数是一个基本类型数组，它创建了一个数组集合。所以该集合的为唯一元素是myArray。因此<code>myList.get(0)</code> 将返回与myArray同样的对象。</p>
<h2 id="aslist创建的对象是固定大小的"><strong>asList()创建的对象是固定大小的</strong></h2>
<p>asList()方法返回的list对象是固定大小的，不能容纳更多的元素，比如：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = Arrays.asList(myArray);
      myList.add(&quot;Guava&quot;);
   }
}
</code></pre>
<p>输出如下：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:148)
	at java.util.AbstractList.add(AbstractList.java:108)
	at Test.main(Test.java:8)
</code></pre>
<p>因为myList是固定长度的，不能添加更多元素。</p>
<p>因为该方法返回的List对象不是java.util包下面的ArrayList，而是Arrays内部的ArrayList类型。改类没有实现add,revmove,clear方法，所以任何对改集合结构修改的调用都将失败。</p>
<h2 id="将基本数组类型转换成list"><strong>将基本数组类型转换成List</strong></h2>
<p>正如上面提到的。传递一个基本类型数组到asList方法不生效，一个不引入第三方库的解决办法是通过Java8 的流，例子如下：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      int[] intArray = { 5, 10, 21 };
      List myList = Arrays.stream(intArray).boxed()
            .collect(Collectors.toList());
   }
}
</code></pre>
<p>数组的每一个元素都被从int转换成了Integer类型(装箱)，数组就被转成了List类型。</p>
<h2 id="将数组转换成允许添加元素的list"><strong>将数组转换成允许添加元素的List</strong></h2>
<p>正如上面陷阱部分提到的，Arrays.asList()方法不支持添加或者移除元素。如果你不想这样，下面是可选方案：</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(myArray));
      myList.add(&quot;Guava&quot;);
   }
}
</code></pre>
<p>这段代码显式地创建了一个新的ArrayList对象，然后将Arrays.asList的结果添加进去了。因为我们创建了一个ArrayList。所以没有添加移除限制，上面的代码执行结束前有四个元素。不要指望代码执行时抛出异常。</p>
<h2 id="自己实现array组转换成list"><strong>自己实现Array组转换成List</strong></h2>
<p>有时候解决问题，使用我们自己的实现方案是更好的。下面是一个将java数组转换成List的简单例子:</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
      for (String str : myArray) {
         myList.add(str);
      }
      System.out.println(myList.size());
   }
}
</code></pre>
<p>代码的预期输出是3.因为逻辑执行完集合了有3个元素。</p>
<p>我们代码的负面是代码更长了，而且我们在重复造轮子。好处就是当我们的需求改变时，我们可以顺应自定义。比如：下面的代码，每一个元素都被添加到list中两次</p>
<pre><code>public class Test {
   public static void main(String[] args) {
      String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; };
      List&lt;String&gt; myList = new ArrayList&lt;String&gt;();
      for (String str : myArray) {
         myList.add(str);
         myList.add(str);
      }
      System.out.println(myList.size());
   }
}
</code></pre>
<p>输出是6，因为数组中的元素都被添加两次。下面是另外一个将String数组转换成List<Integer> 的例子：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio 在APP启动时debug app]]></title>
        <id>https://philadelphia.github.io/post/android-studio-zai-app-qi-dong-shi-debug-app</id>
        <link href="https://philadelphia.github.io/post/android-studio-zai-app-qi-dong-shi-debug-app">
        </link>
        <updated>2019-11-20T10:30:56.000Z</updated>
        <content type="html"><![CDATA[<p>有时候APP一启动就崩溃了，对应Android 就是在Application 的onCreate()方法执行时就崩溃，这个时候我们根本来不及点击debug 按钮，所以我们就无法select a process to attach to debugger.<br>
我们只能以Debug模式运行APP，麻烦</p>
<p>我们可以在<strong>设置</strong>-<strong>开发者选项</strong>(前提是已经打开开发者选项了)-<strong>选择调试应用</strong>(选择我们想要调试的应用)-勾选 <strong>等待调试器</strong> 就好了。<br>
<img src="https://philadelphia.github.io/post-images/1574247141968.jpg" alt=""></p>
<p>这个时候APP启动后不会继续执行，等我们点击debug 按钮后APP才会继续往下执行，这个时候我们就可以调试了。debug 完毕后关闭就行了。<br>
<img src="https://philadelphia.github.io/post-images/1574247152856.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity launchMode在开发中的一些使用]]></title>
        <id>https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong</id>
        <link href="https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong">
        </link>
        <updated>2019-11-19T10:54:50.000Z</updated>
        <content type="html"><![CDATA[<p>最近在做APP的通知模块时，产品要求点击通知后</p>
<ol>
<li>在用户登录的情况下直接进入到通知消息的详情页，</li>
<li>没有登录的情况下先进行登录，然后在跳转到消息的详情页</li>
</ol>
<p>但是登录页面可能包含了N多个步骤，所以最好的方式是当用户没有登录的情况下使用startActivityForResult进行登录请求，把登录功能当做一个模块，<br>
因为登录支持很多方式登录，用户在登录页面可能使用账密登录或者点击其他登录选项使用其他方式登录，<br>
我们只需要关注LogInActivity就行了，<br>
如果使用其他登录方式进行登录，当登录成功后跳转到LogInActivity<br>
我们可以给跳转intent设置flag<br>
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP);</p>
<p>只有这两种启动标志组合使用，才会调用LogInActivity的onNewIntent方法。<br>
而如果单独使用<br>
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>
的话，会将LoginActivity提到栈顶并销毁其他Activity，但是并不会回调onNewIntent方法。</p>
<p>这样的话我们就相当于使用singleTask的方式启动了LogInActivity<br>
这样中间登录步骤的页面就可以全部销毁了。<br>
然后在LogInActivity的onNewIntent()方法中setResult(Activity.Result_OK）来告诉强求页登录成功了，</p>
<pre><code>@Override
protected void onNewIntent(Intent intent) {
      super.onNewIntent(intent);
      setResult(RESULT_OK);
      finish();   
}
</code></pre>
<p>没有登录的情况下复写onBackPressed()方法就行了，因为不论使用何种登录方式，只要进行到一半返回，最终没有完成登录返回的话一定会调用onBackPressed方法。因为只用成功才会自动finish LoginActivity</p>
<pre><code>@Override
public void onBackPressed() {
    super.onBackPressed();
    setResult(RESULT_CANCELED);
}
</code></pre>
<p>其他功能也类似，比如认证相关的功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode之位运算]]></title>
        <id>https://philadelphia.github.io/post/leetcode-zhi-wei-yun-suan</id>
        <link href="https://philadelphia.github.io/post/leetcode-zhi-wei-yun-suan">
        </link>
        <updated>2019-11-15T14:13:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">//判断一个整数是不是2的N次方
private boolean is2N(int num) {
    return (num &amp; (num - 1)) == 0;
}

//判断一个正整数是奇数还是偶数,即可不是被2整除
private boolean isEvenNumber(int num) {
    return (num &amp; 1) == 0;
}

</code></pre>
<p>338：https://leetcode-cn.com/problems/counting-bits/</p>
<p>给定一个非负整数 <strong>num</strong>。计算其二进制数中的 1 的数目。</p>
<pre><code class="language-java">private int getBit1Count(int number) {
    int mask = 1;
    int count = 0;
    for (int i = 0; i &lt; 32; i++) {
        if ((number &amp; mask) != 0) {
            count += 1;
        }
        mask &lt;&lt;= 1;
    }

    return count;
}
</code></pre>
<p>136：https://leetcode-cn.com/problems/single-number/</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>1：</p>
<pre><code class="language-java">   public int selectSinlgeNumber(int[] array) {
        // a^a = 0, 0^x = x
        // a^b^a = a^a^b =b
        int a = 0;
        for (int i = 0; i &lt; array.length; i++) {
            a ^= array[i];
            Log.i(TAG, &quot;selectSinlgeNumber: &quot; + a);
        }
        return a;
    }
</code></pre>
<p>2：</p>
<pre><code class="language-java">public int selectSinlgeNumber1(int[] array) {
    HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
    for (int i = 0; i &lt; array.length; i++) {
        if (!hashSet.add(array[i])) {
            hashSet.remove(array[i]);
        }
    }
    Integer[] array1 = (Integer[]) hashSet.toArray();
    return array1[0];
}
</code></pre>
<p>260:https://leetcode-cn.com/problems/single-number-iii/</p>
<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<pre><code>public int[] selectTheSinlgeNumbers(int[] array) {
    int a = 0;
    for (int i = 0; i &lt; array.length; i++) {
        a ^= array[i];
    }
    int mask = a &amp; -a;
  
    int[] b = new int[2];

    for (int j = 0; j &lt; array.length; j++) {
        if ((mask &amp; array[j]) == 0) {
            b[0] ^= array[j];
        } else {
            b[1] ^= array[j];
        }
    }
    return b;
}
</code></pre>
<p>137:https://leetcode-cn.com/problems/single-number-ii/</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[推送]]></title>
        <id>https://philadelphia.github.io/post/tui-song</id>
        <link href="https://philadelphia.github.io/post/tui-song">
        </link>
        <updated>2019-08-30T06:26:20.000Z</updated>
        <content type="html"><![CDATA[<p>随着移动互联网和移动操作系统的发展，移动设备的功能也越来越丰富，客户端和服务端的交互越来越方便。我们可以及时收到服务的发送的信息，及时作出回应，这背后就设计到推送技术。</p>
<h1 id="传统的推送方案">传统的推送方案：</h1>
<ol>
<li>轮询：客户端定期发送Http请求（短连接）。优点：获取更新及时，缺点是浪费带宽，设备电量。(因为HTTP1.0是短连接类型，每次通话结束后就断开连接)</li>
<li>SMS服务，当服务端有推送的需求时，会向所有的客户端发送短信，缺点是  贵，小公司玩不起</li>
<li>长连接，就是连接接后，通信结束后，不断来连接，后续的通信依旧使用该连接，<br>
短连接和长连接的区别见下图：<br>
<img src="https://philadelphia.github.io/post-images/1567148424079.png" alt=""></li>
</ol>
<p>但是长连接也有断开的可能,三种原因会导致长连接的断开</p>
<ol>
<li>NAT超时：因为IP地址的数量有限，很多时候的我们的通信都是使用NAT来完成，但是NAT会定期刷新NAT映射表，会将没有数据通信的连接断开。</li>
<li>DHCP租约过期：一般而言，PC端或手机终端获取IP地址的方式大多是动态获取，即通过DHCP协议从DHCP服务器(一般由路由器同时兼任)获取。目前测试发现安卓系统对DHCP的处理有Bug， DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。</li>
<li>网络状态改变：手机网络和WIFI网络切换， 网络断开和连上等情况， 也会使长连接断开。 这里原因可能比较多， 但结果无非就是IP变了， 或者被系统通知连接断了。</li>
</ol>
<p>针对2，3照成的长连接断开，我们在连接断开后重新发起连接来解决。<br>
针对NAT照成的长连接断开，我们需要定期的发送心跳包来避免NAT失效。</p>
<p>心跳包不是长连接所必需的的，因为TCP连接默认就是长连接的。<br>
在长连接里使用心跳包有两个作用：1：避免NAT失效；2：检测长连接是否有效<br>
因为2，3造成的连接断开是不会通知客户端的，客户端只有发起连接，遇到写超时时才知道连接断开了。</p>
<h1 id="心跳包的发送频率问题">心跳包的发送频率问题：</h1>
<p>心跳包一定要小于NAT的刷新频率，这样才能避免连接被当做失效连接而关闭<br>
如果心跳包发送太频繁，除了浪费流量和电量之外，没有其他意义<br>
如果频率太慢了，可能导致NAT失效<br>
为了维持长连接，需要CPU定时发送心跳包。<br>
如果使用Timer定时器就会导致阻碍CPU进入休眠状态，很宽就会耗尽设备的电量<br>
在Android系统上推荐使用AlarmManager，AlarmManager 是系统封装的一个RTC的管理工具，RTC(Real Time Clock)是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。</p>
<h1 id="心跳包和轮询的区别">心跳包和轮询的区别</h1>
<p>心跳包和轮询看起来类似， 都是客户端主动联系服务器， 但是区别很大。</p>
<p>轮询是为了获取数据， 而心跳是为了保活TCP连接；<br>
轮询得越频繁， 获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系；<br>
轮询比心跳能耗更高， 因为一次轮询需要经过TCP三次握手， 四次挥手， 单次心跳不需要建立和拆除TCP连接。</p>
<h1 id="长连接是如何唤醒设备的">长连接是如何唤醒设备的：</h1>
<p>在设备休眠的时候是依然可以接受到推送的。如果服务器想客户端推送了信息，那么休眠状态下的设备是如何响应的呢，设备已经休眠了啊，要回答这个问题就需要对手机的硬件架构有一定的了解了。<br>
现在的移动设备的处理器一般包括两部分，一部分是AP(Application Processor)<br>
一部分是BP(BaseBand Processor)<br>
AP是用来运行操作系统和应用程序的<br>
BP是用来运行实时操作系统(RTOS)，通讯协议栈运行于BP的RTOS之上<br>
非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP，LCD，WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。</p>
<p>当设备收到数据包时，BP会唤醒AP，这样CPU接下来就会收到服务器发来的推送，然后就可以进行处理了。<br>
1:<a href="https://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/">https://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/</a><br>
2:<a href="http://www.52im.net/thread-341-1-1.html">http://www.52im.net/thread-341-1-1.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RxJava 1.0]]></title>
        <id>https://philadelphia.github.io/post/rxjava-10</id>
        <link href="https://philadelphia.github.io/post/rxjava-10">
        </link>
        <updated>2019-08-16T10:07:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="function">Function</h2>
<p>Function 是Action和Func的父接口。</p>
<pre><code>/**
 * All Func and Action interfaces extend from this.
 * &lt;p&gt;
 * Marker interface to allow instanceof checks.
 */
public interface Function {

}
</code></pre>
<h2 id="action">Action</h2>
<pre><code>/**
 * All Action interfaces extend from this.
 * &lt;p&gt;
 * Marker interface to allow instanceof checks.
 */
public interface Action extends Function {

}
</code></pre>
<p>Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；</p>
<p>Action 接口有以下子接口，<br>
Action1,Action2------Action9,ActionN</p>
<pre><code>public interface Action1&lt;T&gt; extends Action {
	void call(T t);
}

public interface Action2&lt;T1, T2&gt; extends Action {
	void call(T1 t1, T2 t2);
}

public interface ActionN extends Action {
	void call(Object... args);
}
</code></pre>
<h2 id="func">Func</h2>
<pre><code>Func接口几次Function接口和Callable接口，并复写Callable接口的call方法。
Func0接口没有参数，只有返回值，
Func1有一个参数，
Func2有两个参数。
.
.
.
Func9有9个参数，
以此类推，FuncN有N个参数


/**
 * Represents a function with zero arguments.
 */
public interface Func0&lt;R&gt; extends Function, Callable&lt;R&gt; {
	@Override
	R call();
}

/**
 * Represents a function with one argument.
 */
public interface Func1&lt;T, R&gt; extends Function {
	R call(T t);
}

/**
 * A vector-argument action.
 */
public interface Func9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; extends Function {
	R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
}
</code></pre>
<p>在创建Observable以后，我们可以通过Observable.subscribe(final Action1&lt;? super T&gt; onNext, final Action1<Throwable> onError, final Action0 onCompleted)</p>
<p>如果我们只传递onNext，onError和onComplete会使用系统默认的。</p>
<pre><code>public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }

    Action1&lt;Throwable&gt; onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;
    Action0 onCompleted = Actions.empty();
    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}

 public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    if (onError == null) {
        throw new IllegalArgumentException(&quot;onError can not be null&quot;);
    }

    Action0 onCompleted = Actions.empty();
    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}

public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    if (onError == null) {
        throw new IllegalArgumentException(&quot;onError can not be null&quot;);
    }
    if (onCompleted == null) {
        throw new IllegalArgumentException(&quot;onComplete can not be null&quot;);
    }

    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}
</code></pre>
<p>最终系统会将onNext,onError，onComplete，组合成一个ActionSubscriber，</p>
<pre><code>new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted)
/**
 * A Subscriber that forwards the onXXX method calls to callbacks.
 * @param &lt;T&gt; the value type
 */
	public final class ActionSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {

    final Action1&lt;? super T&gt; onNext;
    final Action1&lt;Throwable&gt; onError;
    final Action0 onCompleted;

    public ActionSubscriber(Action1&lt;? super T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted) {
        this.onNext = onNext;
        this.onError = onError;
        this.onCompleted = onCompleted;
    }

    @Override
    public void onNext(T t) {
        onNext.call(t);
    }

    @Override
    public void onError(Throwable e) {
        onError.call(e);
    }

    @Override
    public void onCompleted() {
        onCompleted.call();
    }
}
</code></pre>
<h2 id="observer">Observer</h2>
<pre><code>public interface Observer&lt;T&gt; {
	void onCompleted();

	void onError(Throwable e);

	void onNext(T t);
</code></pre>
<p>}</p>
<h2 id="subscriber">Subscriber</h2>
<p>Subscriber实现了Subscription接口，复写了其<code>unsubscribe</code>和<code>isUnsubscribed</code>方法。<br>
在<code>Observer</code>的基础上增加了<code>onStart</code>，<code>request</code>，<code>addToRequested</code>，<code>setProducer</code>方法。</p>
<pre><code>public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription{

    // represents requested not set yet
    private static final Long NOT_SET = Long.MIN_VALUE;

    private final SubscriptionList subscriptions;
    private final Subscriber&lt;?&gt; subscriber;
    /* protected by `this` */
    private Producer producer;
    /* protected by `this` */
    private long requested = NOT_SET; // default to not set

    protected Subscriber() {
        this(null, false);
    }


    protected Subscriber(Subscriber&lt;?&gt; subscriber) {
        this(subscriber, true);
    }

   
    protected Subscriber(Subscriber&lt;?&gt; subscriber, boolean shareSubscriptions) {
        this.subscriber = subscriber;
        this.subscriptions = shareSubscriptions &amp;&amp; subscriber != null ? subscriber.subscriptions : new SubscriptionList();
    }


    public final void add(Subscription s) {
        subscriptions.add(s);
    }

    @Override
    public final void unsubscribe() {
        subscriptions.unsubscribe();
    }


    @Override
    public final boolean isUnsubscribed() {
        return subscriptions.isUnsubscribed();
    }

    
    public void onStart() {
        // do nothing by default
    }
    
    
    protected final void request(long n) {
        if (n &lt; 0) {
            throw new IllegalArgumentException(&quot;number requested cannot be negative: &quot; + n);
        } 
        
        // if producer is set then we will request from it
        // otherwise we increase the requested count by n
        Producer producerToRequestFrom = null;
        synchronized (this) {
            if (producer != null) {
                producerToRequestFrom = producer;
            } else {
                addToRequested(n);
                return;
            }
        }
        // after releasing lock (we should not make requests holding a lock)
        producerToRequestFrom.request(n);
    }

    private void addToRequested(long n) {
        if (requested == NOT_SET) {
            requested = n;
        } else { 
            final long total = requested + n;
            // check if overflow occurred
            if (total &lt; 0) {
                requested = Long.MAX_VALUE;
            } else {
                requested = total;
            }
        }
    }
    
  
    public void setProducer(Producer p) {
        long toRequest;
        boolean passToSubscriber = false;
        synchronized (this) {
            toRequest = requested;
            producer = p;
            if (subscriber != null) {
                // middle operator ... we pass through unless a request has been made
                if (toRequest == NOT_SET) {
                    // we pass through to the next producer as nothing has been requested
                    passToSubscriber = true;
                }
            }
        }
        // do after releasing lock
        if (passToSubscriber) {
            subscriber.setProducer(producer);
        } else {
            // we execute the request with whatever has been requested (or Long.MAX_VALUE)
            if (toRequest == NOT_SET) {
                producer.request(Long.MAX_VALUE);
            } else {
                producer.request(toRequest);
            }
        }
    }
}
</code></pre>
<h2 id="observable-与observer建立绑定关系">Observable 与Observer建立绑定关系</h2>
<p>Observable.create().subscribe(new Observer)</p>
<pre><code>  public final Subscription subscribe(final Observer&lt;? super T&gt; observer) {
        if (observer instanceof Subscriber) {
            return subscribe((Subscriber&lt;? super T&gt;)observer);
        }
        return subscribe(new ObserverSubscriber&lt;T&gt;(observer));
    }
</code></pre>
<p>如果传入的直接是一个Subscriber对象的话，直接调用subscribe（Subscriber observer）<br>
否则调用subsribe(new ObserverSubscriber<T>(observer)),将observer构造成一个ObserverSubscriber对象传入。<br>
其实两者都是一样的。因为<code>ObserverSubscriber</code> 也是<code>Subscriber</code>的子类。</p>
<h2 id="observersubscriber">ObserverSubscriber</h2>
<pre><code>	/**
	 * Wraps an Observer and forwards the onXXX method calls to it.
	 * @param &lt;T&gt; the value type
	 */
	public final class ObserverSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {
    final Observer&lt;? super T&gt; observer;

    public ObserverSubscriber(Observer&lt;? super T&gt; observer) {
        this.observer = observer;
    }
    
    @Override
    public void onNext(T t) {
        observer.onNext(t);
    }
    
    @Override
    public void onError(Throwable e) {
        observer.onError(e);
    }
    
    @Override
    public void onCompleted() {
        observer.onCompleted();
    }
}
</code></pre>
<p>该类包裹了一个Observer对象。所有的实现其实是Observer对象来操作的。</p>
<pre><code>	 public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {
	        return Observable.subscribe(subscriber, this);
	    }



    static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
     // validate and proceed
        if (subscriber == null) {
            throw new IllegalArgumentException(&quot;observer can not be null&quot;);
        }
        if (observable.onSubscribe == null) {
            throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);
            /*
             * the subscribe function can also be overridden but generally that's not the appropriate approach
             * so I won't mention that in the exception
             */
        }
        
        // new Subscriber so onStart it
		先调用subscriber的onStart方法。
        subscriber.onStart();
        
        /*
         * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls
         * to user code from within an Observer&quot;
         */
        // if not already wrapped
        if (!(subscriber instanceof SafeSubscriber)) {
            // assign to `observer` so we return the protected version
            subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
        }

        // The code below is exactly the same an unsafeSubscribe but not used because it would 
        // add a significant depth to already huge call stacks.
        try {
            // allow the hook to intercept and/or decorate
            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
            return hook.onSubscribeReturn(subscriber);
        } catch (Throwable e) {
            // special handling for certain Throwable/Error/Exception types
            Exceptions.throwIfFatal(e);
            // in case the subscriber can't listen to exceptions anymore
            if (subscriber.isUnsubscribed()) {
                RxJavaPluginUtils.handleException(hook.onSubscribeError(e));
            } else {
                // if an unhandled error occurs executing the onSubscribe we will propagate it
                try {
                    subscriber.onError(hook.onSubscribeError(e));
                } catch (Throwable e2) {
                    Exceptions.throwIfFatal(e2);
                    // if this happens it means the onError itself failed (perhaps an invalid function implementation)
                    // so we are unable to propagate the error correctly and will just throw
                    RuntimeException r = new OnErrorFailedException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);
                    // TODO could the hook be the cause of the error in the on error handling.
                    hook.onSubscribeError(r);
                    // TODO why aren't we throwing the hook's return value.
                    throw r;
                }
            }
            return Subscriptions.unsubscribed();
        }
    }
</code></pre>
<p>该方法返回一个<code>Subscription</code>对象</p>
<h2 id="subscription">Subscription</h2>
<pre><code>	public interface Subscription {

    /**
     * Stops the receipt of notifications on the {@link Subscriber} that was registered when this Subscription
     * was received.
     * &lt;p&gt;
     * This allows unregistering an {@link Subscriber} before it has finished receiving all events (i.e. before
     * onCompleted is called).
     */
    void unsubscribe();

    /**
     * Indicates whether this {@code Subscription} is currently unsubscribed.
     *
     * @return {@code true} if this {@code Subscription} is currently unsubscribed, {@code false} otherwise
     */
    boolean isUnsubscribed();

}
</code></pre>
<p>该接口有两个方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit2.0简介]]></title>
        <id>https://philadelphia.github.io/post/retrofit20-jian-jie</id>
        <link href="https://philadelphia.github.io/post/retrofit20-jian-jie">
        </link>
        <updated>2019-08-16T10:07:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1定义">1.定义</h2>
<p>官方的Retrofit主页是这样描述它的</p>
<blockquote>
<p>A type-safe HTTP client for Android and Java</p>
</blockquote>
<blockquote>
<p>用于Android和Java的一个类型安全(type-safe)的REST客户端</p>
</blockquote>
<p>你可以使用注解去描述HTTP请求，同时Retrofit默认集成URL参数替换和查询参数.除此之外它还支持 Multipart请求和文件上传。</p>
<h2 id="2使用">2.使用</h2>
<p>注意这个任务是网络任务，不要忘记给程序加入网络权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies { 
 // Retrofit &amp;amp; OkHttp
compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
}
</code></pre>
<p><code>Retrofit</code> 需要最低<code>JDK 1.7</code> 和 <code>Android 2.3</code>.</p>
<p>retfofit 使用注解的方式定义API</p>
<p>方法类型有：</p>
<blockquote>
<p>GET, POST, PUT, DELETE, HEAD</p>
</blockquote>
<p>1	声明API</p>
<pre><code>public interface GitHubService {
  @GET(&quot;users/{user}/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}
</code></pre>
<p>2	初始化Retrofit</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com/&quot;)
.build();

GitHubService service = retrofit.create(GitHubService.class);
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);    
</code></pre>
<p>3	发起请求：</p>
<p>//同步请求</p>
<pre><code>try {
  Response&lt;List&lt;Repo&gt;&gt; bodyResponse = call.execute();
  String body = bodyResponse.body().string();//获取返回体的字符串
  Log.i(&quot;wxl&quot;, &quot;body=&quot; + body);
  } catch (IOException e) {
  e.printStackTrace();
  }
</code></pre>
<p>//异步请求</p>
<pre><code>call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {
            @Override
            public void onResponse(Response&lt;List&lt;Repo&gt;&gt; response) {
                try {
                    Log.i(&quot;wxl&quot;, &quot;response=&quot; + response.body().string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void onFailure(Throwable t) {
                Log.i(&quot;wxl&quot;, &quot;onFailure=&quot; + t.getMessage());
            }
        });
</code></pre>
<p>4 取消请求</p>
<pre><code>call.cancel();
</code></pre>
<p>所有的请求方法都是按照上述类型执行。<br>
在方法声明时注解@GET，@POST,@PUT 分别对应方法的类型。</p>
<p>接口参数</p>
<blockquote>
<p>Path</p>
</blockquote>
<p>ApiStores</p>
<pre><code> /**
 * Call&lt;T&gt; get();必须是这种形式,这是2.0之后的新形式
 * 如果不需要转换成Json数据,可以用了ResponseBody;
 * 你也可以使用Call&lt;GsonBean&gt; get();这样的话,需要添加Gson转换器
 */
public interface ApiStores {
    @GET(&quot;adat/sk/{cityId}.html&quot;)
    Call&lt;ResponseBody&gt; getWeather(@Path(&quot;cityId&quot;) String cityId);
}
</code></pre>
<blockquote>
<p>Query</p>
</blockquote>
<p>如果链接是http://ip.taobao.com/service/getIpInfo.php?ip=202.202.33.33</p>
<p>ApiStores</p>
<pre><code>public interface ApiStores {
	@GET(&quot;http://ip.taobao.com/service/getIpInfo.php&quot;)
	Call&lt;ResponseBody&gt; getWeather(@Query(&quot;ip&quot;) String ip);
</code></pre>
<p>复杂的查询参数也可以使用Map。</p>
<pre><code>@GET(&quot;group/{id}/users&quot;)
Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options);
</code></pre>
<blockquote>
<p>Headers</p>
</blockquote>
<p>你可以通过@Headers参数来设置静态headers</p>
<pre><code>@Headers(&quot;Cache-Control: max-age=640000&quot;)
@GET(&quot;widget/list&quot;)
Call&lt;List&lt;Widget&gt;&gt; widgetList();

@Headers({
    &quot;Accept: application/vnd.github.v3.full+json&quot;,
    &quot;User-Agent: Retrofit-Sample-App&quot;
})
@GET(&quot;users/{username}&quot;)
Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username);
</code></pre>
<p><code>Headers</code>不复写其他的<code>Headers</code>值。所有同名的的<code>Headers</code>参数都将包含在该请求中。<br>
Request的Header可以通过使用<code>@Header</code>注解动态更新。必须给<code>@Header</code>提供一个相应的参数。如果该值为空，该<code>Header</code>就被忽略了。不然就会调用value的<code>toString()</code>方法获得value的值。</p>
<pre><code>@GET(&quot;user&quot;)
Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)
</code></pre>
<p>每一个request都有的header可以通过设置<code>OkHttp interceptor</code>来统一添加。</p>
<blockquote>
<p>Body</p>
</blockquote>
<p>这是针对POST方式，如果参数是json格式，如：</p>
<pre><code>{		
    &quot;apiInfo&quot;: {		
        &quot;apiName&quot;: &quot;WuXiaolong&quot;,		
        &quot;apiKey&quot;: &quot;666&quot;		
    }		
}
</code></pre>
<p>ApiStores</p>
<pre><code>public interface ApiStores {
    @POST(&quot;client/shipper/getCarType&quot;)
    Call&lt;ResponseBody&gt; getCarType(@Body ApiInfo apiInfo);
   }
</code></pre>
<p>这个<code>Object</code>将被<code>Retrofit</code>对象所指定的<code>Converter</code>所转换，如果没有指定转换器，只能使用<code>RequestBody</code>来定义参数。</p>
<p>建立Bean</p>
<pre><code>public class ApiInfo {
       private ApiInfoBean apiInfo;
       public ApiInfoBean getApiInfo() {
           return apiInfo;
       }
       public void setApiInfo(ApiInfoBean apiInfo) {
           this.apiInfo = apiInfo;
       }
       public class ApiInfoBean {
           private String apiName;
           private String apiKey;
           //省略get和set方法
       }
   }
</code></pre>
<p>代码调用</p>
<pre><code>private void getCarType() {
   mRetrofit = new Retrofit.Builder()
           .baseUrl(&quot;http://WuXiaolong.me/&quot;)
           .addConverterFactory(GsonConverterFactory.create())
           .build();
   ApiStores apiStores = mRetrofit.create(ApiStores.class);
   ApiInfo apiInfo = new ApiInfo();
   ApiInfo.ApiInfoBean apiInfoBean = apiInfo.new ApiInfoBean();
   apiInfoBean.setApiKey(&quot;666&quot;);
   apiInfoBean.setApiName(&quot;WuXiaolong&quot;);
   apiInfo.setApiInfo(apiInfoBean);
   Call&lt;ResponseBody&gt; call = apiStores.getCarType(apiInfo);
   call.enqueue(new Callback&lt;ResponseBody&gt;() {
       @Override
       public void onResponse(Response&lt;ResponseBody&gt; response) {
           String body = null;//获取返回体的字符串
           try {
               body = response.body().string();
           } catch (IOException e) {
               e.printStackTrace();
           }
           Log.i(&quot;wxl&quot;, &quot;get=&quot; + body);
       }
       @Override
       public void onFailure( Throwable t) {
       }
   });
   }
</code></pre>
<blockquote>
<p>Url encode</p>
</blockquote>
<p>POST or PUT Url encode 過的表單資料，用@FormUrlEncoded，使用@Field個別指定</p>
<pre><code>@POST(&quot;/articles/{article_id}/comments&quot;)
@FormUrlEncoded
Comment create(
@Path(&quot;article_id&quot;) int articleId,
@Field(&quot;rating&quot;) int rating,
@Field(&quot;content&quot;) String content
);
</code></pre>
<p>POST or PUT Url encode 過的表單資料，用@FormUrlEncoded，參數也可用@Body傳</p>
<pre><code>@POST(&quot;/articles/{article_id}/comments&quot;)
@FormUrlEncoded
Comment create(
    @Path(&quot;article_id&quot;) int articleId,
    @Body Comment comment
);
</code></pre>
<blockquote>
<p>POST or PUT 用@Multipart來上傳檔案</p>
</blockquote>
<pre><code>@PUT(&quot;/me&quot;)
@Multipart
Me update(
    @Part(&quot;display_name&quot;) String displayName,
    @Part(&quot;avatar&quot;) TypedFile avatar
);
</code></pre>
<p>更详细的信息，请点击：<a href="http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/">http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/</a></p>
<p>更多更有效的 Converters</p>
<blockquote>
<p>默认情况下，<code>Retrofit</code> 只能反序列化<code>HTTP</code> body到<code>OKHTTP</code>的<code>ResponseBody</code>类型。并且<code>OKHTTP</code>只接受<code>Retrifit</code> <code>@Body</code>类型的<code>RequestBody</code><br>
可以添加<code>Converter</code>转换器来支持其他的类型，6个相似的兼容流行的序列化库模块可以供使用。</p>
</blockquote>
<pre><code>Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson	
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml	
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
</code></pre>
<p>例子:</p>
<pre><code>interface which uses Gson for its deserialization.

Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com&quot;)
    .addConverterFactory(GsonConverterFactory.create())
    .build();

GitHubService service = retrofit.create(GitHubService.class);
</code></pre>
<blockquote>
<p>Retrofit 1 里有一个 converter 的问题。多数人可能没遇到过，是库内部的一个问题。在 Retrofit 2 里，已经解决了这个问题，同时开始支持多种 Converter 并存。</p>
</blockquote>
<blockquote>
<p>在之前，如果你遇到这种情况：一个 API 请求返回的结果需要通过 JSON 反序列化，另一个 API 请求需要通过 proto 反序列化，唯一的解决方&gt;案就是将两个接口分离开声明。</p>
</blockquote>
<pre><code>interface SomeProtoService {
  @GET(&quot;/some/proto/endpoint&quot;)
  Call&lt;SomeProtoResponse&gt; someProtoEndpoint();
}

interface SomeJsonService {
  @GET(&quot;/some/json/endpoint&quot;)
  Call&lt;SomeJsonResponse&gt; someJsonEndpoint();
</code></pre>
<blockquote>
<p>之所以搞得这么麻烦是因为一个 REST adapter 只能绑定一个 Converter 对象。我们费工夫去解决这个是因为：接口的声明是要语意化的。API 接口应该通过功能实现分组，比如： account 的接口，user 的接口，或者 Twitter 相关的接口。返回格式的差异不应该成为你分组时候的阻碍。</p>
</blockquote>
<blockquote>
<p>现在，你可以把他们都放在一起了：</p>
</blockquote>
<pre><code>interface SomeService {
  @GET(&quot;/some/proto/endpoint&quot;)
  Call&lt;SomeProtoResponse&gt; someProtoEndpoint();

  @GET(&quot;/some/json/endpoint&quot;)
  Call&lt;SomeJsonResponse&gt; someJsonEndpoint();
}
</code></pre>
<blockquote>
<p>SomeProtoResponse —&gt; Proto? Yes!</p>
</blockquote>
<blockquote>
<p>原理很简单，其实就是对着每一个 converter 询问他们是否能够处理某种类型。我们问 proto 的 converter： “Hi, 你能处理 SomeProtoResponse 吗？”，然后它尽可能的去判断它是否可以处理这种类型。我们都知道：Protobuff 都是从一个名叫 message 或者 message lite 的类继承而来。所以，判断方法通常就是检查这个类是否继承自 message。<br>
在面对 JSON 类型的时候，首先问 proto converter，proto converter 会发现这个不是继承子 Message 的，然后回复 no。紧接着移到下一个 JSON converter 上。JSON Converter 会回复说我可以！</p>
</blockquote>
<blockquote>
<p>SomeJsonResponse —&gt; Proto? No! —&gt; JSON? Yes!</p>
</blockquote>
<blockquote>
<p>因为 JSON 并没有什么继承上的约束。所以我们无法通过什么确切的条件来判断一个对象是否是 JSON 对象。以至于 JSON 的 converters 会对任何数据都回复说：我可以处理！这个一定要记住， JSON converter 一定要放在最后，不然会和你的预期不符。</p>
<p>另一个要注意的是，现在已经不提供默认的 converter 了。如果不显性的声明一个可用的 Converter 的话，Retrofit 是会报错的：提醒你没有可用的 Converter。因为核心代码已经不依赖序列化相关的第三方库了，我们依然提供对 Converter 的支持，不过你需要自己引入这些依赖，同时显性的声明 Retrofit 需要用的 Converter 有哪些。<br>
添加 converter 的顺序很重要。按照这个顺序，我们将依次询问每一个 converter 能否处理一个类型。我上面写的其实是错的。如果我们试图反序列化一个 proto 格式，它其实会被当做 JSON 来对待。这显然不是我们想要的。我们需要调整下顺序，因为我们先要检查 proto buffer 格式，然后才是 JSON。</p>
</blockquote>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com&quot;)
.addConverterFactory(ProtoConverterFactory.create())
.addConverterFactory(GsonConverterFactory.create())
.build();
</code></pre>
<blockquote>
<p>由于现在Retrofit开始依赖 OkHttp， 并没有 Http Client 层的抽象。现在是可以传递一个配置好的 OkHttp 实例的。比如：配置 interceptors, 或者一个 SSL socket 工厂类， 或者 timeouts 的具体数值。 （OkHttp 有默认的超时机制，如果你不需要自定义，实际上不&gt;必进行任何设置，但是如果你想要去设置它们，下面是一个例子告诉你来怎么操作。）</p>
</blockquote>
<pre><code> OkHttpClient client = new OkHttpClient.Builder()
            .retryOnConnectionFailure(true)			//失败后是否重试
            .connectTimeout(15, TimeUnit.SECONDS)	//设置连接超时时间
            .addInterceptor(getHttpInterceptor())	//设置应用拦截器
            .build();

Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com&quot;)	//设置BaseURL
    .client(client)						//设置client
    .build();
</code></pre>
<h2 id="3-interceptor">3 Interceptor</h2>
<blockquote>
<p>在使用Android retrofit+rxjava时，想获知网络请求的一些参数，方便调试，比如：请求地址、请求响应时间、请求响应消息体等内容，虽然部分可以通过每个接口进行获知，但是这样极其不方便，可以使用拦截器来做统一的操作。</p>
</blockquote>
<p>添加拦截器：<br>
可以针对OkHttpClient.Builder 添加拦截器</p>
<pre><code>HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);	//设置日志级别

OkHttpClient client = new OkHttpClient.Builder()
            .retryOnConnectionFailure(true)			//失败后是否重试
            .connectTimeout(15, TimeUnit.SECONDS)	//设置连接超时时间
            .addInterceptor(interceptor)	//设置应用拦截器
            .build();
</code></pre>
<h2 id="4cache">4.Cache</h2>
<blockquote>
<p>开启OKHttp缓存：</p>
</blockquote>
<p>先获取系统外部存储的路径，”xxx”可以自己命名，缓存文件就存在 Android/data/&lt;包名&gt;/cache/resposes。</p>
<pre><code>File httpCacheDirectory = new File(UIUtils.getContext().getExternalCacheDir(), &quot;xxx&quot;); 
client.setCache(new Cache(httpCacheDirectory,10 * 1024 * 1024));
</code></pre>
<h2 id="5proguard">5.Proguard</h2>
<blockquote>
<p>如果你在你的代码里使用代码混淆机制,请在你的配置里添加下面几行.</p>
</blockquote>
<pre><code># Platform calls Class.forName on types which do not exist on Android to determine platform.
-dontnote retrofit2.Platform
# Platform used when running on RoboVM on iOS. Will not be used at runtime.
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
# Platform used when running on Java 8 VMs. Will not be used at runtime.
-dontwarn retrofit2.Platform$Java8
# Retain generic type information for use by reflection by converters and adapters.
-keepattributes Signature
# Retain declared checked exceptions for use by a Proxy instance.
-keepattributes Exceptions
</code></pre>
<h2 id="6-nitoice">6 Nitoice</h2>
<blockquote>
<p>Retrofit 在请求失败时依然会回调 <code>onResponse()</code>方法。及时response code不是200依然会回调一下方法，需要注意。</p>
</blockquote>
<pre><code> public void onResponse(Call&lt;LoginResult&gt; call, Response&lt;LoginResult&gt; response) {
	 
}
</code></pre>
<h2 id="7references">7:References</h2>
<ol>
<li>
<p>Retrofit github主页：<a href="https://square.github.io/retrofit/" title="retrofit github 主页">https://square.github.io/retrofit/</a></p>
</li>
<li>
<p>Interceptor wiki:	<a href="https://github.com/square/okhttp/wiki/Interceptors" title="retrofit interceptor">https://github.com/square/okhttp/wiki/Interceptors</a></p>
</li>
<li>
<p>用 Retrofit 2 简化 HTTP 请求	<a href="https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/"> https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/</a></p>
</li>
<li>
<p>Http Caching:		<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" title="Http Cache">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p>
</li>
<li>
<p>四种常见的 POST 提交数据方式		<a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" title="四种常见的 POST 提交数据方式">https://imququ.com/post/four-ways-to-post-data-in-http.html</a></p>
</li>
<li>
<p>Blog				 <a href="http://wuxiaolong.me/2016/01/15/retrofit/" title="Blog"> http://wuxiaolong.me/2016/01/15/retrofit/</a></p>
</li>
<li>
<p>URL wikipedia: 		<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" title="URL wikipedia: ">https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6</a></p>
</li>
</ol>
]]></content>
    </entry>
</feed>