<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philadelphia.github.io</id>
    <title>philadelphia</title>
    <updated>2019-11-20T03:41:04.657Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philadelphia.github.io"/>
    <link rel="self" href="https://philadelphia.github.io/atom.xml"/>
    <subtitle>德不孤，必有邻</subtitle>
    <logo>https://philadelphia.github.io/images/avatar.png</logo>
    <icon>https://philadelphia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, philadelphia</rights>
    <entry>
        <title type="html"><![CDATA[Activity launchMode在开发中的一些使用]]></title>
        <id>https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong</id>
        <link href="https://philadelphia.github.io/post/activity-launchmode-zai-kai-fa-zhong-de-yi-xie-shi-yong">
        </link>
        <updated>2019-11-19T10:54:50.000Z</updated>
        <content type="html"><![CDATA[<p>最近在做APP的通知模块时，产品要求点击通知后</p>
<ol>
<li>在用户登录的情况下直接进入到通知消息的详情页，</li>
<li>没有登录的情况下先进行登录，然后在跳转到消息的详情页</li>
</ol>
<p>但是登录页面可能包含了N多个步骤，所以最好的方式是当用户没有登录的情况下使用startActivityForResult进行登录请求，把登录功能当做一个模块，<br>
因为登录支持很多方式登录，用户在登录页面可能使用账密登录或者点击其他登录选项使用其他方式登录，<br>
我们只需要关注LogInActivity就行了，<br>
如果使用其他登录方式进行登录，当登录成功后跳转到LogInActivity<br>
我们可以给跳转intent设置flag<br>
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP);</p>
<p>只有这两种启动标志组合使用，才会调用LogInActivity的onNewIntent方法。<br>
而如果单独使用<br>
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>
的话，会将LoginActivity提到栈顶并销毁其他Activity，但是并不会回调onNewIntent方法。</p>
<p>这样的话我们就相当于使用singleTask的方式启动了LogInActivity<br>
这样中间登录步骤的页面就可以全部销毁了。<br>
然后在LogInActivity的onNewIntent()方法中setResult(Activity.Result_OK）来告诉强求页登录成功了，</p>
<pre><code>@Override
protected void onNewIntent(Intent intent) {
      super.onNewIntent(intent);
      setResult(RESULT_OK);
      finish();   
}
</code></pre>
<p>没有登录的情况下复写onBackPressed()方法就行了，因为不论使用何种登录方式，只要进行到一半返回，最终没有完成登录返回的话一定会调用onBackPressed方法。因为只用成功才会自动finish LoginActivity</p>
<pre><code>@Override
public void onBackPressed() {
    super.onBackPressed();
    setResult(RESULT_CANCELED);
}
</code></pre>
<p>其他功能也类似，比如认证相关的功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode之位运算]]></title>
        <id>https://philadelphia.github.io/post/leetcode-zhi-wei-yun-suan</id>
        <link href="https://philadelphia.github.io/post/leetcode-zhi-wei-yun-suan">
        </link>
        <updated>2019-11-15T14:13:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">//判断一个整数是不是2的N次方
private boolean is2N(int num) {
    return (num &amp; (num - 1)) == 0;
}

//判断一个正整数是奇数还是偶数,即可不是被2整除
private boolean isEvenNumber(int num) {
    return (num &amp; 1) == 0;
}

</code></pre>
<p>338：https://leetcode-cn.com/problems/counting-bits/</p>
<p>给定一个非负整数 <strong>num</strong>。计算其二进制数中的 1 的数目。</p>
<pre><code class="language-java">private int getBit1Count(int number) {
    int mask = 1;
    int count = 0;
    for (int i = 0; i &lt; 32; i++) {
        if ((number &amp; mask) != 0) {
            count += 1;
        }
        mask &lt;&lt;= 1;
    }

    return count;
}
</code></pre>
<p>136：https://leetcode-cn.com/problems/single-number/</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>1：</p>
<pre><code class="language-java">   public int selectSinlgeNumber(int[] array) {
        // a^a = 0, 0^x = x
        // a^b^a = a^a^b =b
        int a = 0;
        for (int i = 0; i &lt; array.length; i++) {
            a ^= array[i];
            Log.i(TAG, &quot;selectSinlgeNumber: &quot; + a);
        }
        return a;
    }
</code></pre>
<p>2：</p>
<pre><code class="language-java">public int selectSinlgeNumber1(int[] array) {
    HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
    for (int i = 0; i &lt; array.length; i++) {
        if (!hashSet.add(array[i])) {
            hashSet.remove(array[i]);
        }
    }
    Integer[] array1 = (Integer[]) hashSet.toArray();
    return array1[0];
}
</code></pre>
<p>260:https://leetcode-cn.com/problems/single-number-iii/</p>
<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<pre><code>public int[] selectTheSinlgeNumbers(int[] array) {
    int a = 0;
    for (int i = 0; i &lt; array.length; i++) {
        a ^= array[i];
    }
    int mask = a &amp; -a;
  
    int[] b = new int[2];

    for (int j = 0; j &lt; array.length; j++) {
        if ((mask &amp; array[j]) == 0) {
            b[0] ^= array[j];
        } else {
            b[1] ^= array[j];
        }
    }
    return b;
}
</code></pre>
<p>137:https://leetcode-cn.com/problems/single-number-ii/</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[推送]]></title>
        <id>https://philadelphia.github.io/post/tui-song</id>
        <link href="https://philadelphia.github.io/post/tui-song">
        </link>
        <updated>2019-08-30T06:26:20.000Z</updated>
        <content type="html"><![CDATA[<p>随着移动互联网和移动操作系统的发展，移动设备的功能也越来越丰富，客户端和服务端的交互越来越方便。我们可以及时收到服务的发送的信息，及时作出回应，这背后就设计到推送技术。</p>
<h1 id="传统的推送方案">传统的推送方案：</h1>
<ol>
<li>轮询：客户端定期发送Http请求（短连接）。优点：获取更新及时，缺点是浪费带宽，设备电量。(因为HTTP1.0是短连接类型，每次通话结束后就断开连接)</li>
<li>SMS服务，当服务端有推送的需求时，会向所有的客户端发送短信，缺点是  贵，小公司玩不起</li>
<li>长连接，就是连接接后，通信结束后，不断来连接，后续的通信依旧使用该连接，<br>
短连接和长连接的区别见下图：<br>
<img src="https://philadelphia.github.io/post-images/1567148424079.png" alt=""></li>
</ol>
<p>但是长连接也有断开的可能,三种原因会导致长连接的断开</p>
<ol>
<li>NAT超时：因为IP地址的数量有限，很多时候的我们的通信都是使用NAT来完成，但是NAT会定期刷新NAT映射表，会将没有数据通信的连接断开。</li>
<li>DHCP租约过期：一般而言，PC端或手机终端获取IP地址的方式大多是动态获取，即通过DHCP协议从DHCP服务器(一般由路由器同时兼任)获取。目前测试发现安卓系统对DHCP的处理有Bug， DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。</li>
<li>网络状态改变：手机网络和WIFI网络切换， 网络断开和连上等情况， 也会使长连接断开。 这里原因可能比较多， 但结果无非就是IP变了， 或者被系统通知连接断了。</li>
</ol>
<p>针对2，3照成的长连接断开，我们在连接断开后重新发起连接来解决。<br>
针对NAT照成的长连接断开，我们需要定期的发送心跳包来避免NAT失效。</p>
<p>心跳包不是长连接所必需的的，因为TCP连接默认就是长连接的。<br>
在长连接里使用心跳包有两个作用：1：避免NAT失效；2：检测长连接是否有效<br>
因为2，3造成的连接断开是不会通知客户端的，客户端只有发起连接，遇到写超时时才知道连接断开了。</p>
<h1 id="心跳包的发送频率问题">心跳包的发送频率问题：</h1>
<p>心跳包一定要小于NAT的刷新频率，这样才能避免连接被当做失效连接而关闭<br>
如果心跳包发送太频繁，除了浪费流量和电量之外，没有其他意义<br>
如果频率太慢了，可能导致NAT失效<br>
为了维持长连接，需要CPU定时发送心跳包。<br>
如果使用Timer定时器就会导致阻碍CPU进入休眠状态，很宽就会耗尽设备的电量<br>
在Android系统上推荐使用AlarmManager，AlarmManager 是系统封装的一个RTC的管理工具，RTC(Real Time Clock)是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。</p>
<h1 id="心跳包和轮询的区别">心跳包和轮询的区别</h1>
<p>心跳包和轮询看起来类似， 都是客户端主动联系服务器， 但是区别很大。</p>
<p>轮询是为了获取数据， 而心跳是为了保活TCP连接；<br>
轮询得越频繁， 获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系；<br>
轮询比心跳能耗更高， 因为一次轮询需要经过TCP三次握手， 四次挥手， 单次心跳不需要建立和拆除TCP连接。</p>
<h1 id="长连接是如何唤醒设备的">长连接是如何唤醒设备的：</h1>
<p>在设备休眠的时候是依然可以接受到推送的。如果服务器想客户端推送了信息，那么休眠状态下的设备是如何响应的呢，设备已经休眠了啊，要回答这个问题就需要对手机的硬件架构有一定的了解了。<br>
现在的移动设备的处理器一般包括两部分，一部分是AP(Application Processor)<br>
一部分是BP(BaseBand Processor)<br>
AP是用来运行操作系统和应用程序的<br>
BP是用来运行实时操作系统(RTOS)，通讯协议栈运行于BP的RTOS之上<br>
非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP，LCD，WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。</p>
<p>当设备收到数据包时，BP会唤醒AP，这样CPU接下来就会收到服务器发来的推送，然后就可以进行处理了。<br>
1:<a href="https://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/">https://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/</a><br>
2:<a href="http://www.52im.net/thread-341-1-1.html">http://www.52im.net/thread-341-1-1.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RxJava 1.0]]></title>
        <id>https://philadelphia.github.io/post/rxjava-10</id>
        <link href="https://philadelphia.github.io/post/rxjava-10">
        </link>
        <updated>2019-08-16T10:07:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="function">Function</h2>
<p>Function 是Action和Func的父接口。</p>
<pre><code>/**
 * All Func and Action interfaces extend from this.
 * &lt;p&gt;
 * Marker interface to allow instanceof checks.
 */
public interface Function {

}
</code></pre>
<h2 id="action">Action</h2>
<pre><code>/**
 * All Action interfaces extend from this.
 * &lt;p&gt;
 * Marker interface to allow instanceof checks.
 */
public interface Action extends Function {

}
</code></pre>
<p>Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；</p>
<p>Action 接口有以下子接口，<br>
Action1,Action2------Action9,ActionN</p>
<pre><code>public interface Action1&lt;T&gt; extends Action {
	void call(T t);
}

public interface Action2&lt;T1, T2&gt; extends Action {
	void call(T1 t1, T2 t2);
}

public interface ActionN extends Action {
	void call(Object... args);
}
</code></pre>
<h2 id="func">Func</h2>
<pre><code>Func接口几次Function接口和Callable接口，并复写Callable接口的call方法。
Func0接口没有参数，只有返回值，
Func1有一个参数，
Func2有两个参数。
.
.
.
Func9有9个参数，
以此类推，FuncN有N个参数


/**
 * Represents a function with zero arguments.
 */
public interface Func0&lt;R&gt; extends Function, Callable&lt;R&gt; {
	@Override
	R call();
}

/**
 * Represents a function with one argument.
 */
public interface Func1&lt;T, R&gt; extends Function {
	R call(T t);
}

/**
 * A vector-argument action.
 */
public interface Func9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; extends Function {
	R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
}
</code></pre>
<p>在创建Observable以后，我们可以通过Observable.subscribe(final Action1&lt;? super T&gt; onNext, final Action1<Throwable> onError, final Action0 onCompleted)</p>
<p>如果我们只传递onNext，onError和onComplete会使用系统默认的。</p>
<pre><code>public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }

    Action1&lt;Throwable&gt; onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;
    Action0 onCompleted = Actions.empty();
    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}

 public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    if (onError == null) {
        throw new IllegalArgumentException(&quot;onError can not be null&quot;);
    }

    Action0 onCompleted = Actions.empty();
    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}

public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    if (onError == null) {
        throw new IllegalArgumentException(&quot;onError can not be null&quot;);
    }
    if (onCompleted == null) {
        throw new IllegalArgumentException(&quot;onComplete can not be null&quot;);
    }

    return subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));
}
</code></pre>
<p>最终系统会将onNext,onError，onComplete，组合成一个ActionSubscriber，</p>
<pre><code>new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted)
/**
 * A Subscriber that forwards the onXXX method calls to callbacks.
 * @param &lt;T&gt; the value type
 */
	public final class ActionSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {

    final Action1&lt;? super T&gt; onNext;
    final Action1&lt;Throwable&gt; onError;
    final Action0 onCompleted;

    public ActionSubscriber(Action1&lt;? super T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted) {
        this.onNext = onNext;
        this.onError = onError;
        this.onCompleted = onCompleted;
    }

    @Override
    public void onNext(T t) {
        onNext.call(t);
    }

    @Override
    public void onError(Throwable e) {
        onError.call(e);
    }

    @Override
    public void onCompleted() {
        onCompleted.call();
    }
}
</code></pre>
<h2 id="observer">Observer</h2>
<pre><code>public interface Observer&lt;T&gt; {
	void onCompleted();

	void onError(Throwable e);

	void onNext(T t);
</code></pre>
<p>}</p>
<h2 id="subscriber">Subscriber</h2>
<p>Subscriber实现了Subscription接口，复写了其<code>unsubscribe</code>和<code>isUnsubscribed</code>方法。<br>
在<code>Observer</code>的基础上增加了<code>onStart</code>，<code>request</code>，<code>addToRequested</code>，<code>setProducer</code>方法。</p>
<pre><code>public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription{

    // represents requested not set yet
    private static final Long NOT_SET = Long.MIN_VALUE;

    private final SubscriptionList subscriptions;
    private final Subscriber&lt;?&gt; subscriber;
    /* protected by `this` */
    private Producer producer;
    /* protected by `this` */
    private long requested = NOT_SET; // default to not set

    protected Subscriber() {
        this(null, false);
    }


    protected Subscriber(Subscriber&lt;?&gt; subscriber) {
        this(subscriber, true);
    }

   
    protected Subscriber(Subscriber&lt;?&gt; subscriber, boolean shareSubscriptions) {
        this.subscriber = subscriber;
        this.subscriptions = shareSubscriptions &amp;&amp; subscriber != null ? subscriber.subscriptions : new SubscriptionList();
    }


    public final void add(Subscription s) {
        subscriptions.add(s);
    }

    @Override
    public final void unsubscribe() {
        subscriptions.unsubscribe();
    }


    @Override
    public final boolean isUnsubscribed() {
        return subscriptions.isUnsubscribed();
    }

    
    public void onStart() {
        // do nothing by default
    }
    
    
    protected final void request(long n) {
        if (n &lt; 0) {
            throw new IllegalArgumentException(&quot;number requested cannot be negative: &quot; + n);
        } 
        
        // if producer is set then we will request from it
        // otherwise we increase the requested count by n
        Producer producerToRequestFrom = null;
        synchronized (this) {
            if (producer != null) {
                producerToRequestFrom = producer;
            } else {
                addToRequested(n);
                return;
            }
        }
        // after releasing lock (we should not make requests holding a lock)
        producerToRequestFrom.request(n);
    }

    private void addToRequested(long n) {
        if (requested == NOT_SET) {
            requested = n;
        } else { 
            final long total = requested + n;
            // check if overflow occurred
            if (total &lt; 0) {
                requested = Long.MAX_VALUE;
            } else {
                requested = total;
            }
        }
    }
    
  
    public void setProducer(Producer p) {
        long toRequest;
        boolean passToSubscriber = false;
        synchronized (this) {
            toRequest = requested;
            producer = p;
            if (subscriber != null) {
                // middle operator ... we pass through unless a request has been made
                if (toRequest == NOT_SET) {
                    // we pass through to the next producer as nothing has been requested
                    passToSubscriber = true;
                }
            }
        }
        // do after releasing lock
        if (passToSubscriber) {
            subscriber.setProducer(producer);
        } else {
            // we execute the request with whatever has been requested (or Long.MAX_VALUE)
            if (toRequest == NOT_SET) {
                producer.request(Long.MAX_VALUE);
            } else {
                producer.request(toRequest);
            }
        }
    }
}
</code></pre>
<h2 id="observable-与observer建立绑定关系">Observable 与Observer建立绑定关系</h2>
<p>Observable.create().subscribe(new Observer)</p>
<pre><code>  public final Subscription subscribe(final Observer&lt;? super T&gt; observer) {
        if (observer instanceof Subscriber) {
            return subscribe((Subscriber&lt;? super T&gt;)observer);
        }
        return subscribe(new ObserverSubscriber&lt;T&gt;(observer));
    }
</code></pre>
<p>如果传入的直接是一个Subscriber对象的话，直接调用subscribe（Subscriber observer）<br>
否则调用subsribe(new ObserverSubscriber<T>(observer)),将observer构造成一个ObserverSubscriber对象传入。<br>
其实两者都是一样的。因为<code>ObserverSubscriber</code> 也是<code>Subscriber</code>的子类。</p>
<h2 id="observersubscriber">ObserverSubscriber</h2>
<pre><code>	/**
	 * Wraps an Observer and forwards the onXXX method calls to it.
	 * @param &lt;T&gt; the value type
	 */
	public final class ObserverSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {
    final Observer&lt;? super T&gt; observer;

    public ObserverSubscriber(Observer&lt;? super T&gt; observer) {
        this.observer = observer;
    }
    
    @Override
    public void onNext(T t) {
        observer.onNext(t);
    }
    
    @Override
    public void onError(Throwable e) {
        observer.onError(e);
    }
    
    @Override
    public void onCompleted() {
        observer.onCompleted();
    }
}
</code></pre>
<p>该类包裹了一个Observer对象。所有的实现其实是Observer对象来操作的。</p>
<pre><code>	 public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {
	        return Observable.subscribe(subscriber, this);
	    }



    static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
     // validate and proceed
        if (subscriber == null) {
            throw new IllegalArgumentException(&quot;observer can not be null&quot;);
        }
        if (observable.onSubscribe == null) {
            throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);
            /*
             * the subscribe function can also be overridden but generally that's not the appropriate approach
             * so I won't mention that in the exception
             */
        }
        
        // new Subscriber so onStart it
		先调用subscriber的onStart方法。
        subscriber.onStart();
        
        /*
         * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls
         * to user code from within an Observer&quot;
         */
        // if not already wrapped
        if (!(subscriber instanceof SafeSubscriber)) {
            // assign to `observer` so we return the protected version
            subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
        }

        // The code below is exactly the same an unsafeSubscribe but not used because it would 
        // add a significant depth to already huge call stacks.
        try {
            // allow the hook to intercept and/or decorate
            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
            return hook.onSubscribeReturn(subscriber);
        } catch (Throwable e) {
            // special handling for certain Throwable/Error/Exception types
            Exceptions.throwIfFatal(e);
            // in case the subscriber can't listen to exceptions anymore
            if (subscriber.isUnsubscribed()) {
                RxJavaPluginUtils.handleException(hook.onSubscribeError(e));
            } else {
                // if an unhandled error occurs executing the onSubscribe we will propagate it
                try {
                    subscriber.onError(hook.onSubscribeError(e));
                } catch (Throwable e2) {
                    Exceptions.throwIfFatal(e2);
                    // if this happens it means the onError itself failed (perhaps an invalid function implementation)
                    // so we are unable to propagate the error correctly and will just throw
                    RuntimeException r = new OnErrorFailedException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);
                    // TODO could the hook be the cause of the error in the on error handling.
                    hook.onSubscribeError(r);
                    // TODO why aren't we throwing the hook's return value.
                    throw r;
                }
            }
            return Subscriptions.unsubscribed();
        }
    }
</code></pre>
<p>该方法返回一个<code>Subscription</code>对象</p>
<h2 id="subscription">Subscription</h2>
<pre><code>	public interface Subscription {

    /**
     * Stops the receipt of notifications on the {@link Subscriber} that was registered when this Subscription
     * was received.
     * &lt;p&gt;
     * This allows unregistering an {@link Subscriber} before it has finished receiving all events (i.e. before
     * onCompleted is called).
     */
    void unsubscribe();

    /**
     * Indicates whether this {@code Subscription} is currently unsubscribed.
     *
     * @return {@code true} if this {@code Subscription} is currently unsubscribed, {@code false} otherwise
     */
    boolean isUnsubscribed();

}
</code></pre>
<p>该接口有两个方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit2.0简介]]></title>
        <id>https://philadelphia.github.io/post/retrofit20-jian-jie</id>
        <link href="https://philadelphia.github.io/post/retrofit20-jian-jie">
        </link>
        <updated>2019-08-16T10:07:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1定义">1.定义</h2>
<p>官方的Retrofit主页是这样描述它的</p>
<blockquote>
<p>A type-safe HTTP client for Android and Java</p>
</blockquote>
<blockquote>
<p>用于Android和Java的一个类型安全(type-safe)的REST客户端</p>
</blockquote>
<p>你可以使用注解去描述HTTP请求，同时Retrofit默认集成URL参数替换和查询参数.除此之外它还支持 Multipart请求和文件上传。</p>
<h2 id="2使用">2.使用</h2>
<p>注意这个任务是网络任务，不要忘记给程序加入网络权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies { 
 // Retrofit &amp;amp; OkHttp
compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
}
</code></pre>
<p><code>Retrofit</code> 需要最低<code>JDK 1.7</code> 和 <code>Android 2.3</code>.</p>
<p>retfofit 使用注解的方式定义API</p>
<p>方法类型有：</p>
<blockquote>
<p>GET, POST, PUT, DELETE, HEAD</p>
</blockquote>
<p>1	声明API</p>
<pre><code>public interface GitHubService {
  @GET(&quot;users/{user}/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}
</code></pre>
<p>2	初始化Retrofit</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com/&quot;)
.build();

GitHubService service = retrofit.create(GitHubService.class);
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);    
</code></pre>
<p>3	发起请求：</p>
<p>//同步请求</p>
<pre><code>try {
  Response&lt;List&lt;Repo&gt;&gt; bodyResponse = call.execute();
  String body = bodyResponse.body().string();//获取返回体的字符串
  Log.i(&quot;wxl&quot;, &quot;body=&quot; + body);
  } catch (IOException e) {
  e.printStackTrace();
  }
</code></pre>
<p>//异步请求</p>
<pre><code>call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {
            @Override
            public void onResponse(Response&lt;List&lt;Repo&gt;&gt; response) {
                try {
                    Log.i(&quot;wxl&quot;, &quot;response=&quot; + response.body().string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void onFailure(Throwable t) {
                Log.i(&quot;wxl&quot;, &quot;onFailure=&quot; + t.getMessage());
            }
        });
</code></pre>
<p>4 取消请求</p>
<pre><code>call.cancel();
</code></pre>
<p>所有的请求方法都是按照上述类型执行。<br>
在方法声明时注解@GET，@POST,@PUT 分别对应方法的类型。</p>
<p>接口参数</p>
<blockquote>
<p>Path</p>
</blockquote>
<p>ApiStores</p>
<pre><code> /**
 * Call&lt;T&gt; get();必须是这种形式,这是2.0之后的新形式
 * 如果不需要转换成Json数据,可以用了ResponseBody;
 * 你也可以使用Call&lt;GsonBean&gt; get();这样的话,需要添加Gson转换器
 */
public interface ApiStores {
    @GET(&quot;adat/sk/{cityId}.html&quot;)
    Call&lt;ResponseBody&gt; getWeather(@Path(&quot;cityId&quot;) String cityId);
}
</code></pre>
<blockquote>
<p>Query</p>
</blockquote>
<p>如果链接是http://ip.taobao.com/service/getIpInfo.php?ip=202.202.33.33</p>
<p>ApiStores</p>
<pre><code>public interface ApiStores {
	@GET(&quot;http://ip.taobao.com/service/getIpInfo.php&quot;)
	Call&lt;ResponseBody&gt; getWeather(@Query(&quot;ip&quot;) String ip);
</code></pre>
<p>复杂的查询参数也可以使用Map。</p>
<pre><code>@GET(&quot;group/{id}/users&quot;)
Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options);
</code></pre>
<blockquote>
<p>Headers</p>
</blockquote>
<p>你可以通过@Headers参数来设置静态headers</p>
<pre><code>@Headers(&quot;Cache-Control: max-age=640000&quot;)
@GET(&quot;widget/list&quot;)
Call&lt;List&lt;Widget&gt;&gt; widgetList();

@Headers({
    &quot;Accept: application/vnd.github.v3.full+json&quot;,
    &quot;User-Agent: Retrofit-Sample-App&quot;
})
@GET(&quot;users/{username}&quot;)
Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username);
</code></pre>
<p><code>Headers</code>不复写其他的<code>Headers</code>值。所有同名的的<code>Headers</code>参数都将包含在该请求中。<br>
Request的Header可以通过使用<code>@Header</code>注解动态更新。必须给<code>@Header</code>提供一个相应的参数。如果该值为空，该<code>Header</code>就被忽略了。不然就会调用value的<code>toString()</code>方法获得value的值。</p>
<pre><code>@GET(&quot;user&quot;)
Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)
</code></pre>
<p>每一个request都有的header可以通过设置<code>OkHttp interceptor</code>来统一添加。</p>
<blockquote>
<p>Body</p>
</blockquote>
<p>这是针对POST方式，如果参数是json格式，如：</p>
<pre><code>{		
    &quot;apiInfo&quot;: {		
        &quot;apiName&quot;: &quot;WuXiaolong&quot;,		
        &quot;apiKey&quot;: &quot;666&quot;		
    }		
}
</code></pre>
<p>ApiStores</p>
<pre><code>public interface ApiStores {
    @POST(&quot;client/shipper/getCarType&quot;)
    Call&lt;ResponseBody&gt; getCarType(@Body ApiInfo apiInfo);
   }
</code></pre>
<p>这个<code>Object</code>将被<code>Retrofit</code>对象所指定的<code>Converter</code>所转换，如果没有指定转换器，只能使用<code>RequestBody</code>来定义参数。</p>
<p>建立Bean</p>
<pre><code>public class ApiInfo {
       private ApiInfoBean apiInfo;
       public ApiInfoBean getApiInfo() {
           return apiInfo;
       }
       public void setApiInfo(ApiInfoBean apiInfo) {
           this.apiInfo = apiInfo;
       }
       public class ApiInfoBean {
           private String apiName;
           private String apiKey;
           //省略get和set方法
       }
   }
</code></pre>
<p>代码调用</p>
<pre><code>private void getCarType() {
   mRetrofit = new Retrofit.Builder()
           .baseUrl(&quot;http://WuXiaolong.me/&quot;)
           .addConverterFactory(GsonConverterFactory.create())
           .build();
   ApiStores apiStores = mRetrofit.create(ApiStores.class);
   ApiInfo apiInfo = new ApiInfo();
   ApiInfo.ApiInfoBean apiInfoBean = apiInfo.new ApiInfoBean();
   apiInfoBean.setApiKey(&quot;666&quot;);
   apiInfoBean.setApiName(&quot;WuXiaolong&quot;);
   apiInfo.setApiInfo(apiInfoBean);
   Call&lt;ResponseBody&gt; call = apiStores.getCarType(apiInfo);
   call.enqueue(new Callback&lt;ResponseBody&gt;() {
       @Override
       public void onResponse(Response&lt;ResponseBody&gt; response) {
           String body = null;//获取返回体的字符串
           try {
               body = response.body().string();
           } catch (IOException e) {
               e.printStackTrace();
           }
           Log.i(&quot;wxl&quot;, &quot;get=&quot; + body);
       }
       @Override
       public void onFailure( Throwable t) {
       }
   });
   }
</code></pre>
<blockquote>
<p>Url encode</p>
</blockquote>
<p>POST or PUT Url encode 過的表單資料，用@FormUrlEncoded，使用@Field個別指定</p>
<pre><code>@POST(&quot;/articles/{article_id}/comments&quot;)
@FormUrlEncoded
Comment create(
@Path(&quot;article_id&quot;) int articleId,
@Field(&quot;rating&quot;) int rating,
@Field(&quot;content&quot;) String content
);
</code></pre>
<p>POST or PUT Url encode 過的表單資料，用@FormUrlEncoded，參數也可用@Body傳</p>
<pre><code>@POST(&quot;/articles/{article_id}/comments&quot;)
@FormUrlEncoded
Comment create(
    @Path(&quot;article_id&quot;) int articleId,
    @Body Comment comment
);
</code></pre>
<blockquote>
<p>POST or PUT 用@Multipart來上傳檔案</p>
</blockquote>
<pre><code>@PUT(&quot;/me&quot;)
@Multipart
Me update(
    @Part(&quot;display_name&quot;) String displayName,
    @Part(&quot;avatar&quot;) TypedFile avatar
);
</code></pre>
<p>更详细的信息，请点击：<a href="http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/">http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/</a></p>
<p>更多更有效的 Converters</p>
<blockquote>
<p>默认情况下，<code>Retrofit</code> 只能反序列化<code>HTTP</code> body到<code>OKHTTP</code>的<code>ResponseBody</code>类型。并且<code>OKHTTP</code>只接受<code>Retrifit</code> <code>@Body</code>类型的<code>RequestBody</code><br>
可以添加<code>Converter</code>转换器来支持其他的类型，6个相似的兼容流行的序列化库模块可以供使用。</p>
</blockquote>
<pre><code>Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson	
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml	
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
</code></pre>
<p>例子:</p>
<pre><code>interface which uses Gson for its deserialization.

Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com&quot;)
    .addConverterFactory(GsonConverterFactory.create())
    .build();

GitHubService service = retrofit.create(GitHubService.class);
</code></pre>
<blockquote>
<p>Retrofit 1 里有一个 converter 的问题。多数人可能没遇到过，是库内部的一个问题。在 Retrofit 2 里，已经解决了这个问题，同时开始支持多种 Converter 并存。</p>
</blockquote>
<blockquote>
<p>在之前，如果你遇到这种情况：一个 API 请求返回的结果需要通过 JSON 反序列化，另一个 API 请求需要通过 proto 反序列化，唯一的解决方&gt;案就是将两个接口分离开声明。</p>
</blockquote>
<pre><code>interface SomeProtoService {
  @GET(&quot;/some/proto/endpoint&quot;)
  Call&lt;SomeProtoResponse&gt; someProtoEndpoint();
}

interface SomeJsonService {
  @GET(&quot;/some/json/endpoint&quot;)
  Call&lt;SomeJsonResponse&gt; someJsonEndpoint();
</code></pre>
<blockquote>
<p>之所以搞得这么麻烦是因为一个 REST adapter 只能绑定一个 Converter 对象。我们费工夫去解决这个是因为：接口的声明是要语意化的。API 接口应该通过功能实现分组，比如： account 的接口，user 的接口，或者 Twitter 相关的接口。返回格式的差异不应该成为你分组时候的阻碍。</p>
</blockquote>
<blockquote>
<p>现在，你可以把他们都放在一起了：</p>
</blockquote>
<pre><code>interface SomeService {
  @GET(&quot;/some/proto/endpoint&quot;)
  Call&lt;SomeProtoResponse&gt; someProtoEndpoint();

  @GET(&quot;/some/json/endpoint&quot;)
  Call&lt;SomeJsonResponse&gt; someJsonEndpoint();
}
</code></pre>
<blockquote>
<p>SomeProtoResponse —&gt; Proto? Yes!</p>
</blockquote>
<blockquote>
<p>原理很简单，其实就是对着每一个 converter 询问他们是否能够处理某种类型。我们问 proto 的 converter： “Hi, 你能处理 SomeProtoResponse 吗？”，然后它尽可能的去判断它是否可以处理这种类型。我们都知道：Protobuff 都是从一个名叫 message 或者 message lite 的类继承而来。所以，判断方法通常就是检查这个类是否继承自 message。<br>
在面对 JSON 类型的时候，首先问 proto converter，proto converter 会发现这个不是继承子 Message 的，然后回复 no。紧接着移到下一个 JSON converter 上。JSON Converter 会回复说我可以！</p>
</blockquote>
<blockquote>
<p>SomeJsonResponse —&gt; Proto? No! —&gt; JSON? Yes!</p>
</blockquote>
<blockquote>
<p>因为 JSON 并没有什么继承上的约束。所以我们无法通过什么确切的条件来判断一个对象是否是 JSON 对象。以至于 JSON 的 converters 会对任何数据都回复说：我可以处理！这个一定要记住， JSON converter 一定要放在最后，不然会和你的预期不符。</p>
<p>另一个要注意的是，现在已经不提供默认的 converter 了。如果不显性的声明一个可用的 Converter 的话，Retrofit 是会报错的：提醒你没有可用的 Converter。因为核心代码已经不依赖序列化相关的第三方库了，我们依然提供对 Converter 的支持，不过你需要自己引入这些依赖，同时显性的声明 Retrofit 需要用的 Converter 有哪些。<br>
添加 converter 的顺序很重要。按照这个顺序，我们将依次询问每一个 converter 能否处理一个类型。我上面写的其实是错的。如果我们试图反序列化一个 proto 格式，它其实会被当做 JSON 来对待。这显然不是我们想要的。我们需要调整下顺序，因为我们先要检查 proto buffer 格式，然后才是 JSON。</p>
</blockquote>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com&quot;)
.addConverterFactory(ProtoConverterFactory.create())
.addConverterFactory(GsonConverterFactory.create())
.build();
</code></pre>
<blockquote>
<p>由于现在Retrofit开始依赖 OkHttp， 并没有 Http Client 层的抽象。现在是可以传递一个配置好的 OkHttp 实例的。比如：配置 interceptors, 或者一个 SSL socket 工厂类， 或者 timeouts 的具体数值。 （OkHttp 有默认的超时机制，如果你不需要自定义，实际上不&gt;必进行任何设置，但是如果你想要去设置它们，下面是一个例子告诉你来怎么操作。）</p>
</blockquote>
<pre><code> OkHttpClient client = new OkHttpClient.Builder()
            .retryOnConnectionFailure(true)			//失败后是否重试
            .connectTimeout(15, TimeUnit.SECONDS)	//设置连接超时时间
            .addInterceptor(getHttpInterceptor())	//设置应用拦截器
            .build();

Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com&quot;)	//设置BaseURL
    .client(client)						//设置client
    .build();
</code></pre>
<h2 id="3-interceptor">3 Interceptor</h2>
<blockquote>
<p>在使用Android retrofit+rxjava时，想获知网络请求的一些参数，方便调试，比如：请求地址、请求响应时间、请求响应消息体等内容，虽然部分可以通过每个接口进行获知，但是这样极其不方便，可以使用拦截器来做统一的操作。</p>
</blockquote>
<p>添加拦截器：<br>
可以针对OkHttpClient.Builder 添加拦截器</p>
<pre><code>HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);	//设置日志级别

OkHttpClient client = new OkHttpClient.Builder()
            .retryOnConnectionFailure(true)			//失败后是否重试
            .connectTimeout(15, TimeUnit.SECONDS)	//设置连接超时时间
            .addInterceptor(interceptor)	//设置应用拦截器
            .build();
</code></pre>
<h2 id="4cache">4.Cache</h2>
<blockquote>
<p>开启OKHttp缓存：</p>
</blockquote>
<p>先获取系统外部存储的路径，”xxx”可以自己命名，缓存文件就存在 Android/data/&lt;包名&gt;/cache/resposes。</p>
<pre><code>File httpCacheDirectory = new File(UIUtils.getContext().getExternalCacheDir(), &quot;xxx&quot;); 
client.setCache(new Cache(httpCacheDirectory,10 * 1024 * 1024));
</code></pre>
<h2 id="5proguard">5.Proguard</h2>
<blockquote>
<p>如果你在你的代码里使用代码混淆机制,请在你的配置里添加下面几行.</p>
</blockquote>
<pre><code># Platform calls Class.forName on types which do not exist on Android to determine platform.
-dontnote retrofit2.Platform
# Platform used when running on RoboVM on iOS. Will not be used at runtime.
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
# Platform used when running on Java 8 VMs. Will not be used at runtime.
-dontwarn retrofit2.Platform$Java8
# Retain generic type information for use by reflection by converters and adapters.
-keepattributes Signature
# Retain declared checked exceptions for use by a Proxy instance.
-keepattributes Exceptions
</code></pre>
<h2 id="6-nitoice">6 Nitoice</h2>
<blockquote>
<p>Retrofit 在请求失败时依然会回调 <code>onResponse()</code>方法。及时response code不是200依然会回调一下方法，需要注意。</p>
</blockquote>
<pre><code> public void onResponse(Call&lt;LoginResult&gt; call, Response&lt;LoginResult&gt; response) {
	 
}
</code></pre>
<h2 id="7references">7:References</h2>
<ol>
<li>
<p>Retrofit github主页：<a href="https://square.github.io/retrofit/" title="retrofit github 主页">https://square.github.io/retrofit/</a></p>
</li>
<li>
<p>Interceptor wiki:	<a href="https://github.com/square/okhttp/wiki/Interceptors" title="retrofit interceptor">https://github.com/square/okhttp/wiki/Interceptors</a></p>
</li>
<li>
<p>用 Retrofit 2 简化 HTTP 请求	<a href="https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/"> https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/</a></p>
</li>
<li>
<p>Http Caching:		<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" title="Http Cache">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p>
</li>
<li>
<p>四种常见的 POST 提交数据方式		<a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" title="四种常见的 POST 提交数据方式">https://imququ.com/post/four-ways-to-post-data-in-http.html</a></p>
</li>
<li>
<p>Blog				 <a href="http://wuxiaolong.me/2016/01/15/retrofit/" title="Blog"> http://wuxiaolong.me/2016/01/15/retrofit/</a></p>
</li>
<li>
<p>URL wikipedia: 		<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" title="URL wikipedia: ">https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6</a></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit: 几种ApiService接口定义的区别]]></title>
        <id>https://philadelphia.github.io/post/retrofit-ji-chong-apiservice-jie-kou-ding-yi-de-qu-bie</id>
        <link href="https://philadelphia.github.io/post/retrofit-ji-chong-apiservice-jie-kou-ding-yi-de-qu-bie">
        </link>
        <updated>2019-08-16T10:06:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="retrofit声明-apiservice接口">Retrofit:声明 ApiService接口</h1>
<p>我们在使用Retrofit的时候只需要把URL通过注解的形式写到APIService文件中就行了。<br>
比如登录功能：</p>
<p>如果后台的成功返回格式为</p>
<pre><code>{	
	code:0;
	Message:&quot;login success&quot;
}
</code></pre>
<p>失败的返回格式为</p>
<pre><code>{	
	code:-1;
	Message:&quot;login failed&quot;
}
</code></pre>
<p>我们定义个一个Bean类LoginResult.</p>
<pre><code>public class LoginResult{
	private int code;
	private String message;
	
	//get/set
}


</code></pre>
<h2 id="不使用rxjava">不使用Rxjava</h2>
<p>在方法的定义中，如果不适用Rxjava的话，</p>
<pre><code>@Post
@FormUrlEncoded
Call&lt;LogInResult&gt; login(@Field(&quot;userName&quot;) String userName, @Field(&quot;password&quot;)String password);
</code></pre>
<p>在使用的时候们只需要使用apiService.login(&quot;dsf&quot;, &quot;dsf&quot;),就好了。该方法会返回一个Call<LoginResult> 对象</p>
<p>我们只需要或者异步执行</p>
<pre><code>//同步执行
Response&lt;LoginResult&gt; response = call.execute();
//异步调用
call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {

            }
        });
</code></pre>
<p>然后我们在返回结果里面操作就行了，如果我们需要Response里面的元数据，比如header里面的信息的话，直接从Response取就好了。</p>
<p>因为Retrofit 使用DefaultCallAdapterFactory默认将OKHttp返回的Call对象(OkHttp对象)转换成了Retrofit的Call<T>对象了</p>
<h2 id="使用rxajva">使用Rxajva</h2>
<h3 id="observablet">Observable<T></h3>
<p>但是我们在使用RxJava后，有时可能会这样声明接口</p>
<pre><code>@Post
@FormUrlEncoded
Observable&lt;LogInResult&gt; login(@Field(&quot;userName&quot;) String userName, @Field(&quot;password&quot;)String password);
</code></pre>
<p>这样定义可以很方便的在返回中直接subScribe一个Action对象了</p>
<pre><code>Observable&lt;LoginResult&gt; observable = model.login(&quot;dfs&quot;, &quot;dfs&quot;);
observable.subscribe(new Action1&lt;LoginResult&gt;() {
            @Override
            public void call(LoginResult loginResult) {
								if (loginResult.getCode() == 0) {
                    //登录成功   
                } else {
                    //登录失败
                }
					
            }
        });
</code></pre>
<p>但是这样有一个问题就是会丢失Response的元数据，因为Response对象我们是没法访问的。因为Retrofit已经帮助我们做了转换，直接把我们接口方法里定义的数据类型转换好后返回给我们了。去掉了Response信息。</p>
<h3 id="observableresponset">Observable&lt;Response<T>&gt;</h3>
<p>我们可以这么定义接口</p>
<pre><code>@Post
@FormUrlEncoded
Observable&lt;Response&lt;LogInResult&gt;&gt; login(@Field(&quot;userName&quot;) String userName, @Field(&quot;password&quot;)String password);
</code></pre>
<p>这样我们就得到这样的返回结果。</p>
<pre><code class="language-java">Observable&lt;Response&lt;LoginResult&gt;&gt; observable = model.login(&quot;dfs&quot;, &quot;dfs&quot;);
observable.subscribe(new Action1&lt;Response&lt;LoginResult&gt;&gt;() {
            @Override
            public void call(Response&lt;LoginResult&gt; loginResultResponse) {
                if (loginResultResponse.code() == 200){
                    LoginResult body = loginResultResponse.body();
                }else {
                    //登录失败
                }
            }
        });
</code></pre>
<p>这样就能拿到Response信息了，然后根据Response code判断是否登录成功了。</p>
<p>但是这样有个问题是我们写接口会特备繁琐，每次都得使用Response&lt;&gt;泛型。一般我们都写作Observable<LoginResult> login();</p>
<p>其实我们一般情况下也不关注Response信息的。但是不排除特殊情况</p>
<p>比如这种情况<br>
https://academy.realm.io/cn/posts/droidcon-jake-wharton-simple-http-retrofit-2/</p>
<p>这篇文章提到的分页加载的情况，其实这种情况也可以将下一个页面的URL放到Response body里返回。</p>
<p>这里只是给出了一种情景。</p>
<p>现实中解决方案很多种，只能折中了，其实我们没必要使用Response的Response code 来判断接口是否调用成功了。因为Retrofit都帮我们做过了。所以我们定义接口的时候只要使用Observable<Response>就好了。</p>
<p>我们在使用Retrofit + Rxjava 的时候一般都这么生成Retrofit client的</p>
<pre><code> Retrofit retrofit = new Retrofit.Builder()
                .client(okHttpClient)
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .baseUrl(baseUrl)
                .build();
</code></pre>
<p>这里RxJavaCallAdapterFactory生成的CallAdapter对象就帮我们做好了结果的转换</p>
<p>我们看一下RxJavaCallAdapterFactory的声明。</p>
<pre><code>	/**
 * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
 * &lt;p&gt;
 * Adding this class to {@link Retrofit} allows you to return {@link Observable} from service
 * methods.
 * &lt;pre&gt;&lt;code&gt;
 * interface MyService {
 *   &amp;#64;GET(&quot;user/me&quot;)
 *   Observable&amp;lt;User&amp;gt; getUser()
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 * There are three configurations supported for the {@code Observable} type parameter:
 有三种配置支持Observable的类型参数
 * &lt;ul&gt;
 * &lt;li&gt;Direct body (e.g., {@code Observable&lt;User&gt;}) calls {@code onNext} with the deserialized body
 * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
 * {@link IOException} for network errors.&lt;/li&gt;
 第一种：直接使用Observable&lt;T&gt;声明接口, 将会针对所有的2** Response code会调用onNext(T t)方法。所有的Response code 不是200的都调用OnError(Throwable t)方法抛出一个HttpException 异常，网络错误调用onError()方法，并抛出一个IO异常。
 
 * &lt;li&gt;Response wrapped body (e.g., {@code Observable&lt;Response&lt;User&gt;&gt;}) calls {@code onNext}
 * with a {@link Response} object for all HTTP responses and calls {@code onError} with
 * {@link IOException} for network errors&lt;/li&gt;
 //第二种:如果使用Observable&lt;Response&lt;T&gt;&gt;声明接口，那么针对所有的Response将会调用onNext(Respones&lt;T&gt; response)方法，针对网络异常将调用OnError()方法，并抛出一个IO异常。
 * &lt;li&gt;Result wrapped body (e.g., {@code Observable&lt;Result&lt;User&gt;&gt;}) calls {@code onNext} with a
 * {@link Result} object for all HTTP responses and errors.&lt;/li&gt;
 //第三种：如果使用Observable&lt;Result&lt;T&gt;声明接口。所有的Response和Error将会调用onNext方法。
 注意：这个Result是Retrofit提供的。
 * &lt;/ul&gt;
 */
 
</code></pre>
<h2 id="结论">结论</h2>
<p>结论就是，如果我们没有对Response有特殊的需求的话，直接在接口声明处直接声明成Observable<T>是最方便最直观的。</p>
<h2 id="另外">另外</h2>
<p>如果已经存在这样的接口定义了，在没有API可用的情况下，我们需要在mock数据的时候，比如我们需要Observer<LoginResult> 的observable。<br>
我们可以这样mock数据</p>
<pre><code>LoginResult loginResult = new LoginResult();
loginResult.setCode(0);
loginResult.setMessage(&quot;登录成功&quot;);
Observable&lt;LoginResult&gt; just1 = Observable.just(loginResult);
</code></pre>
<p>而如果我们定义的是Observable&lt;Response<LoginResult>&gt; login()时我们需要返回这样的Observable</p>
<pre><code>Response&lt;LoginResponse&gt; loginResponseResponse = Response.success(loginResult);
Observable&lt;Response&lt;LoginResponse&gt;&gt; just2 = Observable.just(loginResponseResponse);	
</code></pre>
<p>这样就可以mock对应的数据了</p>
<p>这篇文章本应该和Retofit源码分析一起写的，奈何Retrofit的源码实在是太晦涩难懂了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit 源码分析]]></title>
        <id>https://philadelphia.github.io/post/retrofit-yuan-ma-fen-xi</id>
        <link href="https://philadelphia.github.io/post/retrofit-yuan-ma-fen-xi">
        </link>
        <updated>2019-08-16T10:06:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>retrofit是square出品的一个优秀的网络框架，注意，不是一个网络引擎。它的定位和Volley是一样的。</p>
<p>它完成了封装请求，线程切换，数据装换等一系列工作，如果自己有能力也可以封装一个这种框架，本质上是没有区别的。</p>
<p>retrofit使用的网络引擎是OkHttp.</p>
<p>而OKHttp和HTTPClient，HttpUrlConnection是一个级别的。</p>
<p>#使用</p>
<pre><code class="language-java">//1 创建网络请求接口类
public interface GitHubService {
  @GET(&quot;users/{user}/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}

//2 创建Retrofit实例对象
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
     .addConverterFactory(GsonConverterFactory.create())
     .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
    .build();

//3 通过动态代理创建网络接口代理对象
GitHubService service = retrofit.create(GitHubService.class);

//4 获取Call对象
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);

//5	执行同步请求或异步请求
repos.execute();
repos.enqueue(callback)
</code></pre>
<h1 id="retrofit">Retrofit</h1>
<p>Retrofit也是使用Build模式创建的。</p>
<p>![屏幕快照 2019-01-11 下午3.12.35](/Users/meiliwu/Desktop/屏幕快照 2019-01-11 下午3.12.35.png)</p>
<p>builder类有这些方法。从图表可以看出，我们可以调用client方法传入一个我们自定义的OkhttpClient,</p>
<p>调用baseUrl方法传入Host,最后调动build方法生成一个Retrofit 对象</p>
<pre><code class="language-java">public Retrofit build() {
    //baseUrl是必须的
  if (baseUrl == null) {
    throw new IllegalStateException(&quot;Base URL required.&quot;);
  }

   //如果没有设置callFactory对象，系统自动生成一个OkhttpClient对象.因为OKHttpclient实现了			Call.Factory接口
   // public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory
  okhttp3.Call.Factory callFactory = this.callFactory;
  if (callFactory == null) {
    callFactory = new OkHttpClient();
  }

  //如果没有设置callbackExecutor，系统自动生成一个，platform.defaultCallbackExecutor，这个platform是无参构造方法里调用Platform.get()方法得到的。
    /** 
    public Builder() {
      this(Platform.get());
    }**/
    
  Executor callbackExecutor = this.callbackExecutor;
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  // Make a defensive copy of the adapters and add the default Call adapter.
  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

  // Make a defensive copy of the converters.
  List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

  return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
      callbackExecutor, validateEagerly);
}
</code></pre>
<h1 id="platform">Platform</h1>
<pre><code class="language-java">class Platform {
  private static final Platform PLATFORM = findPlatform();

  static Platform get() {
    return PLATFORM;
  }

  private static Platform findPlatform() {
    try {
      Class.forName(&quot;android.os.Build&quot;);
      if (Build.VERSION.SDK_INT != 0) {
        return new Android();
      }
    } catch (ClassNotFoundException ignored) {
    }
    try {
      Class.forName(&quot;java.util.Optional&quot;);
      return new Java8();
    } catch (ClassNotFoundException ignored) {
    }
    try {
        //怎么还有IOS代码呢？
      Class.forName(&quot;org.robovm.apple.foundation.NSObject&quot;);
      return new IOS();
    } catch (ClassNotFoundException ignored) {
    }
    return new Platform();
  }

  Executor defaultCallbackExecutor() {
    return null;
  }

  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
    if (callbackExecutor != null) {
      return new ExecutorCallAdapterFactory(callbackExecutor);
    }
    return DefaultCallAdapterFactory.INSTANCE;
  }

  boolean isDefaultMethod(Method method) {
    return false;
  }

  Object invokeDefaultMethod(Method method, Class&lt;?&gt; declaringClass, Object object, Object... args)
      throws Throwable {
    throw new UnsupportedOperationException();
  }

  static class Android extends Platform {
    @Override public Executor defaultCallbackExecutor() {
      return new MainThreadExecutor();
    }

    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
      return new ExecutorCallAdapterFactory(callbackExecutor);
    }

    static class MainThreadExecutor implements Executor {
      private final Handler handler = new Handler(Looper.getMainLooper());

      @Override public void execute(Runnable r) {
        handler.post(r);
      }
    }
  }
}
</code></pre>
<p>Retrofit 要求必须将请求API写到一个interface接口文件里，这是动态代理特性要求的。</p>
<p>从接口文件里我们可以看到，我们将每个请求用这种形式表达</p>
<pre><code class="language-Java">public interface GitHubService {
	@GET(&quot;users/{user}/repos&quot;)
	Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
}		

</code></pre>
<p>从接口文件我们可以看出，一个请求接口被各种注解所表示。</p>
<p>我们知道一个方法有一下关键字段组成</p>
<p>首先一个方法必须有描述符，返回值，方法名，参数类型，参数构成。</p>
<p>那我们用一个方法表示一个http请求需要哪些东西呢？</p>
<p>Http请求，首先我们得知道是GET请求还是POST请求，</p>
<p>然后就是请求头信息，请求路径，查询参数等等。</p>
<p>POST请求还需要Body。</p>
<p>Retrofit 已经提供了足够的注解来表示一个方法。</p>
<p>Retrofit的核心思想AOP，面向切面变成，通过动态代理的反射，将接口文件里的每个方法记性处理，也就是分析该方法的注解生成一个ServiceMethod类。</p>
<p>Retrofit 里有个关键的类，ServiceMethod</p>
<pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety.
public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service);
  if (validateEagerly) {
    eagerlyValidateMethods(service);
  }
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
        private final Platform platform = Platform.get();

        @Override public Object invoke(Object proxy, Method method, Object... args)
            throws Throwable {
          // If the method is a method from Object then defer to normal invocation.
          if (method.getDeclaringClass() == Object.class) {
            return method.invoke(this, args);
          }
          if (platform.isDefaultMethod(method)) {
            return platform.invokeDefaultMethod(method, service, proxy, args);
          }
            //创建ServiceMethod对象
          ServiceMethod serviceMethod = loadServiceMethod(method);
          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
          return serviceMethod.callAdapter.adapt(okHttpCall);
        }
      });
}
</code></pre>
<p>从第3步我们可以看出create方法的实现就是使用了动态代理，在运行时生成了GitHubService对象。</p>
<p>//创建ServiceMethod对象<br>
ServiceMethod serviceMethod = loadServiceMethod(method);</p>
<pre><code class="language-java">ServiceMethod loadServiceMethod(Method method) {
  ServiceMethod result;
  synchronized (serviceMethodCache) {
  //先从换从中取改方法对应的ServiceMethod对象，如果为null就构建一个ServiceMethod对象并存入到map中，如果不为null直接返回
    result = serviceMethodCache.get(method);
    if (result == null) {
      result = new ServiceMethod.Builder(this, method).build();
      serviceMethodCache.put(method, result);
    }
  }
  return result;
}
</code></pre>
<p>我们可以看到loadServiceMethod(Method method)方法返回了一个ServiceMethod对象<br>
这个serviceMethodCache对象是Retrofit的一个字段，是一个Map集合。</p>
<p><code>private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</code></p>
<p>将接口文件里每个方法转换为一个ServiceMethod对象后放入改map中作为缓存，下次调用该方法后就不用再次解析改方法对象了，直接从改map里去以方法为key去取对应的ServiceMethod就行了。666</p>
<p>接下来看一下ServiceMethod对象的构造</p>
<h1 id="servicemethod">ServiceMethod</h1>
<pre><code class="language-java">final class ServiceMethod&lt;T&gt; {
  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
  static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;
  static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\{(&quot; + PARAM + &quot;)\\}&quot;);
  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);

  final okhttp3.Call.Factory callFactory;
  final CallAdapter&lt;?&gt; callAdapter;

  private final HttpUrl baseUrl; 主机地址
  private final Converter&lt;ResponseBody, T&gt; responseConverter;
  private final String httpMethod; 
  private final String relativeUrl; 相对路径
  private final Headers headers;    请求头部信息
  private final MediaType contentType; 请求参数类型
  private final boolean hasBody;  是否有请求体
  private final boolean isFormEncoded; 是否是格式化的表单
  private final boolean isMultipart; 是不是分块
  private final ParameterHandler&lt;?&gt;[] parameterHandlers;

  ServiceMethod(Builder&lt;T&gt; builder) {
    this.callFactory = builder.retrofit.callFactory();
    this.callAdapter = builder.callAdapter;
    this.baseUrl = builder.retrofit.baseUrl();
    this.responseConverter = builder.responseConverter;
    this.httpMethod = builder.httpMethod;
    this.relativeUrl = builder.relativeUrl;
    this.headers = builder.headers;
    this.contentType = builder.contentType;
    this.hasBody = builder.hasBody;
    this.isFormEncoded = builder.isFormEncoded;
    this.isMultipart = builder.isMultipart;
    this.parameterHandlers = builder.parameterHandlers;
  }
}
</code></pre>
<p>ServiceMethod是采用Builder模式创建的。</p>
<pre><code class="language-java">static final class Builder&lt;T&gt; {
  final Retrofit retrofit;
  final Method method; 		//接口里生命的方法
  final Annotation[] methodAnnotations;  //方法的注解，get/post/header之类的
  final Annotation[][] parameterAnnotationsArray; //方法的参数注解数组，二维数组
  final Type[] parameterTypes;  //方法的参数数组

  Type responseType;
  boolean gotField;
  boolean gotPart;
  boolean gotBody;
  boolean gotPath;
  boolean gotQuery;
  boolean gotUrl;
  String httpMethod;
  boolean hasBody;
  boolean isFormEncoded;
  boolean isMultipart;
  String relativeUrl;
  Headers headers;
  MediaType contentType;
  Set&lt;String&gt; relativeUrlParamNames;
  ParameterHandler&lt;?&gt;[] parameterHandlers;
  Converter&lt;ResponseBody, T&gt; responseConverter;
  CallAdapter&lt;?&gt; callAdapter;

  public Builder(Retrofit retrofit, Method method) {
    this.retrofit = retrofit;
    this.method = method;
    this.methodAnnotations = method.getAnnotations(); //获取方法的注解
    this.parameterTypes = method.getGenericParameterTypes(); //获取被注解修饰的方法，一个数组
    this.parameterAnnotationsArray = method.getParameterAnnotations(); //获取方法的参数注解信息，是一个二维数组
  }
</code></pre>
<p>Builder的构造参数需要一个Retrofit对象和一个Method对象。</p>
<p>首先解析方法对象，将其注解和参数注解放到对应的数组里。</p>
<p>首先在构造方法里获取该方法的注解,方法的参数，以及每个参数的注解。</p>
<p>关键就在build方法，在build方法里对方法做了一个彻底的分解</p>
<pre><code class="language-java">public ServiceMethod build() {
  //1 处理返回结果，做一定的转换
  callAdapter = createCallAdapter();
  responseType = callAdapter.responseType();
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;'&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;' is not a valid response body type. Did you mean ResponseBody?&quot;);
  }
  responseConverter = createResponseConverter();

    //2提取方法的注解
  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }
	//如果httpMethod为null，即没有使用方法类型注解修饰，抛出异常进行提示
  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }
//如果没有请求体，即使用了GET，HEAD，DELETE，OPTIONS等所修饰，即不涉及到表单的提交，但是同时使用了Multipart，或者FormUrlEncoded所修饰，就报错
  if (!hasBody) {
    if (isMultipart) {
      throw methodError(
          &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);
    }
    if (isFormEncoded) {
      throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;
          + &quot;request body (e.g., @POST).&quot;);
    }
  }

  //3提取方法的参数
  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  //相对路径为null且gotURL为false的话，抛出异常，因为没有相对路径无法请求。
  if (relativeUrl == null &amp;&amp; !gotUrl) {
    throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);
  }
  //没有使用@FormUrlEncoded，@Multipart主机并且hasBody为false，但是gotBody为true，抛出异常，提示
    Non-Body类型的HTTP method 不能参数不能使用@Body注解
  if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) {
    throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);
  }
  //使用@FormUrlEncoded修饰的方法中的参数至少有一个参数被@Field注解修饰
  if (isFormEncoded &amp;&amp; !gotField) {
    throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);
  }
    
  //使用@Multipart修饰的方法中的参数至少有一个参数被@Part注解修饰
  if (isMultipart &amp;&amp; !gotPart) {
    throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);
  }

 //4 当前Builder对象初始化完毕，可以用来够着ServiceMethod对象。
  return new ServiceMethod&lt;&gt;(this);
}
</code></pre>
<h2 id="处理返回结果">处理返回结果</h2>
<pre><code class="language-java">private CallAdapter&lt;?&gt; createCallAdapter() {
  //获取方法的返回结果,如果有不能解析的类型则抛出异常，也就是说接口中定义的方法的返回值不能使用泛型
  Type returnType = method.getGenericReturnType();
  if (Utils.hasUnresolvableType(returnType)) {
    throw methodError(
        &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
  }
   //接口里的方法不能返回void
  if (returnType == void.class) {
    throw methodError(&quot;Service methods cannot return void.&quot;);
  }
  Annotation[] annotations = method.getAnnotations();
  try {
    return retrofit.callAdapter(returnType, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
    //用户自定义的Adapter可能不能正确的处理返回结果，这时候抛出异常
    throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType);
  }
}
</code></pre>
<h2 id="解析方法注解">解析方法注解</h2>
<p>1处处理方法的注解，就是先处理GET/POST/Header等注解信息</p>
<pre><code>private void parseMethodAnnotation(Annotation annotation) {
  if (annotation instanceof DELETE) {
    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
  } else if (annotation instanceof GET) {
    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
  } else if (annotation instanceof HEAD) {
    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);
    if (!Void.class.equals(responseType)) {
      throw methodError(&quot;HEAD method must use Void as response type.&quot;);
    }
  } else if (annotation instanceof PATCH) {
    parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);
  } else if (annotation instanceof POST) {
    parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
  } else if (annotation instanceof PUT) {
    parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);
  } else if (annotation instanceof OPTIONS) {
    parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);
  } else if (annotation instanceof HTTP) {
    HTTP http = (HTTP) annotation;
    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
  } else if (annotation instanceof retrofit2.http.Headers) {
  headers注解
    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    if (headersToParse.length == 0) {
      throw methodError(&quot;@Headers annotation is empty.&quot;);
    }
    headers = parseHeaders(headersToParse);
  } else if (annotation instanceof Multipart) {//如果是Multipart注解
    if (isFormEncoded) {
    //如果同时使用了FormUrlEncoded注解报错
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isMultipart = true;
  } else if (annotation instanceof FormUrlEncoded) {
    if (isMultipart) {
    //如果同时使用了Multipart注解报错,从这我们可以看出一个方法不能同时被Multipart和FormUrlEncoded所修饰
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isFormEncoded = true;
  }
}
</code></pre>
<p>然后根据具体的注解类型，在做进一步的处理，这里主要分析GET/POST/HEADER/ 等注解</p>
<h3 id="get">@GET</h3>
<pre><code class="language-java">else if (annotation instanceof GET) {
  parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
} 
</code></pre>
<p>get类型的请求，没有请求体</p>
<pre><code class="language-java">private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
 //如果该Builder已经有HTTPMethod了就不能改变了，直接抛异常
    if (this.httpMethod != null) {
    throw methodError(&quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,
        this.httpMethod, httpMethod);
  }
  //将HTTPMethod赋值给httpMethod对象，Get、Post、Delete等
  this.httpMethod = httpMethod;
  this.hasBody = hasBody;//是否有请求体

    //如果value为null，返回，因为value参数的值其实就是relativeURL。所以不能为null
  if (value.isEmpty()) {
    return;
  }

  // Get the relative URL path and existing query string, if present.
  int question = value.indexOf('?');
  if (question != -1 &amp;&amp; question &lt; value.length() - 1) {
    // Ensure the query string does not have any named parameters.
    String queryParams = value.substring(question + 1);
      //获取查询参数
    Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
    if (queryParamMatcher.find()) {
        //如果在value里面找到里查询参数的话，抛出异常。因为查询参数可以使用@Query注解来动态配置。
      throw methodError(&quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;
          + &quot;For dynamic query parameters use @Query.&quot;, queryParams);
    }
  }

  this.relativeUrl = value; //将value赋值给relativeUrl
  this.relativeUrlParamNames = parsePathParameters(value); //获取value里面的path占位符，如果有的话
}
</code></pre>
<p>再来看下解析value里的path占位符的方法。</p>
<pre><code>/**
获取已知URI里面的路径集合，如果一个参数被使用了两次，它只会在set中出现一次，好拗口啊，使用LinkedHashSet来保存path参数集合，保证了路径参数的顺序。
 * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
 * in the URI, it will only show up once in the set.
 */
static Set&lt;String&gt; parsePathParameters(String path) {
  Matcher m = PARAM_URL_REGEX.matcher(path);
  Set&lt;String&gt; patterns = new LinkedHashSet&lt;&gt;();
  while (m.find()) {
    patterns.add(m.group(1));
  }
  return patterns;
}
</code></pre>
<p>至此，GET方法的相关的注解分析完毕</p>
<h3 id="post">@POST</h3>
<pre><code class="language-Java">else if (annotation instanceof POST) {
  parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
} 
</code></pre>
<p>POST类型的请求，没有请求体。所以hasBody参数为true。</p>
<p>parseHttpMethodAndPath()方法已将在GET方法里面分析过了，这里面都一样。</p>
<p>其他的请求类型也是大同小异。</p>
<p>然后接着分析方法的Header注解</p>
<h3 id="headers">@Headers</h3>
<pre><code class="language-java">else if (annotation instanceof retrofit2.http.Headers) {
 //   首先获取Headers注解的值，是一个字符串数组。
  String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    如果header注解长度为0，抛出异常，所以使用了header注解必须设置值，不能存在空的header
  if (headersToParse.length == 0) {
    throw methodError(&quot;@Headers annotation is empty.&quot;);
  }
    处理header信息，我猜肯定是一个map
  headers = parseHeaders(headersToParse);
</code></pre>
<p>啊，居然不是，666.因为header不是KV结构的数据类型，而是一个key可以对应多个值。理论上可以使用Map&lt;String,Set<String>&gt;表示。</p>
<pre><code>private Headers parseHeaders(String[] headers) {
  Headers.Builder builder = new Headers.Builder();
  for (String header : headers) {
  // header以“:&quot;分割，前面是key,后面是value
    int colon = header.indexOf(':');
    if (colon == -1 || colon == 0 || colon == header.length() - 1) {
    //header必须是key:value格式表示，不然报错
      throw methodError(
          &quot;@Headers value must be in the form \&quot;Name: Value\&quot;. Found: \&quot;%s\&quot;&quot;, header);
    }
    String headerName = header.substring(0, colon); //key值
    String headerValue = header.substring(colon + 1).trim(); //value值，必须是一个数组，艹，又猜错了。
    if (&quot;Content-Type&quot;.equalsIgnoreCase(headerName)) {
    //遇到&quot;Content-Type&quot;字段。还需要获得具体的MediaType。
      MediaType type = MediaType.parse(headerValue);
      if (type == null) {
      //如果mediaType为null。抛出一个type畸形的错误。
        throw methodError(&quot;Malformed content type: %s&quot;, headerValue);
      }
      contentType = type;
    } else {
    将header的key和value加入到Builder里面。
      builder.add(headerName, headerValue);
    }
  }
  最后调用build方法生成一个Header对爱。
  return builder.build();
}
</code></pre>
<pre><code class="language-java">/**
 * Add a header with the specified name and value. Does validation of header names and values.
 */
public Builder add(String name, String value) {
  checkNameAndValue(name, value);
  return addLenient(name, value);
}
</code></pre>
<pre><code class="language-Java">Builder addLenient(String name, String value) {
  namesAndValues.add(name);
  namesAndValues.add(value.trim());
  return this;
}
</code></pre>
<pre><code class="language-java">final List&lt;String&gt; namesAndValues = new ArrayList&lt;&gt;(20);
</code></pre>
<p>namesAndValues是Header.Builder类的一种子段。可见在Builder内部header信息是按照key/value异常放到一个String集合里面的。为什么不放到一个Map里面呢，不懂。</p>
<p>总之，最后就是讲方法的Headers注解信息提取完毕。</p>
<h2 id="处理方法参数">处理方法参数</h2>
<pre><code class="language-java">int parameterCount = parameterAnnotationsArray.length; //求得数组的长度
parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
for (int p = 0; p &lt; parameterCount; p++) {
  Type parameterType = parameterTypes[p]; //便利参数，依次处理参数
    //如果参数不能解析，抛出异常
  if (Utils.hasUnresolvableType(parameterType)) {
    throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
        parameterType);
  }
//获取第p个参数的注解数组，如果没有注解抛出异常，可见，使用了Retrofit，接口方法中每个参数都必须使用注解进行修饰。
  Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
  if (parameterAnnotations == null) {
    throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
  }

   //解析方法中的参数，存入parameterHandlers[]数组中。
  parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
}
</code></pre>
<h2 id="参数校验">参数校验</h2>
<p>Utils.hasUnresolvableType(parameterType)，这个方法是对参数的类型做个校验。</p>
<pre><code>static boolean hasUnresolvableType(Type type) {
  //如果参数是引用数据类型，返回false，可见，接口定义中方法的参数只能是基本数据类型
  if (type instanceof Class&lt;?&gt;) {
    return false;
  }
  //如果参数是泛型
  if (type instanceof ParameterizedType) {
    ParameterizedType parameterizedType = (ParameterizedType) type;
    //去除泛型类中的实际类型，遍历
    for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
    //如果有一个泛型参数是基本数据类型，返回true，都不是返回false
      if (hasUnresolvableType(typeArgument)) {
        return true;
      }
    }
    return false;
  }
  //如果参数是泛型数组类型
  if (type instanceof GenericArrayType) {
    return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
  }
  if (type instanceof TypeVariable) {
    return true;
  }
  if (type instanceof WildcardType) {
    return true;
  }
  String className = type == null ? &quot;null&quot; : type.getClass().getName();
  throw new IllegalArgumentException(&quot;Expected a Class, ParameterizedType, or &quot;
      + &quot;GenericArrayType, but &lt;&quot; + type + &quot;&gt; is of type &quot; + className);
}

</code></pre>
<h2 id="解析参数">解析参数</h2>
<pre><code class="language-java">parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
private ParameterHandler&lt;?&gt; parseParameter(
        int p, Type parameterType, Annotation[] annotations) {
      ParameterHandler&lt;?&gt; result = null;
    //遍历参数的注解数组，调用parseParameterAnnotation()
      for (Annotation annotation : annotations) {
        ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(
            p, parameterType, annotations, annotation);
		//如果该注解没有返回，则解析下一个注解
        if (annotationAction == null) {
          continue;
        }

        if (result != null) {
          throw parameterError(p, &quot;Multiple Retrofit annotations found, only one allowed.&quot;);
        }
		
        result = annotationAction; //将解析的结果赋值给Result
      }

    //如果注解为null，抛出异常。这个地方永远不会调用，因为在获取注解数组之前就做过判断了，如果注解数组为null，直接抛异常，Line197-Line200 in ServiceMethod.Builder中
      if (result == null) {
        throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
      }

      return result;
    }
</code></pre>
<h2 id="获取参数注解信息">获取参数注解信息</h2>
<p>再来看看parseParameterAnnotation()方法,内容略多</p>
<pre><code class="language-Java">private ParameterHandler&lt;?&gt; parseParameterAnnotation(
    int p, Type type, Annotation[] annotations, Annotation annotation) {
  if (annotation instanceof Url) {
      //如果使用了Url注解，
    if (gotUrl) {
        //如果gotUrl为true，因为gotURL默认为false，说明之前处理过Url注解了,抛出多个@Url注解异常
      throw parameterError(p, &quot;Multiple @Url method annotations found.&quot;);
    }
    if (gotPath) {
        //如果gotPath为true，抛出异常，说明@Path注解不能和@Url注解一起使用
      throw parameterError(p, &quot;@Path parameters may not be used with @Url.&quot;);
    }
    if (gotQuery) {
        //如果gotQuery为true，抛出异常，说明@Url注解不能用在@Query注解后面
      throw parameterError(p, &quot;A @Url parameter must not come after a @Query&quot;);
    }
    if (relativeUrl != null) {
        //如果relativeUrl不为null,抛出异常，说明使用了@Url注解，relativeUrl必须为null
      throw parameterError(p, &quot;@Url cannot be used with @%s URL&quot;, httpMethod);
    }

    gotUrl = true;
      
----------------------------------------------------------------------------------------    
      //如果参数类型是HttpURL，String，URI或者参数类型是“android.net.Uri&quot;,返回ParameterHandler.RelativeUrl()，实际是交由这个类处理
    if (type == HttpUrl.class
        || type == String.class
        || type == URI.class
        || (type instanceof Class &amp;&amp; &quot;android.net.Uri&quot;.equals(((Class&lt;?&gt;) type).getName()))) {
      return new ParameterHandler.RelativeUrl();
    } else {
        //不然就抛出异常，也就是说@Url注解必须使用在okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri 这几种类型的参数上。
      throw parameterError(p,
          &quot;@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.&quot;);
    }
------------------------------------------------------------------------------------------
  } else if (annotation instanceof Path) { //@Path注解
     //如果gotQuery为true。抛出异常，因为@Path修饰的参数是路径的占位符。不是查询参数，不能使用@Query注解修饰
    if (gotQuery) {
      throw parameterError(p, &quot;A @Path parameter must not come after a @Query.&quot;);
    }
    if (gotUrl) {
      throw parameterError(p, &quot;@Path parameters may not be used with @Url.&quot;);
    }
      //如果相对路径为null，那@path注解也就无意义了。
    if (relativeUrl == null) {
      throw parameterError(p, &quot;@Path can only be used with relative url on @%s&quot;, httpMethod);
    }
    gotPath = true;

    Path path = (Path) annotation;
    String name = path.value(); //获取@Path注解的值
    validatePathName(p, name); //对改值进行校验，1该value必须是合法字符，2:该相对路径必须包含相应的占位符
 
      //然后将改参数的所有注解进行处理，最终调用ParameterHandler.Path进行处理。
    Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);
    return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded());

  } else if (annotation instanceof Query) { //Query注解，看不太懂，最后也是调用ParameterHandler.Query进行处理
    Query query = (Query) annotation;
    String name = query.value();
    boolean encoded = query.encoded();

    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    gotQuery = true;
    if (Iterable.class.isAssignableFrom(rawParameterType)) {
      if (!(type instanceof ParameterizedType)) {
        throw parameterError(p, rawParameterType.getSimpleName()
            + &quot; must include generic type (e.g., &quot;
            + rawParameterType.getSimpleName()
            + &quot;&lt;String&gt;)&quot;);
      }
      ParameterizedType parameterizedType = (ParameterizedType) type;
      Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(iterableType, annotations);
      return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();
    } else if (rawParameterType.isArray()) {
      Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(arrayComponentType, annotations);
      return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).array();
    } else {
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(type, annotations);
      return new ParameterHandler.Query&lt;&gt;(name, converter, encoded);
    }

  } else if (annotation instanceof QueryMap) {
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@QueryMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p, &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;
    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@QueryMap keys must be of type String: &quot; + keyType);
    }
    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    Converter&lt;?, String&gt; valueConverter =
        retrofit.stringConverter(valueType, annotations);

    return new ParameterHandler.QueryMap&lt;&gt;(valueConverter, ((QueryMap) annotation).encoded());

  } else if (annotation instanceof Header) {
    Header header = (Header) annotation;
    String name = header.value();

    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (Iterable.class.isAssignableFrom(rawParameterType)) {
      if (!(type instanceof ParameterizedType)) {
        throw parameterError(p, rawParameterType.getSimpleName()
            + &quot; must include generic type (e.g., &quot;
            + rawParameterType.getSimpleName()
            + &quot;&lt;String&gt;)&quot;);
      }
      ParameterizedType parameterizedType = (ParameterizedType) type;
      Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(iterableType, annotations);
      return new ParameterHandler.Header&lt;&gt;(name, converter).iterable();
    } else if (rawParameterType.isArray()) {
      Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(arrayComponentType, annotations);
      return new ParameterHandler.Header&lt;&gt;(name, converter).array();
    } else {
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(type, annotations);
      return new ParameterHandler.Header&lt;&gt;(name, converter);
    }

  } else if (annotation instanceof HeaderMap) {
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@HeaderMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p, &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;
    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@HeaderMap keys must be of type String: &quot; + keyType);
    }
    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    Converter&lt;?, String&gt; valueConverter =
        retrofit.stringConverter(valueType, annotations);

    return new ParameterHandler.HeaderMap&lt;&gt;(valueConverter);

  } else if (annotation instanceof Field) {
    if (!isFormEncoded) {
      throw parameterError(p, &quot;@Field parameters can only be used with form encoding.&quot;);
    }
    Field field = (Field) annotation;
    String name = field.value();
    boolean encoded = field.encoded();

    gotField = true;

    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (Iterable.class.isAssignableFrom(rawParameterType)) {
      if (!(type instanceof ParameterizedType)) {
        throw parameterError(p, rawParameterType.getSimpleName()
            + &quot; must include generic type (e.g., &quot;
            + rawParameterType.getSimpleName()
            + &quot;&lt;String&gt;)&quot;);
      }
      ParameterizedType parameterizedType = (ParameterizedType) type;
      Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(iterableType, annotations);
      return new ParameterHandler.Field&lt;&gt;(name, converter, encoded).iterable();
    } else if (rawParameterType.isArray()) {
      Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(arrayComponentType, annotations);
      return new ParameterHandler.Field&lt;&gt;(name, converter, encoded).array();
    } else {
      Converter&lt;?, String&gt; converter =
          retrofit.stringConverter(type, annotations);
      return new ParameterHandler.Field&lt;&gt;(name, converter, encoded);
    }

  } else if (annotation instanceof FieldMap) {
    if (!isFormEncoded) {
      throw parameterError(p, &quot;@FieldMap parameters can only be used with form encoding.&quot;);
    }
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@FieldMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p,
          &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;
    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@FieldMap keys must be of type String: &quot; + keyType);
    }
    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    Converter&lt;?, String&gt; valueConverter =
        retrofit.stringConverter(valueType, annotations);

    gotField = true;
    return new ParameterHandler.FieldMap&lt;&gt;(valueConverter, ((FieldMap) annotation).encoded());

  } else if (annotation instanceof Part) {
    if (!isMultipart) {
      throw parameterError(p, &quot;@Part parameters can only be used with multipart encoding.&quot;);
    }
    Part part = (Part) annotation;
    gotPart = true;

    String partName = part.value();
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (partName.isEmpty()) {
      if (Iterable.class.isAssignableFrom(rawParameterType)) {
        if (!(type instanceof ParameterizedType)) {
          throw parameterError(p, rawParameterType.getSimpleName()
              + &quot; must include generic type (e.g., &quot;
              + rawParameterType.getSimpleName()
              + &quot;&lt;String&gt;)&quot;);
        }
        ParameterizedType parameterizedType = (ParameterizedType) type;
        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
          throw parameterError(p,
              &quot;@Part annotation must supply a name or use MultipartBody.Part parameter type.&quot;);
        }
        return ParameterHandler.RawPart.INSTANCE.iterable();
      } else if (rawParameterType.isArray()) {
        Class&lt;?&gt; arrayComponentType = rawParameterType.getComponentType();
        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
          throw parameterError(p,
              &quot;@Part annotation must supply a name or use MultipartBody.Part parameter type.&quot;);
        }
        return ParameterHandler.RawPart.INSTANCE.array();
      } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
        return ParameterHandler.RawPart.INSTANCE;
      } else {
        throw parameterError(p,
            &quot;@Part annotation must supply a name or use MultipartBody.Part parameter type.&quot;);
      }
    } else {
      Headers headers =
          Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + partName + &quot;\&quot;&quot;,
              &quot;Content-Transfer-Encoding&quot;, part.encoding());

      if (Iterable.class.isAssignableFrom(rawParameterType)) {
        if (!(type instanceof ParameterizedType)) {
          throw parameterError(p, rawParameterType.getSimpleName()
              + &quot; must include generic type (e.g., &quot;
              + rawParameterType.getSimpleName()
              + &quot;&lt;String&gt;)&quot;);
        }
        ParameterizedType parameterizedType = (ParameterizedType) type;
        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
          throw parameterError(p, &quot;@Part parameters using the MultipartBody.Part must not &quot;
              + &quot;include a part name in the annotation.&quot;);
        }
        Converter&lt;?, RequestBody&gt; converter =
            retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
        return new ParameterHandler.Part&lt;&gt;(headers, converter).iterable();
      } else if (rawParameterType.isArray()) {
        Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
          throw parameterError(p, &quot;@Part parameters using the MultipartBody.Part must not &quot;
              + &quot;include a part name in the annotation.&quot;);
        }
        Converter&lt;?, RequestBody&gt; converter =
            retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
        return new ParameterHandler.Part&lt;&gt;(headers, converter).array();
      } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
        throw parameterError(p, &quot;@Part parameters using the MultipartBody.Part must not &quot;
            + &quot;include a part name in the annotation.&quot;);
      } else {
        Converter&lt;?, RequestBody&gt; converter =
            retrofit.requestBodyConverter(type, annotations, methodAnnotations);
        return new ParameterHandler.Part&lt;&gt;(headers, converter);
      }
    }

  } else if (annotation instanceof PartMap) {
    if (!isMultipart) {
      throw parameterError(p, &quot;@PartMap parameters can only be used with multipart encoding.&quot;);
    }
    gotPart = true;
    Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
    if (!Map.class.isAssignableFrom(rawParameterType)) {
      throw parameterError(p, &quot;@PartMap parameter type must be Map.&quot;);
    }
    Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
    if (!(mapType instanceof ParameterizedType)) {
      throw parameterError(p, &quot;Map must include generic types (e.g., Map&lt;String, String&gt;)&quot;);
    }
    ParameterizedType parameterizedType = (ParameterizedType) mapType;

    Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
    if (String.class != keyType) {
      throw parameterError(p, &quot;@PartMap keys must be of type String: &quot; + keyType);
    }

    Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
    if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
      throw parameterError(p, &quot;@PartMap values cannot be MultipartBody.Part. &quot;
          + &quot;Use @Part List&lt;Part&gt; or a different value type instead.&quot;);
    }

    Converter&lt;?, RequestBody&gt; valueConverter =
        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);

    PartMap partMap = (PartMap) annotation;
    return new ParameterHandler.PartMap&lt;&gt;(valueConverter, partMap.encoding());

  } else if (annotation instanceof Body) {
    if (isFormEncoded || isMultipart) {
      throw parameterError(p,
          &quot;@Body parameters cannot be used with form or multi-part encoding.&quot;);
    }
    if (gotBody) {
      throw parameterError(p, &quot;Multiple @Body method annotations found.&quot;);
    }

    Converter&lt;?, RequestBody&gt; converter;
    try {
      converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
    } catch (RuntimeException e) {
      // Wide exception range because factories are user code.
      throw parameterError(e, p, &quot;Unable to create @Body converter for %s&quot;, type);
    }
    gotBody = true;
    return new ParameterHandler.Body&lt;&gt;(converter);
  }

  return null; // Not a Retrofit annotation.找不到该注解
}
</code></pre>
<p>从上面可以看出，改立参数注解的套路就是：先判断该注解的类型，然后使用策略模式分别调用ParameterHandler里对应的子类来处理</p>
<p>写到这里我已经晕了。晕晕乎乎好舒服</p>
<h3 id="header">@Header</h3>
<h4 id="使用场景">使用场景</h4>
<p>有时候我们需要动态的设置请求header中的某个请求头的值，这个时候就可以使用@Header来修饰个参数。</p>
<p>最终都是讲header里的信息提取到Request里面</p>
<pre><code class="language-java">static final class Header&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name;
  private final Converter&lt;T, String&gt; valueConverter;

  Header(String name, Converter&lt;T, String&gt; valueConverter) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) return; // Skip null values.
    builder.addHeader(name, valueConverter.convert(value));
  }
}
</code></pre>
<pre><code class="language-java">void addHeader(String name, String value) {
  if (&quot;Content-Type&quot;.equalsIgnoreCase(name)) {
    MediaType type = MediaType.parse(value);
    if (type == null) {
      throw new IllegalArgumentException(&quot;Malformed content type: &quot; + value);
    }
    contentType = type;
  } else {
    requestBuilder.addHeader(name, value);
  }
}
</code></pre>
<p>调用requestBuilder.addHeader()方法。</p>
<p>这个requestBuilder是OKHttp中Request的内部静态类Builder类的一个对象。</p>
<pre><code>private final Request.Builder requestBuilder;
</code></pre>
<p>从中我们可以看出最后将@Header注释的参数的值解析后添加到Request对象中的Header信息里。</p>
<h3 id="path">@Path</h3>
<h4 id="使用场景-2">使用场景</h4>
<p>有时候请求路径是不定的，即请求路径里的某个segment是变化的，也就是需要我们使用参数来动态的改变，这个时候我们就需要使用@Path 来修饰这个参数</p>
<pre><code class="language-java">static final class Path&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name; //参数名，占位符
  private final Converter&lt;T, String&gt; valueConverter;
  private final boolean encoded; //是否编码

  Path(String name, Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) {
      throw new IllegalArgumentException(
          &quot;Path parameter \&quot;&quot; + name + &quot;\&quot; value must not be null.&quot;);
    }
    builder.addPathParam(name, valueConverter.convert(value), encoded);
  }
}
</code></pre>
<pre><code class="language-java">void addPathParam(String name, String value, boolean encoded) {
  if (relativeUrl == null) {
    // The relative URL is cleared when the first query parameter is set.
    throw new AssertionError();
  }
   //将占位符”{name}”使用value替换
  relativeUrl = relativeUrl.replace(&quot;{&quot; + name + &quot;}&quot;, canonicalizeForPath(value, encoded));
}
</code></pre>
<h3 id="query">@Query</h3>
<h4 id="使用场景-3">使用场景</h4>
<p>@Query用来修饰接口方法中的查询字段</p>
<pre><code class="language-java">static final class Query&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name;
  private final Converter&lt;T, String&gt; valueConverter;
  private final boolean encoded;

  Query(String name, Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) return; // Skip null values.
    builder.addQueryParam(name, valueConverter.convert(value), encoded);
  }
}
</code></pre>
<pre><code class="language-Java">//将查询参数组合到相对路径上。
void addQueryParam(String name, String value, boolean encoded) {
  if (relativeUrl != null) {
    // Do a one-time combination of the built relative URL and the base URL.
    urlBuilder = baseUrl.newBuilder(relativeUrl);
    if (urlBuilder == null) {
      throw new IllegalArgumentException(
          &quot;Malformed URL. Base: &quot; + baseUrl + &quot;, Relative: &quot; + relativeUrl);
    }
    relativeUrl = null;
  }

  if (encoded) {
    urlBuilder.addEncodedQueryParameter(name, value);
  } else {
    urlBuilder.addQueryParameter(name, value);
  }
}
</code></pre>
<h3 id="querymap">@QueryMap</h3>
<h4 id="使用场景-4">使用场景</h4>
<p>当接口中的一个 方法有比较多的查询字段时，全部定义到方法中时比较麻烦且容易出错，这个使用我们完全可以将所有的查询参数放到一个Map里面。</p>
<p>可想而知，其内部实现必定是遍历map ，然后像处理@Query参数一样调用addQueryParam()处理每个查询参数。</p>
<pre><code>static final class FieldMap&lt;T&gt; extends ParameterHandler&lt;Map&lt;String, T&gt;&gt; {
  private final Converter&lt;T, String&gt; valueConverter;
  private final boolean encoded;

  FieldMap(Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, Map&lt;String, T&gt; value) throws IOException {
    if (value == null) {
      throw new IllegalArgumentException(&quot;Field map was null.&quot;);
    }

    for (Map.Entry&lt;String, T&gt; entry : value.entrySet()) {
      String entryKey = entry.getKey();
      if (entryKey == null) {
        throw new IllegalArgumentException(&quot;Field map contained null key.&quot;);
      }
      T entryValue = entry.getValue();
      if (entryValue == null) {
        throw new IllegalArgumentException(
            &quot;Field map contained null value for key '&quot; + entryKey + &quot;'.&quot;);
      }
      //果然不假
      builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
    }
  }
}
</code></pre>
<h3 id="field">@Field</h3>
<h4 id="使用场景-5">使用场景</h4>
<p>@Field注解一般用在表单参数的提交上</p>
<pre><code class="language-java">static final class Field&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final String name; //参数名字
  private final Converter&lt;T, String&gt; valueConverter; //参数值转换器
  private final boolean encoded; //是否编码

  Field(String name, Converter&lt;T, String&gt; valueConverter, boolean encoded) {
    this.name = checkNotNull(name, &quot;name == null&quot;);
    this.valueConverter = valueConverter;
    this.encoded = encoded;
  }

  @Override void apply(RequestBuilder builder, T value) throws IOException {
    if (value == null) return; // Skip null values. 所以使用@Field修饰的字段，是不会上传到服务器的。
    //调用ResuestBuilder对象的具体想法来处理@Field修饰的表单字段
    builder.addFormField(name, valueConverter.convert(value), encoded);
  }
}
</code></pre>
<pre><code>void addFormField(String name, String value, boolean encoded) {
//根据参数值是否被编码，调用不同的方法。formBuilder是OKHttp中的一个类。也是使用Builder模式创建的。
  if (encoded) {
    formBuilder.addEncoded(name, value);
  } else {
    formBuilder.add(name, value);
  }
}
</code></pre>
<h3 id="fieldmap">@FieldMap</h3>
<p>@FieldMap</p>
<h4 id="使用场景-6">使用场景</h4>
<p>假如表单参数有很多个，我们可以使用一个Map&lt;String,String&gt;来表示，然后使用@FieldMap注解来修饰该参数就行了。可想而知，如同@QueryMap一样，其内部实现肯定是遍历Map，然后像处理@Field参数一样调用</p>
<p>builder.addFormField(name, valueConverter.convert(value), encoded);</p>
<h3 id="body">@Body</h3>
<h4 id="使用场景-7">使用场景</h4>
<p>在以下需要提交表单的请求里，我们可以使用@Field,@FieldMap,我们还可以使用@Body来修饰我们提交的表单数据，这个时候我们需要定义一个Bean类，Bean类的各个Field必须和表单字段的key一样</p>
<pre><code class="language-java">static final class Body&lt;T&gt; extends ParameterHandler&lt;T&gt; {
  private final Converter&lt;T, RequestBody&gt; converter;

  Body(Converter&lt;T, RequestBody&gt; converter) {
    this.converter = converter;
  }

  @Override void apply(RequestBuilder builder, T value) {
    if (value == null) {
      throw new IllegalArgumentException(&quot;Body parameter value must not be null.&quot;);
    }
    RequestBody body;
    try {
      body = converter.convert(value);
    } catch (IOException e) {
      throw new RuntimeException(&quot;Unable to convert &quot; + value + &quot; to RequestBody&quot;, e);
    }
    builder.setBody(body);
  }
}
</code></pre>
<p>这里Retrofit并没有像@Field一样处理表单参数。仔细想想也对，因为凡是提交的表单数据都需要放到请求体里面，即使使用@Field，@FieldMap提交的数据，最终还是需要放到请求体里面。</p>
<h3 id="part">@Part</h3>
<h3 id="rawpart">@RawPart</h3>
<h3 id="partmap">@PartMap</h3>
<p>以上三个注解都是使用修饰上传文件的参数的，</p>
<h3 id="结论">结论</h3>
<p>从对上面的分析可以知道，我们在提取使用注解修饰的参数后将值存放到RequestBuilder对象里。</p>
<p>这里又引入了RequestBuilder类</p>
<h1 id="requestbuilder">RequestBuilder</h1>
<pre><code class="language-java">final class RequestBuilder {
  private static final char[] HEX_DIGITS =
      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = &quot; \&quot;&lt;&gt;^`{}|\\?#&quot;;

  private final String method; //方法类型

  private final HttpUrl baseUrl; //scheme+host
  private String relativeUrl; 	//相对路径
  private HttpUrl.Builder urlBuilder; //URL构造器

  private final Request.Builder requestBuilder; //OkHttp中Request构造器
  private MediaType contentType;		//提交表单的数据类型

  private final boolean hasBody;		//是否有请求体
  private MultipartBody.Builder multipartBuilder; //上传文件的构造器
  private FormBody.Builder formBuilder;				//表单数据的构造器
  private RequestBody body;							//请求体

  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
    this.method = method;
    this.baseUrl = baseUrl;
    this.relativeUrl = relativeUrl;
    this.requestBuilder = new Request.Builder();
    this.contentType = contentType;
    this.hasBody = hasBody;

    if (headers != null) {
      requestBuilder.headers(headers);
    }

    if (isFormEncoded) {
      // Will be set to 'body' in 'build'.
      formBuilder = new FormBody.Builder();
    } else if (isMultipart) {
      // Will be set to 'body' in 'build'.
      multipartBuilder = new MultipartBody.Builder();
      multipartBuilder.setType(MultipartBody.FORM);
    }
  }

  void setRelativeUrl(Object relativeUrl) {
    if (relativeUrl == null) throw new NullPointerException(&quot;@Url parameter is null.&quot;);
    this.relativeUrl = relativeUrl.toString();
  }

  void addHeader(String name, String value) {
    if (&quot;Content-Type&quot;.equalsIgnoreCase(name)) {
      MediaType type = MediaType.parse(value);
      if (type == null) {
        throw new IllegalArgumentException(&quot;Malformed content type: &quot; + value);
      }
      contentType = type;
    } else {
      requestBuilder.addHeader(name, value);
    }
  }

  void addPathParam(String name, String value, boolean encoded) {
    if (relativeUrl == null) {
      // The relative URL is cleared when the first query parameter is set.
      throw new AssertionError();
    }
    relativeUrl = relativeUrl.replace(&quot;{&quot; + name + &quot;}&quot;, canonicalizeForPath(value, encoded));
  }

  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
    int codePoint;
    for (int i = 0, limit = input.length(); i &lt; limit; i += Character.charCount(codePoint)) {
      codePoint = input.codePointAt(i);
      if (codePoint &lt; 0x20 || codePoint &gt;= 0x7f
          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
          || (!alreadyEncoded &amp;&amp; (codePoint == '/' || codePoint == '%'))) {
        // Slow path: the character at i requires encoding!
        Buffer out = new Buffer();
        out.writeUtf8(input, 0, i);
        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
        return out.readUtf8();
      }
    }

    // Fast path: no characters required encoding.
    return input;
  }

  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
      boolean alreadyEncoded) {
    Buffer utf8Buffer = null; // Lazily allocated.
    int codePoint;
    for (int i = pos; i &lt; limit; i += Character.charCount(codePoint)) {
      codePoint = input.codePointAt(i);
      if (alreadyEncoded
          &amp;&amp; (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
        // Skip this character.
      } else if (codePoint &lt; 0x20 || codePoint &gt;= 0x7f
          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
          || (!alreadyEncoded &amp;&amp; (codePoint == '/' || codePoint == '%'))) {
        // Percent encode this character.
        if (utf8Buffer == null) {
          utf8Buffer = new Buffer();
        }
        utf8Buffer.writeUtf8CodePoint(codePoint);
        while (!utf8Buffer.exhausted()) {
          int b = utf8Buffer.readByte() &amp; 0xff;
          out.writeByte('%');
          out.writeByte(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0xf]);
          out.writeByte(HEX_DIGITS[b &amp; 0xf]);
        }
      } else {
        // This character doesn't need encoding. Just copy it over.
        out.writeUtf8CodePoint(codePoint);
      }
    }
  }

  void addQueryParam(String name, String value, boolean encoded) {
    if (relativeUrl != null) {
      // Do a one-time combination of the built relative URL and the base URL.
      urlBuilder = baseUrl.newBuilder(relativeUrl);
      if (urlBuilder == null) {
        throw new IllegalArgumentException(
            &quot;Malformed URL. Base: &quot; + baseUrl + &quot;, Relative: &quot; + relativeUrl);
      }
      relativeUrl = null;
    }

    if (encoded) {
      urlBuilder.addEncodedQueryParameter(name, value);
    } else {
      urlBuilder.addQueryParameter(name, value);
    }
  }

  void addFormField(String name, String value, boolean encoded) {
    if (encoded) {
      formBuilder.addEncoded(name, value);
    } else {
      formBuilder.add(name, value);
    }
  }

  void addPart(Headers headers, RequestBody body) {
    multipartBuilder.addPart(headers, body);
  }

  void addPart(MultipartBody.Part part) {
    multipartBuilder.addPart(part);
  }

  void setBody(RequestBody body) {
    this.body = body;
  }

  Request build() {
    HttpUrl url;
    HttpUrl.Builder urlBuilder = this.urlBuilder;
    if (urlBuilder != null) {
      url = urlBuilder.build();
    } else {
      // No query parameters triggered builder creation, just combine the relative URL and base URL.
      url = baseUrl.resolve(relativeUrl);
      if (url == null) {
        throw new IllegalArgumentException(
            &quot;Malformed URL. Base: &quot; + baseUrl + &quot;, Relative: &quot; + relativeUrl);
      }
    }

    RequestBody body = this.body;
    if (body == null) {
      // Try to pull from one of the builders.
      if (formBuilder != null) {
        body = formBuilder.build();
      } else if (multipartBuilder != null) {
        body = multipartBuilder.build();
      } else if (hasBody) {
        // Body is absent, make an empty body.
        body = RequestBody.create(null, new byte[0]);
      }
    }

    MediaType contentType = this.contentType;
    if (contentType != null) {
      if (body != null) {
        body = new ContentTypeOverridingRequestBody(body, contentType);
      } else {
        requestBuilder.addHeader(&quot;Content-Type&quot;, contentType.toString());
      }
    }

    //生成一个Request对象
    return requestBuilder
        .url(url)
        .method(method, body)
        .build();
  }

  private static class ContentTypeOverridingRequestBody extends RequestBody {
    private final RequestBody delegate;
    private final MediaType contentType;

    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
      this.delegate = delegate;
      this.contentType = contentType;
    }

    @Override public MediaType contentType() {
      return contentType;
    }

    @Override public long contentLength() throws IOException {
      return delegate.contentLength();
    }

    @Override public void writeTo(BufferedSink sink) throws IOException {
      delegate.writeTo(sink);
    }
  }
}
</code></pre>
<h1 id="okhttpcall">OkHttpCall</h1>
<pre><code class="language-java">OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre>
<p>在创建了ServiceMethod对象后，使用该ServiceMethod对象和其参数创建一个OKHttPCall对象</p>
<pre><code class="language-java">OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre>
<p>在合适的时候调用ServiceMethod对象的toRequest方法生成一个Request对象，toReques()的内部实现就是调用RequestBuilder对象的build方法。</p>
<pre><code>/** Builds an HTTP request from method arguments. */
Request toRequest(Object... args) throws IOException {
  RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
      contentType, hasBody, isFormEncoded, isMultipart);

  @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;

  int argumentCount = args != null ? args.length : 0;
  if (argumentCount != handlers.length) {
    throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount
        + &quot;) doesn't match expected count (&quot; + handlers.length + &quot;)&quot;);
  }

  for (int p = 0; p &lt; argumentCount; p++) {
    handlers[p].apply(requestBuilder, args[p]);
  }

  return requestBuilder.build();
}
</code></pre>
<p>OkHttpCall 实现了Call接口，这个Call接口和OkHttp中的Call接口一样，毕竟一家公司嘛。</p>
<p>其实就是对OkHttpCall 做了一层包装。</p>
<p>最后方法的执行时通过调用</p>
<pre><code>return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre>
<p>返回接口中方法定义的返回值。</p>
<p>这块的流程就是构造一个OKHttp对象需要使用ServiceMethod对象和相应的参数。</p>
<pre><code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre>
<p>最后创建具体的Call对象时</p>
<pre><code class="language-java">private okhttp3.Call createRawCall() throws IOException {
  Request request = serviceMethod.toRequest(args);
  okhttp3.Call call = serviceMethod.callFactory.newCall(request);
  if (call == null) {
    throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
  }
  return call;
}
</code></pre>
<p>调用了ServiceMethod对象的toRequest方法，然后使用这个request对象创建了一个Call对象。</p>
<pre><code class="language-java">/** Builds an HTTP request from method arguments. */
Request toRequest(Object... args) throws IOException {
  RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
      contentType, hasBody, isFormEncoded, isMultipart);

  @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;

  int argumentCount = args != null ? args.length : 0;
  if (argumentCount != handlers.length) {
    throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount
        + &quot;) doesn't match expected count (&quot; + handlers.length + &quot;)&quot;);
  }

  for (int p = 0; p &lt; argumentCount; p++) {
    handlers[p].apply(requestBuilder, args[p]);
  }
//生成一个Request对象
  return requestBuilder.build();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OkHttp 源码分析]]></title>
        <id>https://philadelphia.github.io/post/okhttp-yuan-ma-fen-xi</id>
        <link href="https://philadelphia.github.io/post/okhttp-yuan-ma-fen-xi">
        </link>
        <updated>2019-08-16T10:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>基于OkHttp3.11.0</p>
<pre><code>implementation(&quot;com.squareup.okhttp3:okhttp:3.11.0&quot;)
</code></pre>
<p>网络框架的核心思想都是构建基本的执行单元之后(1)，根据任务类型放入对应的任务队列里(2)，再由线程池去执行(3)。OKHttp也不列外。</p>
<h1 id="初始化okhttpclient">初始化OKHttpClient</h1>
<p>OKHttpclient采用了Builder模式创建</p>
<pre><code class="language-java">OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .readTimeout(5, TimeUnit.SECONDS)
        .writeTimeout(5, TimeUnit.SECONDS)
        .build();
</code></pre>
<h1 id="构建执行单元">构建执行单元</h1>
<h2 id="1get请求">1：GET请求</h2>
<pre><code class="language-java">Request request = new Request.Builder().url(&quot;www.baidu.com&quot;)
        .get() // 默认就是get请求
        .build();
</code></pre>
<h2 id="2-post请求">2: POST请求</h2>
<p>POST与GET多了一个body。</p>
<pre><code class="language-java">FormBody body = new FormBody.Builder()
        .add(&quot;key&quot;, &quot;value&quot;)
        .add(&quot;key1&quot;, &quot;value1&quot;)
        .build();

Request post = new Request.Builder().url(&quot;www.baidu.com&quot;)
        .post(body)
        .build();
</code></pre>
<h1 id="执行">执行</h1>
<h2 id="1同步执行">1：同步执行</h2>
<pre><code class="language-Java">try {
    Response response = okHttpClient.newCall(post).execute();
    if (response.code() ==  200){
     	 }

} catch (IOException e) {

}
</code></pre>
<p>然后就可以根据response的结果操作了。</p>
<h2 id="2异步执行">2：异步执行</h2>
<pre><code class="language-java">okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {

    }
});
</code></pre>
<p>在对应的回调函数里做对应的业务逻辑。</p>
<p>以上就是OKHttp的使用的基本使用。</p>
<p>这里Request就是请求单元,不论是同步执行还是异步执行，都调用okHttpClient.newCall(request) 生成了一个RealCall对象，然后分别调用该对象的execute(同步执行)方法或者enqueue(异步执行)方法。</p>
<pre><code class="language-Java">@Override public Call newCall(Request request) {
  return RealCall.newRealCall(this, request, false /* for web socket */);
}
</code></pre>
<p>OKHttp的newCall方法调用RealCall的静态方法newRealCall().</p>
<pre><code class="language-Java">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
  // Safely publish the Call instance to the EventListener.
  RealCall call = new RealCall(client, originalRequest, forWebSocket);
  call.eventListener = client.eventListenerFactory().create(call);
  return call;
}
</code></pre>
<pre><code class="language-Java">private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
  this.client = client;
  this.originalRequest = originalRequest;
  this.forWebSocket = forWebSocket;
  this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
}
</code></pre>
<p>可以看到，newRealCall方法将client作为自己构造函数的参数传入</p>
<p>下面这个方法是RealCall对象的execute方法</p>
<pre><code>@Override public Response execute() throws IOException {
  synchronized (this) {
    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
    executed = true;
  }
  captureCallStackTrace();
  eventListener.callStart(this);
  try {
    client.dispatcher().executed(this);
    Response result = getResponseWithInterceptorChain();
    if (result == null) throw new IOException(&quot;Canceled&quot;);
    return result;
  } catch (IOException e) {
    eventListener.callFailed(this, e);
    throw e;
  } finally {
    client.dispatcher().finished(this);
  }
}
</code></pre>
<p>可以看到调用了 client.dispatcher().executed(this);</p>
<p>最中调用 Response result = getResponseWithInterceptorChain();并返回Result对象</p>
<p>如果发生了异常则调用    eventListener.callFailed(this, e);</p>
<p>而最终这会调用    client.dispatcher().finished(this)，来结束这个call。</p>
<p>这里面有一个很重要的类Dispatcher，它是OKHttpclient的一个内部成员，同时OKHttpclient是request的内部成员</p>
<pre><code class="language-java">public final class Dispatcher {
      private int maxRequests = 64;  //最大的请求数量
      private int maxRequestsPerHost = 5; //同义主机同时支持的最大请求数
      private @Nullable Runnable idleCallback;

      /** Executes calls. Created lazily. */
      private @Nullable ExecutorService executorService;

      /** Ready async calls in the order they'll be run. */
      private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();//准备执行的异步任务队列

      /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
      private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //正在执行的异步任务队列

      /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
      private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); //正在运行的同步任务队列
  
  }
</code></pre>
<p>分别看到，这个类的同步执行方法是</p>
<pre><code>synchronized void executed(RealCall call) {
  runningSyncCalls.add(call);
}
</code></pre>
<p>将改call假如同步执行队列中。</p>
<pre><code>synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
    runningAsyncCalls.add(call);
    executorService().execute(call);
  } else {
    readyAsyncCalls.add(call);
  }
}
</code></pre>
<p>异步执行方法是先进行判断，只有正在执行的异步任务队列长度小于了最大的请求数并且改请求的主机的正在请求数量小于每个主句的同时的最大连接数世才将改请求加入到正在执行的异步任务队列里，然后由具体的执行任务来执行这个请求任务。</p>
<p>不然就把这个任务加入到待执行的异步执行队队列。</p>
<p>这里RealCall 对象突然就变成了一个AsyncCall对象</p>
<pre><code class="language-Java">@Override public void enqueue(Callback responseCallback) {
  synchronized (this) {
    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
    executed = true;
  }
  captureCallStackTrace();
  eventListener.callStart(this);
  client.dispatcher().enqueue(new AsyncCall(responseCallback));
}
</code></pre>
<p>在RealCall执行enqueue方法时将一个回调对象作为构造参数生成了一个AsyncCall对象，传入了Dispatcher的enqueue方法。</p>
<pre><code class="language-java">final class AsyncCall extends NamedRunnable {
      private final Callback responseCallback;

      AsyncCall(Callback responseCallback) {
        super(&quot;OkHttp %s&quot;, redactedUrl());
        this.responseCallback = responseCallback;
      }
  }
</code></pre>
<p>Async对象其实继承了NamedRunnable。而NamedRunnable实现了Runnable接口，可以看出其实Async其实就是一个命名后的runnable对象。</p>
<p>这里把RealCall同步执行和异步执行的代码列出来</p>
<p>1：同步执行</p>
<pre><code class="language-Java">@Override public Response execute() throws IOException {
  synchronized (this) {
    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
    executed = true;
  }
  captureCallStackTrace();
  eventListener.callStart(this);
  try {
    client.dispatcher().executed(this);
    Response result = getResponseWithInterceptorChain();
    if (result == null) throw new IOException(&quot;Canceled&quot;);
    return result;
  } catch (IOException e) {
    eventListener.callFailed(this, e);
    throw e;
  } finally {
    client.dispatcher().finished(this);
  }
}
</code></pre>
<p>2：异步执行</p>
<p>最终调用AsyncCall对象的execute方法</p>
<pre><code>@Override protected void execute() {
    boolean signalledCallback = false;
    try {
      Response response = getResponseWithInterceptorChain();
      if (retryAndFollowUpInterceptor.isCanceled()) {
        signalledCallback = true;
        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
      } else {
        signalledCallback = true;
        responseCallback.onResponse(RealCall.this, response);
      }
    } catch (IOException e) {
      if (signalledCallback) {
        // Do not signal the callback twice!
        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);
      } else {
        eventListener.callFailed(RealCall.this, e);
        responseCallback.onFailure(RealCall.this, e);
      }
    } finally {
      client.dispatcher().finished(this);
    }
  }
}
</code></pre>
<p>可以看出不管是同步执行还是异步执行，最终都是调用getResponseWithInterceptorChain();</p>
<p>方法得出Response</p>
<pre><code class="language-Java">Response getResponseWithInterceptorChain() throws IOException {
  // Build a full stack of interceptors.
  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
  interceptors.addAll(client.interceptors());
  interceptors.add(retryAndFollowUpInterceptor);
  interceptors.add(new BridgeInterceptor(client.cookieJar()));
  interceptors.add(new CacheInterceptor(client.internalCache()));
  interceptors.add(new ConnectInterceptor(client));
  if (!forWebSocket) {
    interceptors.addAll(client.networkInterceptors());
  }
  interceptors.add(new CallServerInterceptor(forWebSocket));

  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
      originalRequest, this, eventListener, client.connectTimeoutMillis(),
      client.readTimeoutMillis(), client.writeTimeoutMillis());

  return chain.proceed(originalRequest);
}
</code></pre>
<p>在这个方法里首先将用户添加到OKHttpClient上的应用拦截器添加到拦截器列表里。然后一次添加重试重定向拦截器, 头部信息处理拦截器，缓存拦截器， 连接拦截器，然后再加上OKhttpclient配置的网络拦截器，最后添加最终发起请求的拦截器。</p>
<p>拦截器这里使用了不完整的责任链模式，依次处理返回的response，最后返回最终的response。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java:动态绑定]]></title>
        <id>https://philadelphia.github.io/post/javadong-tai-bang-ding</id>
        <link href="https://philadelphia.github.io/post/javadong-tai-bang-ding">
        </link>
        <updated>2019-08-16T10:03:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="动态绑定">动态绑定</h2>
<p>动态绑定作为Java多态特性的一个重要实现</p>
<p>有一下三个类：</p>
<pre><code class="language-java">public class Fruit {
    public static final String TAG = &quot;Fruit&quot;;

    public Fruit() {
    }

    public void say() {
        Log.i(TAG, &quot;say: i am fruit: &quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Apple  extends  Fruit{

    public void say(){
        Log.i(TAG, &quot;say:  i am apple&quot;);
    }
}
</code></pre>
<pre><code class="language-java">
public class Orange extends Fruit {

    public void say(){
        Log.i(TAG, &quot;say:  i am orange&quot;);
    }
}
</code></pre>
<p>其中Apple和Orange类都继承Fruit类。</p>
<p>然后在使用的时候</p>
<pre><code class="language-java">Fruit fruit = new Apple();
fruit.say();
</code></pre>
<p>我们都知道最后打印的结果是</p>
<pre><code class="language-java">debug I/Fruit: say:  i am apple
</code></pre>
<p>很明显这就是Java多态特性的体现。</p>
<p>我们明明调用的是Fruit对象的方法。但是运行时却调用了Apple对象的方法，这是怎么实现的呢，这就涉及到了Java的动态绑定了，</p>
<p>这里确定两个概念：编译时类型与运行时类型</p>
<p>编译时类型就是指改对象在编译后的文件里的类型也就是改对象声明时的类型，而运行时类型是指在程序运行时动态指定的类型也就是该对象定义时的类型。如果编译时类型与运行时类型不一致就会发生运行时动态绑定</p>
<p>比如上面定义的Fruit fruit = new Apple();</p>
<p>fruit的编译时类型是Fruit。</p>
<p>我们可以从编译后的class文件看出</p>
<pre><code class="language-java">#4 = Class              #243          // com/meiliwu/dragon/model/Apple
#5 = Methodref          #4.#241       // com/meiliwu/dragon/model/Apple.&quot;&lt;init&gt;&quot;:()V
#6 = Methodref          #244.#245     // com/meiliwu/dragon/model/Fruit.say:()V
</code></pre>
<p>我们可以从编译后的文件看出。fruit.say方法在编译后指向的是Fruit的say方法。但是运行时类型是Apple。运行时却是调用Apple的say方法。我们从日志可以看出来。</p>
<p>如果我们将代码改成这样</p>
<pre><code class="language-java">Apple fruit = new Apple();
fruit.say();
</code></pre>
<p>打印日志如下：</p>
<pre><code class="language-Java">12-25 11:25:17.803 9709-9709/com.meiliwu.dragon.debug I/Fruit: say:  i am apple
</code></pre>
<p>我们再看看编译后的文件</p>
<pre><code class="language-java">4 = Class              #243          // com/meiliwu/dragon/model/Apple
#5 = Methodref          #4.#241       // com/meiliwu/dragon/model/Apple.&quot;&lt;init&gt;&quot;:()V
#6 = Methodref          #4.#244       // com/meiliwu/dragon/model/Apple.say:()V
</code></pre>
<p>从代码可以看出编译时类型与运行时类型一致，这是不会发生动态绑定的，这时可以从编译后的class文件得出验证。</p>
<h2 id="java的pecs原则">JAVA的PECS原则</h2>
<p>PECS指“Producer Extends，Consumer Super”</p>
<p>比如：</p>
<pre><code class="language-java">List&lt;? extends Fruit&gt; fruitList = new ArrayList&lt;&gt;();
fruitList.add(new Apple());
fruitList.add(new Orange());
</code></pre>
<p>但是编译器却报了编译错误：</p>
<p>按理说fruitList是一个持有类型为Fruit及其子类的泛型列表啊，为什么不能往其中添加Fruit的子类呢？</p>
<p>因为泛型的一大好处就是可以在编译时检查，避免传入不相符的类型可能导致的ClassCastException了。但是声明fruitList的时候没有明确的指定泛型的具体类型，所以编译器无法确认其持有的具体类型，当然也就拒绝了add操作。</p>
<p>fruitList只是规定了泛型的上限，但是并没有确定具体的类型，也无法确定具体的子类型，可以是Apple，Orange还可能是Banana,所以不能把具体的对象添加进去，不然使用的时候可能导致ClassCastException了。但是可以保证从里面取出来的数据都是Fruit及其子类，而且还是Fruit的某一个子类。</p>
<p>我们把代码改成下面这样子就可以添加不同的Fruit对象了。</p>
<p>因为我们规定了fruitList持有的都是Fruit及其父类，可以将Fruit 及其子类都添加进去</p>
<pre><code class="language-java">List&lt;? super Fruit&gt; fruitList = new ArrayList&lt;&gt;();
fruitList.add(new Apple());
fruitList.add(new Orange());
</code></pre>
<p>但是</p>
<pre><code class="language-Java">fruitList.add(new Object());
</code></pre>
<p>却不行，why?因为在编译时无法确认具体的fruitList持有的是Fruit的哪一个父类，要想确定就不能用泛型了。所以就无法往里面写入Fruit的父类型对象。</p>
<p>所以我们可以从Java Collctions copy方法的签名可以看出</p>
<pre><code class="language-Java">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
</code></pre>
<p>dest集合持有？super T ，可以往里面写入所有T及其子类对象，而src集合持有？ extends T泛型。可以确保的是从里面读取的数据都是T及其子类。所以可以写入dest了。</p>
<p>PS:Java 类的final方法和static不能复写</p>
<h2 id="reference">Reference</h2>
<p>1：https://www.cnblogs.com/ygj0930/p/6554103.html</p>
<p>2:  http://www.importnew.com/8966.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android中Activity数据的保存和恢复 ]]></title>
        <id>https://philadelphia.github.io/post/android-zhong-activity-shu-ju-de-bao-cun-he-hui-fu</id>
        <link href="https://philadelphia.github.io/post/android-zhong-activity-shu-ju-de-bao-cun-he-hui-fu">
        </link>
        <updated>2019-08-16T10:03:02.000Z</updated>
        <content type="html"><![CDATA[<p>在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。</p>
<p>突发情况都有哪些？</p>
<p>因为本文讨论的是当一些突发情况的出现时，对数据的保存和恢复。所以现在总结一下突发情况应该都有哪些？</p>
<pre><code>1. 点击back键
2. 点击锁屏键
3. 点击home键
4. 其他APP进入前台
5. 启动了另一个Activity
6. 屏幕方向旋转
7. APP被Kill
</code></pre>
<h2 id=""></h2>
<p>现在我们创建一个Activity并复写其中的关键方法：<br>
​	<br>
package com.example.activitytest;</p>
<pre><code>	import android.content.Intent;
	import android.os.Bundle;
	import android.support.v7.app.AppCompatActivity;
	import android.util.Log;
	import android.widget.Button;
	
	import butterknife.BindView;
	import butterknife.ButterKnife;
	import butterknife.OnClick;
	
	public class MainActivity extends AppCompatActivity {
</code></pre>
<p>​	<br>
@BindView(R.id.btn_secondActivity)<br>
Button btnSecondActivity;<br>
private static final String TAG = &quot;MainActivity&quot;;</p>
<pre><code>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.i(TAG, &quot;onCreate: &quot;);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        Log.i(TAG, &quot;onRestart: &quot;);
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.i(TAG, &quot;onStart: &quot;);
    }

    @Override
    protected void onResume() {
        Log.i(TAG, &quot;onResume: &quot;);
        super.onResume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.i(TAG, &quot;onPause: &quot;);
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i(TAG, &quot;onStop: &quot;);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i(TAG, &quot;onDestroy: &quot;);
    }

    @OnClick(R.id.btn_secondActivity)
    public void onViewClicked() {
        startActivity(new Intent(MainActivity.this, SecondActivity.class));
    }
</code></pre>
<p>​	<br>
@Override<br>
protected void onSaveInstanceState(Bundle outState) {<br>
Log.i(TAG, &quot;onSaveInstanceState: &quot;);<br>
super.onSaveInstanceState(outState);<br>
}</p>
<pre><code>    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        Log.i(TAG, &quot;onRestoreInstanceState: &quot;);
    }

}
</code></pre>
<p>来看看各种情况下，Activity会调用哪些方法。</p>
<ol>
<li>
<p>点击back键</p>
<pre><code>09-26 16:00:02.124 21636-21636/com.example.activitytest I/MainActivity: onPause: 

09-26 16:00:02.575 21636-21636/com.example.activitytest I/MainActivity: onStop: 
09-26 16:00:02.575 21636-21636/com.example.activitytest I/MainActivity: onDestroy: 
</code></pre>
</li>
<li>
<p>点击锁屏键<br>
​	<br>
09-26 16:02:14.453 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:02:14.497 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:02:14.498 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>点击home键<br>
​	<br>
09-26 16:02:54.239 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:02:54.306 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
09-26 16:02:54.355 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>其他APP进入前台<br>
​	<br>
09-26 16:04:02.658 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>启动了另一个Activity</p>
<p>09-26 16:04:02.658 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:04:03.159 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
<li>
<p>屏幕方向旋转</p>
<p>​</p>
<pre><code class="language-java">09-26 16:04:51.199 21636-21636/com.example.activitytest I/MainActivity: onPause: 
09-26 16:04:51.199 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState: 
09-26 16:04:51.201 21636-21636/com.example.activitytest I/MainActivity: onStop: 
09-26 16:04:51.201 21636-21636/com.example.activitytest I/MainActivity: onDestroy: 
09-26 16:04:51.220 21636-21636/com.example.activitytest I/MainActivity: onCreate: 
09-26 16:04:51.250 21636-21636/com.example.activitytest I/MainActivity: onStart: 
09-26 16:04:51.250 21636-21636/com.example.activitytest I/MainActivity: 
</code></pre>
<p>onRestoreInstanceState:<br>
​	09-26 16:04:51.252 21636-21636/com.example.activitytest I/MainActivity: onResume:</p>
</li>
<li>
<p>APP被Kill<br>
​	<br>
09-26 16:05:17.544 21636-21636/com.example.activitytest I/MainActivity: onPause:<br>
​	09-26 16:05:17.601 21636-21636/com.example.activitytest I/MainActivity: onSaveInstanceState:<br>
​	09-26 16:05:17.611 21636-21636/com.example.activitytest I/MainActivity: onStop:</p>
</li>
</ol>
<p>当APP处在前台，能与用户交互的情况下，出现上述的突发事件时，只有点击back键，onSaveInstanceState方法不会调用。其余的情况下， 该方法一律都会调用，并且onPause方法是必然会调用的.<br>
我们可以看一下onSaveInstanceState()方法的注释<br>
​	<br>
/**<br>
* Called to retrieve per-instance state from an activity before being killed<br>
* so that the state can be restored in {@link #onCreate} or<br>
* {@link #onRestoreInstanceState} (the {@link Bundle} populated by this method<br>
* will be passed to both).<br>
*<br>
* <p>This method is called before an activity may be killed so that when it<br>
* comes back some time in the future it can restore its state.  For example,<br>
* if activity B is launched in front of activity A, and at some point activity<br>
* A is killed to reclaim resources, activity A will have a chance to save the<br>
* current state of its user interface via this method so that when the user<br>
* returns to activity A, the state of the user interface can be restored<br>
* via {@link #onCreate} or {@link #onRestoreInstanceState}.<br>
*<br>
* <p>Do not confuse this method with activity lifecycle callbacks such as<br>
* {@link #onPause}, which is always called when an activity is being placed<br>
* in the background or on its way to destruction, or {@link #onStop} which<br>
* is called before destruction.  One example of when {@link #onPause} and<br>
* {@link #onStop} is called and not this method is when a user navigates back<br>
* from activity B to activity A: there is no need to call {@link #onSaveInstanceState}<br>
* on B because that particular instance will never be restored, so the<br>
* system avoids calling it.  An example when {@link #onPause} is called and<br>
* not {@link #onSaveInstanceState} is when activity B is launched in front of activity A:<br>
* the system may avoid calling {@link #onSaveInstanceState} on activity A if it isn't<br>
* killed during the lifetime of B since the state of the user interface of<br>
* A will stay intact.<br>
*<br>
* <p>The default implementation takes care of most of the UI per-instance<br>
* state for you by calling {@link android.view.View#onSaveInstanceState()} on each<br>
* view in the hierarchy that has an id, and by saving the id of the currently<br>
* focused view (all of which is restored by the default implementation of<br>
* {@link #onRestoreInstanceState}).  If you override this method to save additional<br>
* information not captured by each individual view, you will likely want to<br>
* call through to the default implementation, otherwise be prepared to save<br>
* all of the state of each view yourself.<br>
*<br>
* <p>If called, this method will occur before {@link #onStop}.  There are<br>
* no guarantees about whether it will occur before or after {@link #onPause}.<br>
*<br>
* @param outState Bundle in which to place your saved state.<br>
* 这个方法在Activity被Killed之前调用去保存Activity的每个实体的状态，所以状态可以在<code>onCreat 	 * 或者</code>onRestoreInstanceState<code>被恢复。通过这个方法传递过去的</code>Bundle<code>* 这个方法在一个Activity被killed之前调用，所以当它将来恢复时可以恢复它的状态。比如：如果Activity B 	 * 在Acitivity A之前入站。如果在某一时刻A被销毁去释放资源，那么A将有机会调用该方法去保存它的用户UI的状态。 	 * 因此，当用户返回A时。用户状态可以被恢复。 	 * 不要将这个方法和Activity的生命周期回掉比如</code>onPause<code>，</code>onPause<code>在Activity被取代或者销毁时调用。</code>onStop<code>在被销毁之前 	 * 调用。一个</code>onPause<code>和</code>onStop<code>被调用但是</code>onSaveInstanceState<code>没被调用的情况是当用户从B回退到A时。不需要调用B的 	 *</code>onSaveInstanceState<code>* 一个</code>onPause<code>被调用但是</code>onSaveInstanceState<code>没被Blaunch 在A的上面时。系统避免调用A的</code>onSaveInstanceState<code>* 如果A在B的生命周期内没有被销毁。所以A的用户状态将保持不变。 	 * 可以通过给View设置ID。可以自动保存每个View的状态。 	 * 如果这个方法被调用了。这个方法将在</code>onStop<code>之前调用。但是不保证和</code>onPause`的调用顺序。<br>
*</p>
<p>google工程师们对onSaveInstanceState如此设计就是让其完成对一些临时的、非永久数据存储并进行恢复。但是一些永久性质的数据，比如插入数据库的操作，我们应该在什么方法中对其进行保存呢？</p>
<pre><code>onPause
onPuase的解释是：onPause(), onStop(), onDestroy() are &quot;killable after&quot; lifecycle methods. This indicates whether or not the system can kill the process hosting the activity at any time after the method returns, without executing another line of the activity's code. Because onPause() is the first of the three, once the activity is created, onPause() is the last method that's guaranteed to be called before the process can be killed—if the system must recover memory in an emergency, then onStop() and onDestroy() might not be called. Therefore, you should use onPause() to write crucial persistent data (such as user edits) to storage. However, you should be selective about what information must be retained during onPause(), because any blocking procedures in this method block the transition to the next activity and slow the user experience.
</code></pre>
<p>翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得onPause是持久化相关数据的最后的可靠时机。当然onPause方法不能做大量的操作，这会影响下一个Activity入栈</p>
<p>最后	我们来一句话总结一下：</p>
<h2 id="临时数据使用onsaveinstancestate保存恢复永久性数据使用onpause方法保存">临时数据使用onSaveInstanceState保存恢复，永久性数据使用onPause方法保存。</h2>
<p>参考：</p>
<p>1.<a href="http://www.jianshu.com/p/6622434511f7" title="http://www.jianshu.com/p/6622434511f7">http://www.jianshu.com/p/6622434511f7</a></p>
<p>2.<a href="http://blog.csdn.net/lonelyroamer/article/details/8927940" title="http://blog.csdn.net/lonelyroamer/article/details/8927940">http://blog.csdn.net/lonelyroamer/article/details/8927940</a></p>
]]></content>
    </entry>
</feed>